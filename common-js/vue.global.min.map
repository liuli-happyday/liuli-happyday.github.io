{"version":3,"sources":["jsdelivr-header.js","/npm/vue@3.2.31/dist/vue.global.js"],"names":[],"mappings":"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","file":"/npm/vue@3.2.31/dist/vue.global.js","sourceRoot":"","sourcesContent":["/**\n * Minified by jsDelivr using Terser v5.10.0.\n * Original file: /npm/vue@3.2.31/dist/vue.global.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n","var Vue = (function (exports) {\n  'use strict';\n\n  /**\r\n   * Make a map and return a function for checking if a key\r\n   * is in that map.\r\n   * IMPORTANT: all calls of this function must be prefixed with\r\n   * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n   * So that rollup can tree-shake them if necessary.\r\n   */\r\n  function makeMap(str, expectsLowerCase) {\r\n      const map = Object.create(null);\r\n      const list = str.split(',');\r\n      for (let i = 0; i < list.length; i++) {\r\n          map[list[i]] = true;\r\n      }\r\n      return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n  }\n\n  /**\r\n   * dev only flag -> name mapping\r\n   */\r\n  const PatchFlagNames = {\r\n      [1 /* TEXT */]: `TEXT`,\r\n      [2 /* CLASS */]: `CLASS`,\r\n      [4 /* STYLE */]: `STYLE`,\r\n      [8 /* PROPS */]: `PROPS`,\r\n      [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n      [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n      [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n      [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n      [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n      [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n      [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n      [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n      [-1 /* HOISTED */]: `HOISTED`,\r\n      [-2 /* BAIL */]: `BAIL`\r\n  };\n\n  /**\r\n   * Dev only\r\n   */\r\n  const slotFlagsText = {\r\n      [1 /* STABLE */]: 'STABLE',\r\n      [2 /* DYNAMIC */]: 'DYNAMIC',\r\n      [3 /* FORWARDED */]: 'FORWARDED'\r\n  };\n\n  const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n      'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n      'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\n  const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\n  const range = 2;\r\n  function generateCodeFrame(source, start = 0, end = source.length) {\r\n      // Split the content into individual lines but capture the newline sequence\r\n      // that separated each line. This is important because the actual sequence is\r\n      // needed to properly take into account the full line length for offset\r\n      // comparison\r\n      let lines = source.split(/(\\r?\\n)/);\r\n      // Separate the lines and newline sequences into separate arrays for easier referencing\r\n      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n      lines = lines.filter((_, idx) => idx % 2 === 0);\r\n      let count = 0;\r\n      const res = [];\r\n      for (let i = 0; i < lines.length; i++) {\r\n          count +=\r\n              lines[i].length +\r\n                  ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n          if (count >= start) {\r\n              for (let j = i - range; j <= i + range || end > count; j++) {\r\n                  if (j < 0 || j >= lines.length)\r\n                      continue;\r\n                  const line = j + 1;\r\n                  res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                  const lineLength = lines[j].length;\r\n                  const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                  if (j === i) {\r\n                      // push underline\r\n                      const pad = start - (count - (lineLength + newLineSeqLength));\r\n                      const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                      res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                  }\r\n                  else if (j > i) {\r\n                      if (end > count) {\r\n                          const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                          res.push(`   |  ` + '^'.repeat(length));\r\n                      }\r\n                      count += lineLength + newLineSeqLength;\r\n                  }\r\n              }\r\n              break;\r\n          }\r\n      }\r\n      return res.join('\\n');\r\n  }\n\n  /**\r\n   * On the client we only need to offer special cases for boolean attributes that\r\n   * have different names from their corresponding dom properties:\r\n   * - itemscope -> N/A\r\n   * - allowfullscreen -> allowFullscreen\r\n   * - formnovalidate -> formNoValidate\r\n   * - ismap -> isMap\r\n   * - nomodule -> noModule\r\n   * - novalidate -> noValidate\r\n   * - readonly -> readOnly\r\n   */\r\n  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\n  const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n  /**\r\n   * Boolean attributes should be included if the value is truthy or ''.\r\n   * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n   */\r\n  function includeBooleanAttr(value) {\r\n      return !!value || value === '';\r\n  }\n\n  function normalizeStyle(value) {\r\n      if (isArray(value)) {\r\n          const res = {};\r\n          for (let i = 0; i < value.length; i++) {\r\n              const item = value[i];\r\n              const normalized = isString(item)\r\n                  ? parseStringStyle(item)\r\n                  : normalizeStyle(item);\r\n              if (normalized) {\r\n                  for (const key in normalized) {\r\n                      res[key] = normalized[key];\r\n                  }\r\n              }\r\n          }\r\n          return res;\r\n      }\r\n      else if (isString(value)) {\r\n          return value;\r\n      }\r\n      else if (isObject(value)) {\r\n          return value;\r\n      }\r\n  }\r\n  const listDelimiterRE = /;(?![^(]*\\))/g;\r\n  const propertyDelimiterRE = /:(.+)/;\r\n  function parseStringStyle(cssText) {\r\n      const ret = {};\r\n      cssText.split(listDelimiterRE).forEach(item => {\r\n          if (item) {\r\n              const tmp = item.split(propertyDelimiterRE);\r\n              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n          }\r\n      });\r\n      return ret;\r\n  }\r\n  function normalizeClass(value) {\r\n      let res = '';\r\n      if (isString(value)) {\r\n          res = value;\r\n      }\r\n      else if (isArray(value)) {\r\n          for (let i = 0; i < value.length; i++) {\r\n              const normalized = normalizeClass(value[i]);\r\n              if (normalized) {\r\n                  res += normalized + ' ';\r\n              }\r\n          }\r\n      }\r\n      else if (isObject(value)) {\r\n          for (const name in value) {\r\n              if (value[name]) {\r\n                  res += name + ' ';\r\n              }\r\n          }\r\n      }\r\n      return res.trim();\r\n  }\r\n  function normalizeProps(props) {\r\n      if (!props)\r\n          return null;\r\n      let { class: klass, style } = props;\r\n      if (klass && !isString(klass)) {\r\n          props.class = normalizeClass(klass);\r\n      }\r\n      if (style) {\r\n          props.style = normalizeStyle(style);\r\n      }\r\n      return props;\r\n  }\n\n  // These tag configs are shared between compiler-dom and runtime-dom, so they\r\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\n  const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n      'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n      'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n      'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n      'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n      'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n      'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n      'option,output,progress,select,textarea,details,dialog,menu,' +\r\n      'summary,template,blockquote,iframe,tfoot';\r\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\n  const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n      'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n      'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n      'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n      'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n      'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n      'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n      'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n      'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n      'text,textPath,title,tspan,unknown,use,view';\r\n  const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n  /**\r\n   * Compiler only.\r\n   * Do NOT use in runtime code paths unless behind `true` flag.\r\n   */\r\n  const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\n  /**\r\n   * Compiler only.\r\n   * Do NOT use in runtime code paths unless behind `true` flag.\r\n   */\r\n  const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\n  /**\r\n   * Compiler only.\r\n   * Do NOT use in runtime code paths unless behind `true` flag.\r\n   */\r\n  const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n  function looseCompareArrays(a, b) {\r\n      if (a.length !== b.length)\r\n          return false;\r\n      let equal = true;\r\n      for (let i = 0; equal && i < a.length; i++) {\r\n          equal = looseEqual(a[i], b[i]);\r\n      }\r\n      return equal;\r\n  }\r\n  function looseEqual(a, b) {\r\n      if (a === b)\r\n          return true;\r\n      let aValidType = isDate(a);\r\n      let bValidType = isDate(b);\r\n      if (aValidType || bValidType) {\r\n          return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n      }\r\n      aValidType = isArray(a);\r\n      bValidType = isArray(b);\r\n      if (aValidType || bValidType) {\r\n          return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n      }\r\n      aValidType = isObject(a);\r\n      bValidType = isObject(b);\r\n      if (aValidType || bValidType) {\r\n          /* istanbul ignore if: this if will probably never be called */\r\n          if (!aValidType || !bValidType) {\r\n              return false;\r\n          }\r\n          const aKeysCount = Object.keys(a).length;\r\n          const bKeysCount = Object.keys(b).length;\r\n          if (aKeysCount !== bKeysCount) {\r\n              return false;\r\n          }\r\n          for (const key in a) {\r\n              const aHasKey = a.hasOwnProperty(key);\r\n              const bHasKey = b.hasOwnProperty(key);\r\n              if ((aHasKey && !bHasKey) ||\r\n                  (!aHasKey && bHasKey) ||\r\n                  !looseEqual(a[key], b[key])) {\r\n                  return false;\r\n              }\r\n          }\r\n      }\r\n      return String(a) === String(b);\r\n  }\r\n  function looseIndexOf(arr, val) {\r\n      return arr.findIndex(item => looseEqual(item, val));\r\n  }\n\n  /**\r\n   * For converting {{ interpolation }} values to displayed strings.\r\n   * @private\r\n   */\r\n  const toDisplayString = (val) => {\r\n      return isString(val)\r\n          ? val\r\n          : val == null\r\n              ? ''\r\n              : isArray(val) ||\r\n                  (isObject(val) &&\r\n                      (val.toString === objectToString || !isFunction(val.toString)))\r\n                  ? JSON.stringify(val, replacer, 2)\r\n                  : String(val);\r\n  };\r\n  const replacer = (_key, val) => {\r\n      // can't use isRef here since @vue/shared has no deps\r\n      if (val && val.__v_isRef) {\r\n          return replacer(_key, val.value);\r\n      }\r\n      else if (isMap(val)) {\r\n          return {\r\n              [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                  entries[`${key} =>`] = val;\r\n                  return entries;\r\n              }, {})\r\n          };\r\n      }\r\n      else if (isSet(val)) {\r\n          return {\r\n              [`Set(${val.size})`]: [...val.values()]\r\n          };\r\n      }\r\n      else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n          return String(val);\r\n      }\r\n      return val;\r\n  };\n\n  const EMPTY_OBJ = Object.freeze({})\r\n      ;\r\n  const EMPTY_ARR = Object.freeze([]) ;\r\n  const NOOP = () => { };\r\n  /**\r\n   * Always return false.\r\n   */\r\n  const NO = () => false;\r\n  const onRE = /^on[^a-z]/;\r\n  const isOn = (key) => onRE.test(key);\r\n  const isModelListener = (key) => key.startsWith('onUpdate:');\r\n  const extend = Object.assign;\r\n  const remove = (arr, el) => {\r\n      const i = arr.indexOf(el);\r\n      if (i > -1) {\r\n          arr.splice(i, 1);\r\n      }\r\n  };\r\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\r\n  const hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\n  const isArray = Array.isArray;\r\n  const isMap = (val) => toTypeString(val) === '[object Map]';\r\n  const isSet = (val) => toTypeString(val) === '[object Set]';\r\n  const isDate = (val) => val instanceof Date;\r\n  const isFunction = (val) => typeof val === 'function';\r\n  const isString = (val) => typeof val === 'string';\r\n  const isSymbol = (val) => typeof val === 'symbol';\r\n  const isObject = (val) => val !== null && typeof val === 'object';\r\n  const isPromise = (val) => {\r\n      return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n  };\r\n  const objectToString = Object.prototype.toString;\r\n  const toTypeString = (value) => objectToString.call(value);\r\n  const toRawType = (value) => {\r\n      // extract \"RawType\" from strings like \"[object RawType]\"\r\n      return toTypeString(value).slice(8, -1);\r\n  };\r\n  const isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\n  const isIntegerKey = (key) => isString(key) &&\r\n      key !== 'NaN' &&\r\n      key[0] !== '-' &&\r\n      '' + parseInt(key, 10) === key;\r\n  const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n      'onVnodeBeforeMount,onVnodeMounted,' +\r\n      'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n      'onVnodeBeforeUnmount,onVnodeUnmounted');\r\n  const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\r\n  const cacheStringFunction = (fn) => {\r\n      const cache = Object.create(null);\r\n      return ((str) => {\r\n          const hit = cache[str];\r\n          return hit || (cache[str] = fn(str));\r\n      });\r\n  };\r\n  const camelizeRE = /-(\\w)/g;\r\n  /**\r\n   * @private\r\n   */\r\n  const camelize = cacheStringFunction((str) => {\r\n      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n  });\r\n  const hyphenateRE = /\\B([A-Z])/g;\r\n  /**\r\n   * @private\r\n   */\r\n  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n  /**\r\n   * @private\r\n   */\r\n  const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n  /**\r\n   * @private\r\n   */\r\n  const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\r\n  // compare whether a value has changed, accounting for NaN.\r\n  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\n  const invokeArrayFns = (fns, arg) => {\r\n      for (let i = 0; i < fns.length; i++) {\r\n          fns[i](arg);\r\n      }\r\n  };\r\n  const def = (obj, key, value) => {\r\n      Object.defineProperty(obj, key, {\r\n          configurable: true,\r\n          enumerable: false,\r\n          value\r\n      });\r\n  };\r\n  const toNumber = (val) => {\r\n      const n = parseFloat(val);\r\n      return isNaN(n) ? val : n;\r\n  };\r\n  let _globalThis;\r\n  const getGlobalThis = () => {\r\n      return (_globalThis ||\r\n          (_globalThis =\r\n              typeof globalThis !== 'undefined'\r\n                  ? globalThis\r\n                  : typeof self !== 'undefined'\r\n                      ? self\r\n                      : typeof window !== 'undefined'\r\n                          ? window\r\n                          : typeof global !== 'undefined'\r\n                              ? global\r\n                              : {}));\r\n  };\n\n  function warn(msg, ...args) {\r\n      console.warn(`[Vue warn] ${msg}`, ...args);\r\n  }\n\n  let activeEffectScope;\r\n  class EffectScope {\r\n      constructor(detached = false) {\r\n          this.active = true;\r\n          this.effects = [];\r\n          this.cleanups = [];\r\n          if (!detached && activeEffectScope) {\r\n              this.parent = activeEffectScope;\r\n              this.index =\r\n                  (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n          }\r\n      }\r\n      run(fn) {\r\n          if (this.active) {\r\n              try {\r\n                  activeEffectScope = this;\r\n                  return fn();\r\n              }\r\n              finally {\r\n                  activeEffectScope = this.parent;\r\n              }\r\n          }\r\n          else {\r\n              warn(`cannot run an inactive effect scope.`);\r\n          }\r\n      }\r\n      on() {\r\n          activeEffectScope = this;\r\n      }\r\n      off() {\r\n          activeEffectScope = this.parent;\r\n      }\r\n      stop(fromParent) {\r\n          if (this.active) {\r\n              let i, l;\r\n              for (i = 0, l = this.effects.length; i < l; i++) {\r\n                  this.effects[i].stop();\r\n              }\r\n              for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                  this.cleanups[i]();\r\n              }\r\n              if (this.scopes) {\r\n                  for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                      this.scopes[i].stop(true);\r\n                  }\r\n              }\r\n              // nested scope, dereference from parent to avoid memory leaks\r\n              if (this.parent && !fromParent) {\r\n                  // optimized O(1) removal\r\n                  const last = this.parent.scopes.pop();\r\n                  if (last && last !== this) {\r\n                      this.parent.scopes[this.index] = last;\r\n                      last.index = this.index;\r\n                  }\r\n              }\r\n              this.active = false;\r\n          }\r\n      }\r\n  }\r\n  function effectScope(detached) {\r\n      return new EffectScope(detached);\r\n  }\r\n  function recordEffectScope(effect, scope = activeEffectScope) {\r\n      if (scope && scope.active) {\r\n          scope.effects.push(effect);\r\n      }\r\n  }\r\n  function getCurrentScope() {\r\n      return activeEffectScope;\r\n  }\r\n  function onScopeDispose(fn) {\r\n      if (activeEffectScope) {\r\n          activeEffectScope.cleanups.push(fn);\r\n      }\r\n      else {\r\n          warn(`onScopeDispose() is called when there is no active effect scope` +\r\n              ` to be associated with.`);\r\n      }\r\n  }\n\n  const createDep = (effects) => {\r\n      const dep = new Set(effects);\r\n      dep.w = 0;\r\n      dep.n = 0;\r\n      return dep;\r\n  };\r\n  const wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\n  const newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\n  const initDepMarkers = ({ deps }) => {\r\n      if (deps.length) {\r\n          for (let i = 0; i < deps.length; i++) {\r\n              deps[i].w |= trackOpBit; // set was tracked\r\n          }\r\n      }\r\n  };\r\n  const finalizeDepMarkers = (effect) => {\r\n      const { deps } = effect;\r\n      if (deps.length) {\r\n          let ptr = 0;\r\n          for (let i = 0; i < deps.length; i++) {\r\n              const dep = deps[i];\r\n              if (wasTracked(dep) && !newTracked(dep)) {\r\n                  dep.delete(effect);\r\n              }\r\n              else {\r\n                  deps[ptr++] = dep;\r\n              }\r\n              // clear bits\r\n              dep.w &= ~trackOpBit;\r\n              dep.n &= ~trackOpBit;\r\n          }\r\n          deps.length = ptr;\r\n      }\r\n  };\n\n  const targetMap = new WeakMap();\r\n  // The number of effects currently being tracked recursively.\r\n  let effectTrackDepth = 0;\r\n  let trackOpBit = 1;\r\n  /**\r\n   * The bitwise track markers support at most 30 levels of recursion.\r\n   * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n   * When recursion depth is greater, fall back to using a full cleanup.\r\n   */\r\n  const maxMarkerBits = 30;\r\n  let activeEffect;\r\n  const ITERATE_KEY = Symbol('iterate' );\r\n  const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate' );\r\n  class ReactiveEffect {\r\n      constructor(fn, scheduler = null, scope) {\r\n          this.fn = fn;\r\n          this.scheduler = scheduler;\r\n          this.active = true;\r\n          this.deps = [];\r\n          this.parent = undefined;\r\n          recordEffectScope(this, scope);\r\n      }\r\n      run() {\r\n          if (!this.active) {\r\n              return this.fn();\r\n          }\r\n          let parent = activeEffect;\r\n          let lastShouldTrack = shouldTrack;\r\n          while (parent) {\r\n              if (parent === this) {\r\n                  return;\r\n              }\r\n              parent = parent.parent;\r\n          }\r\n          try {\r\n              this.parent = activeEffect;\r\n              activeEffect = this;\r\n              shouldTrack = true;\r\n              trackOpBit = 1 << ++effectTrackDepth;\r\n              if (effectTrackDepth <= maxMarkerBits) {\r\n                  initDepMarkers(this);\r\n              }\r\n              else {\r\n                  cleanupEffect(this);\r\n              }\r\n              return this.fn();\r\n          }\r\n          finally {\r\n              if (effectTrackDepth <= maxMarkerBits) {\r\n                  finalizeDepMarkers(this);\r\n              }\r\n              trackOpBit = 1 << --effectTrackDepth;\r\n              activeEffect = this.parent;\r\n              shouldTrack = lastShouldTrack;\r\n              this.parent = undefined;\r\n          }\r\n      }\r\n      stop() {\r\n          if (this.active) {\r\n              cleanupEffect(this);\r\n              if (this.onStop) {\r\n                  this.onStop();\r\n              }\r\n              this.active = false;\r\n          }\r\n      }\r\n  }\r\n  function cleanupEffect(effect) {\r\n      const { deps } = effect;\r\n      if (deps.length) {\r\n          for (let i = 0; i < deps.length; i++) {\r\n              deps[i].delete(effect);\r\n          }\r\n          deps.length = 0;\r\n      }\r\n  }\r\n  function effect(fn, options) {\r\n      if (fn.effect) {\r\n          fn = fn.effect.fn;\r\n      }\r\n      const _effect = new ReactiveEffect(fn);\r\n      if (options) {\r\n          extend(_effect, options);\r\n          if (options.scope)\r\n              recordEffectScope(_effect, options.scope);\r\n      }\r\n      if (!options || !options.lazy) {\r\n          _effect.run();\r\n      }\r\n      const runner = _effect.run.bind(_effect);\r\n      runner.effect = _effect;\r\n      return runner;\r\n  }\r\n  function stop(runner) {\r\n      runner.effect.stop();\r\n  }\r\n  let shouldTrack = true;\r\n  const trackStack = [];\r\n  function pauseTracking() {\r\n      trackStack.push(shouldTrack);\r\n      shouldTrack = false;\r\n  }\r\n  function resetTracking() {\r\n      const last = trackStack.pop();\r\n      shouldTrack = last === undefined ? true : last;\r\n  }\r\n  function track(target, type, key) {\r\n      if (shouldTrack && activeEffect) {\r\n          let depsMap = targetMap.get(target);\r\n          if (!depsMap) {\r\n              targetMap.set(target, (depsMap = new Map()));\r\n          }\r\n          let dep = depsMap.get(key);\r\n          if (!dep) {\r\n              depsMap.set(key, (dep = createDep()));\r\n          }\r\n          const eventInfo = { effect: activeEffect, target, type, key }\r\n              ;\r\n          trackEffects(dep, eventInfo);\r\n      }\r\n  }\r\n  function trackEffects(dep, debuggerEventExtraInfo) {\r\n      let shouldTrack = false;\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n          if (!newTracked(dep)) {\r\n              dep.n |= trackOpBit; // set newly tracked\r\n              shouldTrack = !wasTracked(dep);\r\n          }\r\n      }\r\n      else {\r\n          // Full cleanup mode.\r\n          shouldTrack = !dep.has(activeEffect);\r\n      }\r\n      if (shouldTrack) {\r\n          dep.add(activeEffect);\r\n          activeEffect.deps.push(dep);\r\n          if (activeEffect.onTrack) {\r\n              activeEffect.onTrack(Object.assign({\r\n                  effect: activeEffect\r\n              }, debuggerEventExtraInfo));\r\n          }\r\n      }\r\n  }\r\n  function trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n      const depsMap = targetMap.get(target);\r\n      if (!depsMap) {\r\n          // never been tracked\r\n          return;\r\n      }\r\n      let deps = [];\r\n      if (type === \"clear\" /* CLEAR */) {\r\n          // collection being cleared\r\n          // trigger all effects for target\r\n          deps = [...depsMap.values()];\r\n      }\r\n      else if (key === 'length' && isArray(target)) {\r\n          depsMap.forEach((dep, key) => {\r\n              if (key === 'length' || key >= newValue) {\r\n                  deps.push(dep);\r\n              }\r\n          });\r\n      }\r\n      else {\r\n          // schedule runs for SET | ADD | DELETE\r\n          if (key !== void 0) {\r\n              deps.push(depsMap.get(key));\r\n          }\r\n          // also run for iteration key on ADD | DELETE | Map.SET\r\n          switch (type) {\r\n              case \"add\" /* ADD */:\r\n                  if (!isArray(target)) {\r\n                      deps.push(depsMap.get(ITERATE_KEY));\r\n                      if (isMap(target)) {\r\n                          deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                      }\r\n                  }\r\n                  else if (isIntegerKey(key)) {\r\n                      // new index added to array -> length changes\r\n                      deps.push(depsMap.get('length'));\r\n                  }\r\n                  break;\r\n              case \"delete\" /* DELETE */:\r\n                  if (!isArray(target)) {\r\n                      deps.push(depsMap.get(ITERATE_KEY));\r\n                      if (isMap(target)) {\r\n                          deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                      }\r\n                  }\r\n                  break;\r\n              case \"set\" /* SET */:\r\n                  if (isMap(target)) {\r\n                      deps.push(depsMap.get(ITERATE_KEY));\r\n                  }\r\n                  break;\r\n          }\r\n      }\r\n      const eventInfo = { target, type, key, newValue, oldValue, oldTarget }\r\n          ;\r\n      if (deps.length === 1) {\r\n          if (deps[0]) {\r\n              {\r\n                  triggerEffects(deps[0], eventInfo);\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          const effects = [];\r\n          for (const dep of deps) {\r\n              if (dep) {\r\n                  effects.push(...dep);\r\n              }\r\n          }\r\n          {\r\n              triggerEffects(createDep(effects), eventInfo);\r\n          }\r\n      }\r\n  }\r\n  function triggerEffects(dep, debuggerEventExtraInfo) {\r\n      // spread into array for stabilization\r\n      for (const effect of isArray(dep) ? dep : [...dep]) {\r\n          if (effect !== activeEffect || effect.allowRecurse) {\r\n              if (effect.onTrigger) {\r\n                  effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\r\n              }\r\n              if (effect.scheduler) {\r\n                  effect.scheduler();\r\n              }\r\n              else {\r\n                  effect.run();\r\n              }\r\n          }\r\n      }\r\n  }\n\n  const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\r\n  const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n      .map(key => Symbol[key])\r\n      .filter(isSymbol));\r\n  const get = /*#__PURE__*/ createGetter();\r\n  const shallowGet = /*#__PURE__*/ createGetter(false, true);\r\n  const readonlyGet = /*#__PURE__*/ createGetter(true);\r\n  const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\n  const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\n  function createArrayInstrumentations() {\r\n      const instrumentations = {};\r\n      ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n          instrumentations[key] = function (...args) {\r\n              const arr = toRaw(this);\r\n              for (let i = 0, l = this.length; i < l; i++) {\r\n                  track(arr, \"get\" /* GET */, i + '');\r\n              }\r\n              // we run the method using the original args first (which may be reactive)\r\n              const res = arr[key](...args);\r\n              if (res === -1 || res === false) {\r\n                  // if that didn't work, run it again using raw values.\r\n                  return arr[key](...args.map(toRaw));\r\n              }\r\n              else {\r\n                  return res;\r\n              }\r\n          };\r\n      });\r\n      ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n          instrumentations[key] = function (...args) {\r\n              pauseTracking();\r\n              const res = toRaw(this)[key].apply(this, args);\r\n              resetTracking();\r\n              return res;\r\n          };\r\n      });\r\n      return instrumentations;\r\n  }\r\n  function createGetter(isReadonly = false, shallow = false) {\r\n      return function get(target, key, receiver) {\r\n          if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n              return !isReadonly;\r\n          }\r\n          else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n              return isReadonly;\r\n          }\r\n          else if (key === \"__v_isShallow\" /* IS_SHALLOW */) {\r\n              return shallow;\r\n          }\r\n          else if (key === \"__v_raw\" /* RAW */ &&\r\n              receiver ===\r\n                  (isReadonly\r\n                      ? shallow\r\n                          ? shallowReadonlyMap\r\n                          : readonlyMap\r\n                      : shallow\r\n                          ? shallowReactiveMap\r\n                          : reactiveMap).get(target)) {\r\n              return target;\r\n          }\r\n          const targetIsArray = isArray(target);\r\n          if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n              return Reflect.get(arrayInstrumentations, key, receiver);\r\n          }\r\n          const res = Reflect.get(target, key, receiver);\r\n          if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n              return res;\r\n          }\r\n          if (!isReadonly) {\r\n              track(target, \"get\" /* GET */, key);\r\n          }\r\n          if (shallow) {\r\n              return res;\r\n          }\r\n          if (isRef(res)) {\r\n              // ref unwrapping - does not apply for Array + integer key.\r\n              const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n              return shouldUnwrap ? res.value : res;\r\n          }\r\n          if (isObject(res)) {\r\n              // Convert returned value into a proxy as well. we do the isObject check\r\n              // here to avoid invalid value warning. Also need to lazy access readonly\r\n              // and reactive here to avoid circular dependency.\r\n              return isReadonly ? readonly(res) : reactive(res);\r\n          }\r\n          return res;\r\n      };\r\n  }\r\n  const set = /*#__PURE__*/ createSetter();\r\n  const shallowSet = /*#__PURE__*/ createSetter(true);\r\n  function createSetter(shallow = false) {\r\n      return function set(target, key, value, receiver) {\r\n          let oldValue = target[key];\r\n          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\r\n              return false;\r\n          }\r\n          if (!shallow && !isReadonly(value)) {\r\n              if (!isShallow(value)) {\r\n                  value = toRaw(value);\r\n                  oldValue = toRaw(oldValue);\r\n              }\r\n              if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                  oldValue.value = value;\r\n                  return true;\r\n              }\r\n          }\r\n          const hadKey = isArray(target) && isIntegerKey(key)\r\n              ? Number(key) < target.length\r\n              : hasOwn(target, key);\r\n          const result = Reflect.set(target, key, value, receiver);\r\n          // don't trigger if target is something up in the prototype chain of original\r\n          if (target === toRaw(receiver)) {\r\n              if (!hadKey) {\r\n                  trigger(target, \"add\" /* ADD */, key, value);\r\n              }\r\n              else if (hasChanged(value, oldValue)) {\r\n                  trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n              }\r\n          }\r\n          return result;\r\n      };\r\n  }\r\n  function deleteProperty(target, key) {\r\n      const hadKey = hasOwn(target, key);\r\n      const oldValue = target[key];\r\n      const result = Reflect.deleteProperty(target, key);\r\n      if (result && hadKey) {\r\n          trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n      }\r\n      return result;\r\n  }\r\n  function has(target, key) {\r\n      const result = Reflect.has(target, key);\r\n      if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n          track(target, \"has\" /* HAS */, key);\r\n      }\r\n      return result;\r\n  }\r\n  function ownKeys(target) {\r\n      track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n      return Reflect.ownKeys(target);\r\n  }\r\n  const mutableHandlers = {\r\n      get,\r\n      set,\r\n      deleteProperty,\r\n      has,\r\n      ownKeys\r\n  };\r\n  const readonlyHandlers = {\r\n      get: readonlyGet,\r\n      set(target, key) {\r\n          {\r\n              console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n          }\r\n          return true;\r\n      },\r\n      deleteProperty(target, key) {\r\n          {\r\n              console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n          }\r\n          return true;\r\n      }\r\n  };\r\n  const shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\r\n      get: shallowGet,\r\n      set: shallowSet\r\n  });\r\n  // Props handlers are special in the sense that it should not unwrap top-level\r\n  // refs (in order to allow refs to be explicitly passed down), but should\r\n  // retain the reactivity of the normal readonly object.\r\n  const shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\r\n      get: shallowReadonlyGet\r\n  });\n\n  const toShallow = (value) => value;\r\n  const getProto = (v) => Reflect.getPrototypeOf(v);\r\n  function get$1(target, key, isReadonly = false, isShallow = false) {\r\n      // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n      // of the value\r\n      target = target[\"__v_raw\" /* RAW */];\r\n      const rawTarget = toRaw(target);\r\n      const rawKey = toRaw(key);\r\n      if (key !== rawKey) {\r\n          !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n      }\r\n      !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n      const { has } = getProto(rawTarget);\r\n      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n      if (has.call(rawTarget, key)) {\r\n          return wrap(target.get(key));\r\n      }\r\n      else if (has.call(rawTarget, rawKey)) {\r\n          return wrap(target.get(rawKey));\r\n      }\r\n      else if (target !== rawTarget) {\r\n          // #3602 readonly(reactive(Map))\r\n          // ensure that the nested reactive `Map` can do tracking for itself\r\n          target.get(key);\r\n      }\r\n  }\r\n  function has$1(key, isReadonly = false) {\r\n      const target = this[\"__v_raw\" /* RAW */];\r\n      const rawTarget = toRaw(target);\r\n      const rawKey = toRaw(key);\r\n      if (key !== rawKey) {\r\n          !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n      }\r\n      !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n      return key === rawKey\r\n          ? target.has(key)\r\n          : target.has(key) || target.has(rawKey);\r\n  }\r\n  function size(target, isReadonly = false) {\r\n      target = target[\"__v_raw\" /* RAW */];\r\n      !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n      return Reflect.get(target, 'size', target);\r\n  }\r\n  function add(value) {\r\n      value = toRaw(value);\r\n      const target = toRaw(this);\r\n      const proto = getProto(target);\r\n      const hadKey = proto.has.call(target, value);\r\n      if (!hadKey) {\r\n          target.add(value);\r\n          trigger(target, \"add\" /* ADD */, value, value);\r\n      }\r\n      return this;\r\n  }\r\n  function set$1(key, value) {\r\n      value = toRaw(value);\r\n      const target = toRaw(this);\r\n      const { has, get } = getProto(target);\r\n      let hadKey = has.call(target, key);\r\n      if (!hadKey) {\r\n          key = toRaw(key);\r\n          hadKey = has.call(target, key);\r\n      }\r\n      else {\r\n          checkIdentityKeys(target, has, key);\r\n      }\r\n      const oldValue = get.call(target, key);\r\n      target.set(key, value);\r\n      if (!hadKey) {\r\n          trigger(target, \"add\" /* ADD */, key, value);\r\n      }\r\n      else if (hasChanged(value, oldValue)) {\r\n          trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n      }\r\n      return this;\r\n  }\r\n  function deleteEntry(key) {\r\n      const target = toRaw(this);\r\n      const { has, get } = getProto(target);\r\n      let hadKey = has.call(target, key);\r\n      if (!hadKey) {\r\n          key = toRaw(key);\r\n          hadKey = has.call(target, key);\r\n      }\r\n      else {\r\n          checkIdentityKeys(target, has, key);\r\n      }\r\n      const oldValue = get ? get.call(target, key) : undefined;\r\n      // forward the operation before queueing reactions\r\n      const result = target.delete(key);\r\n      if (hadKey) {\r\n          trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n      }\r\n      return result;\r\n  }\r\n  function clear() {\r\n      const target = toRaw(this);\r\n      const hadItems = target.size !== 0;\r\n      const oldTarget = isMap(target)\r\n              ? new Map(target)\r\n              : new Set(target)\r\n          ;\r\n      // forward the operation before queueing reactions\r\n      const result = target.clear();\r\n      if (hadItems) {\r\n          trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n      }\r\n      return result;\r\n  }\r\n  function createForEach(isReadonly, isShallow) {\r\n      return function forEach(callback, thisArg) {\r\n          const observed = this;\r\n          const target = observed[\"__v_raw\" /* RAW */];\r\n          const rawTarget = toRaw(target);\r\n          const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n          !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n          return target.forEach((value, key) => {\r\n              // important: make sure the callback is\r\n              // 1. invoked with the reactive map as `this` and 3rd arg\r\n              // 2. the value received should be a corresponding reactive/readonly.\r\n              return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n          });\r\n      };\r\n  }\r\n  function createIterableMethod(method, isReadonly, isShallow) {\r\n      return function (...args) {\r\n          const target = this[\"__v_raw\" /* RAW */];\r\n          const rawTarget = toRaw(target);\r\n          const targetIsMap = isMap(rawTarget);\r\n          const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n          const isKeyOnly = method === 'keys' && targetIsMap;\r\n          const innerIterator = target[method](...args);\r\n          const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n          !isReadonly &&\r\n              track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n          // return a wrapped iterator which returns observed versions of the\r\n          // values emitted from the real iterator\r\n          return {\r\n              // iterator protocol\r\n              next() {\r\n                  const { value, done } = innerIterator.next();\r\n                  return done\r\n                      ? { value, done }\r\n                      : {\r\n                          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                          done\r\n                      };\r\n              },\r\n              // iterable protocol\r\n              [Symbol.iterator]() {\r\n                  return this;\r\n              }\r\n          };\r\n      };\r\n  }\r\n  function createReadonlyMethod(type) {\r\n      return function (...args) {\r\n          {\r\n              const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n              console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n          }\r\n          return type === \"delete\" /* DELETE */ ? false : this;\r\n      };\r\n  }\r\n  function createInstrumentations() {\r\n      const mutableInstrumentations = {\r\n          get(key) {\r\n              return get$1(this, key);\r\n          },\r\n          get size() {\r\n              return size(this);\r\n          },\r\n          has: has$1,\r\n          add,\r\n          set: set$1,\r\n          delete: deleteEntry,\r\n          clear,\r\n          forEach: createForEach(false, false)\r\n      };\r\n      const shallowInstrumentations = {\r\n          get(key) {\r\n              return get$1(this, key, false, true);\r\n          },\r\n          get size() {\r\n              return size(this);\r\n          },\r\n          has: has$1,\r\n          add,\r\n          set: set$1,\r\n          delete: deleteEntry,\r\n          clear,\r\n          forEach: createForEach(false, true)\r\n      };\r\n      const readonlyInstrumentations = {\r\n          get(key) {\r\n              return get$1(this, key, true);\r\n          },\r\n          get size() {\r\n              return size(this, true);\r\n          },\r\n          has(key) {\r\n              return has$1.call(this, key, true);\r\n          },\r\n          add: createReadonlyMethod(\"add\" /* ADD */),\r\n          set: createReadonlyMethod(\"set\" /* SET */),\r\n          delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n          clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n          forEach: createForEach(true, false)\r\n      };\r\n      const shallowReadonlyInstrumentations = {\r\n          get(key) {\r\n              return get$1(this, key, true, true);\r\n          },\r\n          get size() {\r\n              return size(this, true);\r\n          },\r\n          has(key) {\r\n              return has$1.call(this, key, true);\r\n          },\r\n          add: createReadonlyMethod(\"add\" /* ADD */),\r\n          set: createReadonlyMethod(\"set\" /* SET */),\r\n          delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n          clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n          forEach: createForEach(true, true)\r\n      };\r\n      const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n      iteratorMethods.forEach(method => {\r\n          mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n          readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n          shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n          shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n      });\r\n      return [\r\n          mutableInstrumentations,\r\n          readonlyInstrumentations,\r\n          shallowInstrumentations,\r\n          shallowReadonlyInstrumentations\r\n      ];\r\n  }\r\n  const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\n  function createInstrumentationGetter(isReadonly, shallow) {\r\n      const instrumentations = shallow\r\n          ? isReadonly\r\n              ? shallowReadonlyInstrumentations\r\n              : shallowInstrumentations\r\n          : isReadonly\r\n              ? readonlyInstrumentations\r\n              : mutableInstrumentations;\r\n      return (target, key, receiver) => {\r\n          if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n              return !isReadonly;\r\n          }\r\n          else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n              return isReadonly;\r\n          }\r\n          else if (key === \"__v_raw\" /* RAW */) {\r\n              return target;\r\n          }\r\n          return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n              ? instrumentations\r\n              : target, key, receiver);\r\n      };\r\n  }\r\n  const mutableCollectionHandlers = {\r\n      get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n  };\r\n  const shallowCollectionHandlers = {\r\n      get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n  };\r\n  const readonlyCollectionHandlers = {\r\n      get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n  };\r\n  const shallowReadonlyCollectionHandlers = {\r\n      get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n  };\r\n  function checkIdentityKeys(target, has, key) {\r\n      const rawKey = toRaw(key);\r\n      if (rawKey !== key && has.call(target, rawKey)) {\r\n          const type = toRawType(target);\r\n          console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n              `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n              `which can lead to inconsistencies. ` +\r\n              `Avoid differentiating between the raw and reactive versions ` +\r\n              `of an object and only use the reactive version if possible.`);\r\n      }\r\n  }\n\n  const reactiveMap = new WeakMap();\r\n  const shallowReactiveMap = new WeakMap();\r\n  const readonlyMap = new WeakMap();\r\n  const shallowReadonlyMap = new WeakMap();\r\n  function targetTypeMap(rawType) {\r\n      switch (rawType) {\r\n          case 'Object':\r\n          case 'Array':\r\n              return 1 /* COMMON */;\r\n          case 'Map':\r\n          case 'Set':\r\n          case 'WeakMap':\r\n          case 'WeakSet':\r\n              return 2 /* COLLECTION */;\r\n          default:\r\n              return 0 /* INVALID */;\r\n      }\r\n  }\r\n  function getTargetType(value) {\r\n      return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n          ? 0 /* INVALID */\r\n          : targetTypeMap(toRawType(value));\r\n  }\r\n  function reactive(target) {\r\n      // if trying to observe a readonly proxy, return the readonly version.\r\n      if (isReadonly(target)) {\r\n          return target;\r\n      }\r\n      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n  }\r\n  /**\r\n   * Return a shallowly-reactive copy of the original object, where only the root\r\n   * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n   * root level).\r\n   */\r\n  function shallowReactive(target) {\r\n      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n  }\r\n  /**\r\n   * Creates a readonly copy of the original object. Note the returned copy is not\r\n   * made reactive, but `readonly` can be called on an already reactive object.\r\n   */\r\n  function readonly(target) {\r\n      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n  }\r\n  /**\r\n   * Returns a reactive-copy of the original object, where only the root level\r\n   * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n   * returned properties.\r\n   * This is used for creating the props proxy object for stateful components.\r\n   */\r\n  function shallowReadonly(target) {\r\n      return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n  }\r\n  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n      if (!isObject(target)) {\r\n          {\r\n              console.warn(`value cannot be made reactive: ${String(target)}`);\r\n          }\r\n          return target;\r\n      }\r\n      // target is already a Proxy, return it.\r\n      // exception: calling readonly() on a reactive object\r\n      if (target[\"__v_raw\" /* RAW */] &&\r\n          !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n          return target;\r\n      }\r\n      // target already has corresponding Proxy\r\n      const existingProxy = proxyMap.get(target);\r\n      if (existingProxy) {\r\n          return existingProxy;\r\n      }\r\n      // only a whitelist of value types can be observed.\r\n      const targetType = getTargetType(target);\r\n      if (targetType === 0 /* INVALID */) {\r\n          return target;\r\n      }\r\n      const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n      proxyMap.set(target, proxy);\r\n      return proxy;\r\n  }\r\n  function isReactive(value) {\r\n      if (isReadonly(value)) {\r\n          return isReactive(value[\"__v_raw\" /* RAW */]);\r\n      }\r\n      return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n  }\r\n  function isReadonly(value) {\r\n      return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n  }\r\n  function isShallow(value) {\r\n      return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\r\n  }\r\n  function isProxy(value) {\r\n      return isReactive(value) || isReadonly(value);\r\n  }\r\n  function toRaw(observed) {\r\n      const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n      return raw ? toRaw(raw) : observed;\r\n  }\r\n  function markRaw(value) {\r\n      def(value, \"__v_skip\" /* SKIP */, true);\r\n      return value;\r\n  }\r\n  const toReactive = (value) => isObject(value) ? reactive(value) : value;\r\n  const toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\n  function trackRefValue(ref) {\r\n      if (shouldTrack && activeEffect) {\r\n          ref = toRaw(ref);\r\n          {\r\n              trackEffects(ref.dep || (ref.dep = createDep()), {\r\n                  target: ref,\r\n                  type: \"get\" /* GET */,\r\n                  key: 'value'\r\n              });\r\n          }\r\n      }\r\n  }\r\n  function triggerRefValue(ref, newVal) {\r\n      ref = toRaw(ref);\r\n      if (ref.dep) {\r\n          {\r\n              triggerEffects(ref.dep, {\r\n                  target: ref,\r\n                  type: \"set\" /* SET */,\r\n                  key: 'value',\r\n                  newValue: newVal\r\n              });\r\n          }\r\n      }\r\n  }\r\n  function isRef(r) {\r\n      return !!(r && r.__v_isRef === true);\r\n  }\r\n  function ref(value) {\r\n      return createRef(value, false);\r\n  }\r\n  function shallowRef(value) {\r\n      return createRef(value, true);\r\n  }\r\n  function createRef(rawValue, shallow) {\r\n      if (isRef(rawValue)) {\r\n          return rawValue;\r\n      }\r\n      return new RefImpl(rawValue, shallow);\r\n  }\r\n  class RefImpl {\r\n      constructor(value, __v_isShallow) {\r\n          this.__v_isShallow = __v_isShallow;\r\n          this.dep = undefined;\r\n          this.__v_isRef = true;\r\n          this._rawValue = __v_isShallow ? value : toRaw(value);\r\n          this._value = __v_isShallow ? value : toReactive(value);\r\n      }\r\n      get value() {\r\n          trackRefValue(this);\r\n          return this._value;\r\n      }\r\n      set value(newVal) {\r\n          newVal = this.__v_isShallow ? newVal : toRaw(newVal);\r\n          if (hasChanged(newVal, this._rawValue)) {\r\n              this._rawValue = newVal;\r\n              this._value = this.__v_isShallow ? newVal : toReactive(newVal);\r\n              triggerRefValue(this, newVal);\r\n          }\r\n      }\r\n  }\r\n  function triggerRef(ref) {\r\n      triggerRefValue(ref, ref.value );\r\n  }\r\n  function unref(ref) {\r\n      return isRef(ref) ? ref.value : ref;\r\n  }\r\n  const shallowUnwrapHandlers = {\r\n      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n      set: (target, key, value, receiver) => {\r\n          const oldValue = target[key];\r\n          if (isRef(oldValue) && !isRef(value)) {\r\n              oldValue.value = value;\r\n              return true;\r\n          }\r\n          else {\r\n              return Reflect.set(target, key, value, receiver);\r\n          }\r\n      }\r\n  };\r\n  function proxyRefs(objectWithRefs) {\r\n      return isReactive(objectWithRefs)\r\n          ? objectWithRefs\r\n          : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n  }\r\n  class CustomRefImpl {\r\n      constructor(factory) {\r\n          this.dep = undefined;\r\n          this.__v_isRef = true;\r\n          const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\r\n          this._get = get;\r\n          this._set = set;\r\n      }\r\n      get value() {\r\n          return this._get();\r\n      }\r\n      set value(newVal) {\r\n          this._set(newVal);\r\n      }\r\n  }\r\n  function customRef(factory) {\r\n      return new CustomRefImpl(factory);\r\n  }\r\n  function toRefs(object) {\r\n      if (!isProxy(object)) {\r\n          console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n      }\r\n      const ret = isArray(object) ? new Array(object.length) : {};\r\n      for (const key in object) {\r\n          ret[key] = toRef(object, key);\r\n      }\r\n      return ret;\r\n  }\r\n  class ObjectRefImpl {\r\n      constructor(_object, _key, _defaultValue) {\r\n          this._object = _object;\r\n          this._key = _key;\r\n          this._defaultValue = _defaultValue;\r\n          this.__v_isRef = true;\r\n      }\r\n      get value() {\r\n          const val = this._object[this._key];\r\n          return val === undefined ? this._defaultValue : val;\r\n      }\r\n      set value(newVal) {\r\n          this._object[this._key] = newVal;\r\n      }\r\n  }\r\n  function toRef(object, key, defaultValue) {\r\n      const val = object[key];\r\n      return isRef(val)\r\n          ? val\r\n          : new ObjectRefImpl(object, key, defaultValue);\r\n  }\n\n  class ComputedRefImpl {\r\n      constructor(getter, _setter, isReadonly, isSSR) {\r\n          this._setter = _setter;\r\n          this.dep = undefined;\r\n          this.__v_isRef = true;\r\n          this._dirty = true;\r\n          this.effect = new ReactiveEffect(getter, () => {\r\n              if (!this._dirty) {\r\n                  this._dirty = true;\r\n                  triggerRefValue(this);\r\n              }\r\n          });\r\n          this.effect.computed = this;\r\n          this.effect.active = this._cacheable = !isSSR;\r\n          this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n      }\r\n      get value() {\r\n          // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n          const self = toRaw(this);\r\n          trackRefValue(self);\r\n          if (self._dirty || !self._cacheable) {\r\n              self._dirty = false;\r\n              self._value = self.effect.run();\r\n          }\r\n          return self._value;\r\n      }\r\n      set value(newValue) {\r\n          this._setter(newValue);\r\n      }\r\n  }\r\n  function computed(getterOrOptions, debugOptions, isSSR = false) {\r\n      let getter;\r\n      let setter;\r\n      const onlyGetter = isFunction(getterOrOptions);\r\n      if (onlyGetter) {\r\n          getter = getterOrOptions;\r\n          setter = () => {\r\n                  console.warn('Write operation failed: computed value is readonly');\r\n              }\r\n              ;\r\n      }\r\n      else {\r\n          getter = getterOrOptions.get;\r\n          setter = getterOrOptions.set;\r\n      }\r\n      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\r\n      if (debugOptions && !isSSR) {\r\n          cRef.effect.onTrack = debugOptions.onTrack;\r\n          cRef.effect.onTrigger = debugOptions.onTrigger;\r\n      }\r\n      return cRef;\r\n  }\n\n  const stack = [];\r\n  function pushWarningContext(vnode) {\r\n      stack.push(vnode);\r\n  }\r\n  function popWarningContext() {\r\n      stack.pop();\r\n  }\r\n  function warn$1(msg, ...args) {\r\n      // avoid props formatting or warn handler tracking deps that might be mutated\r\n      // during patch, leading to infinite recursion.\r\n      pauseTracking();\r\n      const instance = stack.length ? stack[stack.length - 1].component : null;\r\n      const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n      const trace = getComponentTrace();\r\n      if (appWarnHandler) {\r\n          callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n              msg + args.join(''),\r\n              instance && instance.proxy,\r\n              trace\r\n                  .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                  .join('\\n'),\r\n              trace\r\n          ]);\r\n      }\r\n      else {\r\n          const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n          /* istanbul ignore if */\r\n          if (trace.length &&\r\n              // avoid spamming console during tests\r\n              !false) {\r\n              warnArgs.push(`\\n`, ...formatTrace(trace));\r\n          }\r\n          console.warn(...warnArgs);\r\n      }\r\n      resetTracking();\r\n  }\r\n  function getComponentTrace() {\r\n      let currentVNode = stack[stack.length - 1];\r\n      if (!currentVNode) {\r\n          return [];\r\n      }\r\n      // we can't just use the stack because it will be incomplete during updates\r\n      // that did not start from the root. Re-construct the parent chain using\r\n      // instance parent pointers.\r\n      const normalizedStack = [];\r\n      while (currentVNode) {\r\n          const last = normalizedStack[0];\r\n          if (last && last.vnode === currentVNode) {\r\n              last.recurseCount++;\r\n          }\r\n          else {\r\n              normalizedStack.push({\r\n                  vnode: currentVNode,\r\n                  recurseCount: 0\r\n              });\r\n          }\r\n          const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n          currentVNode = parentInstance && parentInstance.vnode;\r\n      }\r\n      return normalizedStack;\r\n  }\r\n  /* istanbul ignore next */\r\n  function formatTrace(trace) {\r\n      const logs = [];\r\n      trace.forEach((entry, i) => {\r\n          logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n      });\r\n      return logs;\r\n  }\r\n  function formatTraceEntry({ vnode, recurseCount }) {\r\n      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n      const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n      const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n      const close = `>` + postfix;\r\n      return vnode.props\r\n          ? [open, ...formatProps(vnode.props), close]\r\n          : [open + close];\r\n  }\r\n  /* istanbul ignore next */\r\n  function formatProps(props) {\r\n      const res = [];\r\n      const keys = Object.keys(props);\r\n      keys.slice(0, 3).forEach(key => {\r\n          res.push(...formatProp(key, props[key]));\r\n      });\r\n      if (keys.length > 3) {\r\n          res.push(` ...`);\r\n      }\r\n      return res;\r\n  }\r\n  /* istanbul ignore next */\r\n  function formatProp(key, value, raw) {\r\n      if (isString(value)) {\r\n          value = JSON.stringify(value);\r\n          return raw ? value : [`${key}=${value}`];\r\n      }\r\n      else if (typeof value === 'number' ||\r\n          typeof value === 'boolean' ||\r\n          value == null) {\r\n          return raw ? value : [`${key}=${value}`];\r\n      }\r\n      else if (isRef(value)) {\r\n          value = formatProp(key, toRaw(value.value), true);\r\n          return raw ? value : [`${key}=Ref<`, value, `>`];\r\n      }\r\n      else if (isFunction(value)) {\r\n          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n      }\r\n      else {\r\n          value = toRaw(value);\r\n          return raw ? value : [`${key}=`, value];\r\n      }\r\n  }\n\n  const ErrorTypeStrings = {\r\n      [\"sp\" /* SERVER_PREFETCH */]: 'serverPrefetch hook',\r\n      [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n      [\"c\" /* CREATED */]: 'created hook',\r\n      [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n      [\"m\" /* MOUNTED */]: 'mounted hook',\r\n      [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n      [\"u\" /* UPDATED */]: 'updated',\r\n      [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n      [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n      [\"a\" /* ACTIVATED */]: 'activated hook',\r\n      [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n      [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n      [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n      [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n      [0 /* SETUP_FUNCTION */]: 'setup function',\r\n      [1 /* RENDER_FUNCTION */]: 'render function',\r\n      [2 /* WATCH_GETTER */]: 'watcher getter',\r\n      [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n      [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n      [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n      [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n      [7 /* VNODE_HOOK */]: 'vnode hook',\r\n      [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n      [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n      [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n      [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n      [12 /* FUNCTION_REF */]: 'ref function',\r\n      [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n      [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n          'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\r\n  };\r\n  function callWithErrorHandling(fn, instance, type, args) {\r\n      let res;\r\n      try {\r\n          res = args ? fn(...args) : fn();\r\n      }\r\n      catch (err) {\r\n          handleError(err, instance, type);\r\n      }\r\n      return res;\r\n  }\r\n  function callWithAsyncErrorHandling(fn, instance, type, args) {\r\n      if (isFunction(fn)) {\r\n          const res = callWithErrorHandling(fn, instance, type, args);\r\n          if (res && isPromise(res)) {\r\n              res.catch(err => {\r\n                  handleError(err, instance, type);\r\n              });\r\n          }\r\n          return res;\r\n      }\r\n      const values = [];\r\n      for (let i = 0; i < fn.length; i++) {\r\n          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n      }\r\n      return values;\r\n  }\r\n  function handleError(err, instance, type, throwInDev = true) {\r\n      const contextVNode = instance ? instance.vnode : null;\r\n      if (instance) {\r\n          let cur = instance.parent;\r\n          // the exposed instance is the render proxy to keep it consistent with 2.x\r\n          const exposedInstance = instance.proxy;\r\n          // in production the hook receives only the error code\r\n          const errorInfo = ErrorTypeStrings[type] ;\r\n          while (cur) {\r\n              const errorCapturedHooks = cur.ec;\r\n              if (errorCapturedHooks) {\r\n                  for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                      if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                          return;\r\n                      }\r\n                  }\r\n              }\r\n              cur = cur.parent;\r\n          }\r\n          // app-level handling\r\n          const appErrorHandler = instance.appContext.config.errorHandler;\r\n          if (appErrorHandler) {\r\n              callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n              return;\r\n          }\r\n      }\r\n      logError(err, type, contextVNode, throwInDev);\r\n  }\r\n  function logError(err, type, contextVNode, throwInDev = true) {\r\n      {\r\n          const info = ErrorTypeStrings[type];\r\n          if (contextVNode) {\r\n              pushWarningContext(contextVNode);\r\n          }\r\n          warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n          if (contextVNode) {\r\n              popWarningContext();\r\n          }\r\n          // crash in dev by default so it's more noticeable\r\n          if (throwInDev) {\r\n              throw err;\r\n          }\r\n          else {\r\n              console.error(err);\r\n          }\r\n      }\r\n  }\n\n  let isFlushing = false;\r\n  let isFlushPending = false;\r\n  const queue = [];\r\n  let flushIndex = 0;\r\n  const pendingPreFlushCbs = [];\r\n  let activePreFlushCbs = null;\r\n  let preFlushIndex = 0;\r\n  const pendingPostFlushCbs = [];\r\n  let activePostFlushCbs = null;\r\n  let postFlushIndex = 0;\r\n  const resolvedPromise = Promise.resolve();\r\n  let currentFlushPromise = null;\r\n  let currentPreFlushParentJob = null;\r\n  const RECURSION_LIMIT = 100;\r\n  function nextTick(fn) {\r\n      const p = currentFlushPromise || resolvedPromise;\r\n      return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n  }\r\n  // #2768\r\n  // Use binary-search to find a suitable position in the queue,\r\n  // so that the queue maintains the increasing order of job's id,\r\n  // which can prevent the job from being skipped and also can avoid repeated patching.\r\n  function findInsertionIndex(id) {\r\n      // the start index should be `flushIndex + 1`\r\n      let start = flushIndex + 1;\r\n      let end = queue.length;\r\n      while (start < end) {\r\n          const middle = (start + end) >>> 1;\r\n          const middleJobId = getId(queue[middle]);\r\n          middleJobId < id ? (start = middle + 1) : (end = middle);\r\n      }\r\n      return start;\r\n  }\r\n  function queueJob(job) {\r\n      // the dedupe search uses the startIndex argument of Array.includes()\r\n      // by default the search index includes the current job that is being run\r\n      // so it cannot recursively trigger itself again.\r\n      // if the job is a watch() callback, the search will start with a +1 index to\r\n      // allow it recursively trigger itself - it is the user's responsibility to\r\n      // ensure it doesn't end up in an infinite loop.\r\n      if ((!queue.length ||\r\n          !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n          job !== currentPreFlushParentJob) {\r\n          if (job.id == null) {\r\n              queue.push(job);\r\n          }\r\n          else {\r\n              queue.splice(findInsertionIndex(job.id), 0, job);\r\n          }\r\n          queueFlush();\r\n      }\r\n  }\r\n  function queueFlush() {\r\n      if (!isFlushing && !isFlushPending) {\r\n          isFlushPending = true;\r\n          currentFlushPromise = resolvedPromise.then(flushJobs);\r\n      }\r\n  }\r\n  function invalidateJob(job) {\r\n      const i = queue.indexOf(job);\r\n      if (i > flushIndex) {\r\n          queue.splice(i, 1);\r\n      }\r\n  }\r\n  function queueCb(cb, activeQueue, pendingQueue, index) {\r\n      if (!isArray(cb)) {\r\n          if (!activeQueue ||\r\n              !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n              pendingQueue.push(cb);\r\n          }\r\n      }\r\n      else {\r\n          // if cb is an array, it is a component lifecycle hook which can only be\r\n          // triggered by a job, which is already deduped in the main queue, so\r\n          // we can skip duplicate check here to improve perf\r\n          pendingQueue.push(...cb);\r\n      }\r\n      queueFlush();\r\n  }\r\n  function queuePreFlushCb(cb) {\r\n      queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n  }\r\n  function queuePostFlushCb(cb) {\r\n      queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n  }\r\n  function flushPreFlushCbs(seen, parentJob = null) {\r\n      if (pendingPreFlushCbs.length) {\r\n          currentPreFlushParentJob = parentJob;\r\n          activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n          pendingPreFlushCbs.length = 0;\r\n          {\r\n              seen = seen || new Map();\r\n          }\r\n          for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n              if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {\r\n                  continue;\r\n              }\r\n              activePreFlushCbs[preFlushIndex]();\r\n          }\r\n          activePreFlushCbs = null;\r\n          preFlushIndex = 0;\r\n          currentPreFlushParentJob = null;\r\n          // recursively flush until it drains\r\n          flushPreFlushCbs(seen, parentJob);\r\n      }\r\n  }\r\n  function flushPostFlushCbs(seen) {\r\n      if (pendingPostFlushCbs.length) {\r\n          const deduped = [...new Set(pendingPostFlushCbs)];\r\n          pendingPostFlushCbs.length = 0;\r\n          // #1947 already has active queue, nested flushPostFlushCbs call\r\n          if (activePostFlushCbs) {\r\n              activePostFlushCbs.push(...deduped);\r\n              return;\r\n          }\r\n          activePostFlushCbs = deduped;\r\n          {\r\n              seen = seen || new Map();\r\n          }\r\n          activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n              if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\r\n                  continue;\r\n              }\r\n              activePostFlushCbs[postFlushIndex]();\r\n          }\r\n          activePostFlushCbs = null;\r\n          postFlushIndex = 0;\r\n      }\r\n  }\r\n  const getId = (job) => job.id == null ? Infinity : job.id;\r\n  function flushJobs(seen) {\r\n      isFlushPending = false;\r\n      isFlushing = true;\r\n      {\r\n          seen = seen || new Map();\r\n      }\r\n      flushPreFlushCbs(seen);\r\n      // Sort queue before flush.\r\n      // This ensures that:\r\n      // 1. Components are updated from parent to child. (because parent is always\r\n      //    created before the child so its render effect will have smaller\r\n      //    priority number)\r\n      // 2. If a component is unmounted during a parent component's update,\r\n      //    its update can be skipped.\r\n      queue.sort((a, b) => getId(a) - getId(b));\r\n      // conditional usage of checkRecursiveUpdate must be determined out of\r\n      // try ... catch block since Rollup by default de-optimizes treeshaking\r\n      // inside try-catch. This can leave all warning code unshaked. Although\r\n      // they would get eventually shaken by a minifier like terser, some minifiers\r\n      // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n      const check = (job) => checkRecursiveUpdates(seen, job)\r\n          ;\r\n      try {\r\n          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n              const job = queue[flushIndex];\r\n              if (job && job.active !== false) {\r\n                  if (true && check(job)) {\r\n                      continue;\r\n                  }\r\n                  // console.log(`running:`, job.id)\r\n                  callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n              }\r\n          }\r\n      }\r\n      finally {\r\n          flushIndex = 0;\r\n          queue.length = 0;\r\n          flushPostFlushCbs(seen);\r\n          isFlushing = false;\r\n          currentFlushPromise = null;\r\n          // some postFlushCb queued jobs!\r\n          // keep flushing until it drains.\r\n          if (queue.length ||\r\n              pendingPreFlushCbs.length ||\r\n              pendingPostFlushCbs.length) {\r\n              flushJobs(seen);\r\n          }\r\n      }\r\n  }\r\n  function checkRecursiveUpdates(seen, fn) {\r\n      if (!seen.has(fn)) {\r\n          seen.set(fn, 1);\r\n      }\r\n      else {\r\n          const count = seen.get(fn);\r\n          if (count > RECURSION_LIMIT) {\r\n              const instance = fn.ownerInstance;\r\n              const componentName = instance && getComponentName(instance.type);\r\n              warn$1(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +\r\n                  `This means you have a reactive effect that is mutating its own ` +\r\n                  `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                  `include component template, render function, updated hook or ` +\r\n                  `watcher source function.`);\r\n              return true;\r\n          }\r\n          else {\r\n              seen.set(fn, count + 1);\r\n          }\r\n      }\r\n  }\n\n  /* eslint-disable no-restricted-globals */\r\n  let isHmrUpdating = false;\r\n  const hmrDirtyComponents = new Set();\r\n  // Expose the HMR runtime on the global object\r\n  // This makes it entirely tree-shakable without polluting the exports and makes\r\n  // it easier to be used in toolings like vue-loader\r\n  // Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n  // to be set so that its instances can be registered / removed.\r\n  {\r\n      getGlobalThis().__VUE_HMR_RUNTIME__ = {\r\n          createRecord: tryWrap(createRecord),\r\n          rerender: tryWrap(rerender),\r\n          reload: tryWrap(reload)\r\n      };\r\n  }\r\n  const map = new Map();\r\n  function registerHMR(instance) {\r\n      const id = instance.type.__hmrId;\r\n      let record = map.get(id);\r\n      if (!record) {\r\n          createRecord(id, instance.type);\r\n          record = map.get(id);\r\n      }\r\n      record.instances.add(instance);\r\n  }\r\n  function unregisterHMR(instance) {\r\n      map.get(instance.type.__hmrId).instances.delete(instance);\r\n  }\r\n  function createRecord(id, initialDef) {\r\n      if (map.has(id)) {\r\n          return false;\r\n      }\r\n      map.set(id, {\r\n          initialDef: normalizeClassComponent(initialDef),\r\n          instances: new Set()\r\n      });\r\n      return true;\r\n  }\r\n  function normalizeClassComponent(component) {\r\n      return isClassComponent(component) ? component.__vccOpts : component;\r\n  }\r\n  function rerender(id, newRender) {\r\n      const record = map.get(id);\r\n      if (!record) {\r\n          return;\r\n      }\r\n      // update initial record (for not-yet-rendered component)\r\n      record.initialDef.render = newRender;\r\n      [...record.instances].forEach(instance => {\r\n          if (newRender) {\r\n              instance.render = newRender;\r\n              normalizeClassComponent(instance.type).render = newRender;\r\n          }\r\n          instance.renderCache = [];\r\n          // this flag forces child components with slot content to update\r\n          isHmrUpdating = true;\r\n          instance.update();\r\n          isHmrUpdating = false;\r\n      });\r\n  }\r\n  function reload(id, newComp) {\r\n      const record = map.get(id);\r\n      if (!record)\r\n          return;\r\n      newComp = normalizeClassComponent(newComp);\r\n      // update initial def (for not-yet-rendered components)\r\n      updateComponentDef(record.initialDef, newComp);\r\n      // create a snapshot which avoids the set being mutated during updates\r\n      const instances = [...record.instances];\r\n      for (const instance of instances) {\r\n          const oldComp = normalizeClassComponent(instance.type);\r\n          if (!hmrDirtyComponents.has(oldComp)) {\r\n              // 1. Update existing comp definition to match new one\r\n              if (oldComp !== record.initialDef) {\r\n                  updateComponentDef(oldComp, newComp);\r\n              }\r\n              // 2. mark definition dirty. This forces the renderer to replace the\r\n              // component on patch.\r\n              hmrDirtyComponents.add(oldComp);\r\n          }\r\n          // 3. invalidate options resolution cache\r\n          instance.appContext.optionsCache.delete(instance.type);\r\n          // 4. actually update\r\n          if (instance.ceReload) {\r\n              // custom element\r\n              hmrDirtyComponents.add(oldComp);\r\n              instance.ceReload(newComp.styles);\r\n              hmrDirtyComponents.delete(oldComp);\r\n          }\r\n          else if (instance.parent) {\r\n              // 4. Force the parent instance to re-render. This will cause all updated\r\n              // components to be unmounted and re-mounted. Queue the update so that we\r\n              // don't end up forcing the same parent to re-render multiple times.\r\n              queueJob(instance.parent.update);\r\n              // instance is the inner component of an async custom element\r\n              // invoke to reset styles\r\n              if (instance.parent.type.__asyncLoader &&\r\n                  instance.parent.ceReload) {\r\n                  instance.parent.ceReload(newComp.styles);\r\n              }\r\n          }\r\n          else if (instance.appContext.reload) {\r\n              // root instance mounted via createApp() has a reload method\r\n              instance.appContext.reload();\r\n          }\r\n          else if (typeof window !== 'undefined') {\r\n              // root instance inside tree created via raw render(). Force reload.\r\n              window.location.reload();\r\n          }\r\n          else {\r\n              console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n          }\r\n      }\r\n      // 5. make sure to cleanup dirty hmr components after update\r\n      queuePostFlushCb(() => {\r\n          for (const instance of instances) {\r\n              hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\r\n          }\r\n      });\r\n  }\r\n  function updateComponentDef(oldComp, newComp) {\r\n      extend(oldComp, newComp);\r\n      for (const key in oldComp) {\r\n          if (key !== '__file' && !(key in newComp)) {\r\n              delete oldComp[key];\r\n          }\r\n      }\r\n  }\r\n  function tryWrap(fn) {\r\n      return (id, arg) => {\r\n          try {\r\n              return fn(id, arg);\r\n          }\r\n          catch (e) {\r\n              console.error(e);\r\n              console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                  `Full reload required.`);\r\n          }\r\n      };\r\n  }\n\n  let buffer = [];\r\n  let devtoolsNotInstalled = false;\r\n  function emit(event, ...args) {\r\n      if (exports.devtools) {\r\n          exports.devtools.emit(event, ...args);\r\n      }\r\n      else if (!devtoolsNotInstalled) {\r\n          buffer.push({ event, args });\r\n      }\r\n  }\r\n  function setDevtoolsHook(hook, target) {\r\n      var _a, _b;\r\n      exports.devtools = hook;\r\n      if (exports.devtools) {\r\n          exports.devtools.enabled = true;\r\n          buffer.forEach(({ event, args }) => exports.devtools.emit(event, ...args));\r\n          buffer = [];\r\n      }\r\n      else if (\r\n      // handle late devtools injection - only do this if we are in an actual\r\n      // browser environment to avoid the timer handle stalling test runner exit\r\n      // (#4815)\r\n      // eslint-disable-next-line no-restricted-globals\r\n      typeof window !== 'undefined' &&\r\n          // some envs mock window but not fully\r\n          window.HTMLElement &&\r\n          // also exclude jsdom\r\n          !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {\r\n          const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =\r\n              target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);\r\n          replay.push((newHook) => {\r\n              setDevtoolsHook(newHook, target);\r\n          });\r\n          // clear buffer after 3s - the user probably doesn't have devtools installed\r\n          // at all, and keeping the buffer will cause memory leaks (#4738)\r\n          setTimeout(() => {\r\n              if (!exports.devtools) {\r\n                  target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\r\n                  devtoolsNotInstalled = true;\r\n                  buffer = [];\r\n              }\r\n          }, 3000);\r\n      }\r\n      else {\r\n          // non-browser env, assume not installed\r\n          devtoolsNotInstalled = true;\r\n          buffer = [];\r\n      }\r\n  }\r\n  function devtoolsInitApp(app, version) {\r\n      emit(\"app:init\" /* APP_INIT */, app, version, {\r\n          Fragment,\r\n          Text,\r\n          Comment,\r\n          Static\r\n      });\r\n  }\r\n  function devtoolsUnmountApp(app) {\r\n      emit(\"app:unmount\" /* APP_UNMOUNT */, app);\r\n  }\r\n  const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\r\n  const devtoolsComponentUpdated = \r\n  /*#__PURE__*/ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\r\n  const devtoolsComponentRemoved = \r\n  /*#__PURE__*/ createDevtoolsComponentHook(\"component:removed\" /* COMPONENT_REMOVED */);\r\n  function createDevtoolsComponentHook(hook) {\r\n      return (component) => {\r\n          emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\r\n      };\r\n  }\r\n  const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(\"perf:start\" /* PERFORMANCE_START */);\r\n  const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(\"perf:end\" /* PERFORMANCE_END */);\r\n  function createDevtoolsPerformanceHook(hook) {\r\n      return (component, type, time) => {\r\n          emit(hook, component.appContext.app, component.uid, component, type, time);\r\n      };\r\n  }\r\n  function devtoolsComponentEmit(component, event, params) {\r\n      emit(\"component:emit\" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\r\n  }\n\n  function emit$1(instance, event, ...rawArgs) {\r\n      const props = instance.vnode.props || EMPTY_OBJ;\r\n      {\r\n          const { emitsOptions, propsOptions: [propsOptions] } = instance;\r\n          if (emitsOptions) {\r\n              if (!(event in emitsOptions) &&\r\n                  !(false )) {\r\n                  if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\r\n                      warn$1(`Component emitted event \"${event}\" but it is neither declared in ` +\r\n                          `the emits option nor as an \"${toHandlerKey(event)}\" prop.`);\r\n                  }\r\n              }\r\n              else {\r\n                  const validator = emitsOptions[event];\r\n                  if (isFunction(validator)) {\r\n                      const isValid = validator(...rawArgs);\r\n                      if (!isValid) {\r\n                          warn$1(`Invalid event arguments: event validation failed for event \"${event}\".`);\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      let args = rawArgs;\r\n      const isModelListener = event.startsWith('update:');\r\n      // for v-model update:xxx events, apply modifiers on args\r\n      const modelArg = isModelListener && event.slice(7);\r\n      if (modelArg && modelArg in props) {\r\n          const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\r\n          const { number, trim } = props[modifiersKey] || EMPTY_OBJ;\r\n          if (trim) {\r\n              args = rawArgs.map(a => a.trim());\r\n          }\r\n          else if (number) {\r\n              args = rawArgs.map(toNumber);\r\n          }\r\n      }\r\n      {\r\n          devtoolsComponentEmit(instance, event, args);\r\n      }\r\n      {\r\n          const lowerCaseEvent = event.toLowerCase();\r\n          if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\r\n              warn$1(`Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n                  `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` +\r\n                  `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n                  `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n                  `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\r\n          }\r\n      }\r\n      let handlerName;\r\n      let handler = props[(handlerName = toHandlerKey(event))] ||\r\n          // also try camelCase event handler (#2249)\r\n          props[(handlerName = toHandlerKey(camelize(event)))];\r\n      // for v-model update:xxx events, also trigger kebab-case equivalent\r\n      // for props passed via kebab-case\r\n      if (!handler && isModelListener) {\r\n          handler = props[(handlerName = toHandlerKey(hyphenate(event)))];\r\n      }\r\n      if (handler) {\r\n          callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n      }\r\n      const onceHandler = props[handlerName + `Once`];\r\n      if (onceHandler) {\r\n          if (!instance.emitted) {\r\n              instance.emitted = {};\r\n          }\r\n          else if (instance.emitted[handlerName]) {\r\n              return;\r\n          }\r\n          instance.emitted[handlerName] = true;\r\n          callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n      }\r\n  }\r\n  function normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n      const cache = appContext.emitsCache;\r\n      const cached = cache.get(comp);\r\n      if (cached !== undefined) {\r\n          return cached;\r\n      }\r\n      const raw = comp.emits;\r\n      let normalized = {};\r\n      // apply mixin/extends props\r\n      let hasExtends = false;\r\n      if (!isFunction(comp)) {\r\n          const extendEmits = (raw) => {\r\n              const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\r\n              if (normalizedFromExtend) {\r\n                  hasExtends = true;\r\n                  extend(normalized, normalizedFromExtend);\r\n              }\r\n          };\r\n          if (!asMixin && appContext.mixins.length) {\r\n              appContext.mixins.forEach(extendEmits);\r\n          }\r\n          if (comp.extends) {\r\n              extendEmits(comp.extends);\r\n          }\r\n          if (comp.mixins) {\r\n              comp.mixins.forEach(extendEmits);\r\n          }\r\n      }\r\n      if (!raw && !hasExtends) {\r\n          cache.set(comp, null);\r\n          return null;\r\n      }\r\n      if (isArray(raw)) {\r\n          raw.forEach(key => (normalized[key] = null));\r\n      }\r\n      else {\r\n          extend(normalized, raw);\r\n      }\r\n      cache.set(comp, normalized);\r\n      return normalized;\r\n  }\r\n  // Check if an incoming prop key is a declared emit event listener.\r\n  // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n  // both considered matched listeners.\r\n  function isEmitListener(options, key) {\r\n      if (!options || !isOn(key)) {\r\n          return false;\r\n      }\r\n      key = key.slice(2).replace(/Once$/, '');\r\n      return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\r\n          hasOwn(options, hyphenate(key)) ||\r\n          hasOwn(options, key));\r\n  }\n\n  /**\r\n   * mark the current rendering instance for asset resolution (e.g.\r\n   * resolveComponent, resolveDirective) during render\r\n   */\r\n  let currentRenderingInstance = null;\r\n  let currentScopeId = null;\r\n  /**\r\n   * Note: rendering calls maybe nested. The function returns the parent rendering\r\n   * instance if present, which should be restored after the render is done:\r\n   *\r\n   * ```js\r\n   * const prev = setCurrentRenderingInstance(i)\r\n   * // ...render\r\n   * setCurrentRenderingInstance(prev)\r\n   * ```\r\n   */\r\n  function setCurrentRenderingInstance(instance) {\r\n      const prev = currentRenderingInstance;\r\n      currentRenderingInstance = instance;\r\n      currentScopeId = (instance && instance.type.__scopeId) || null;\r\n      return prev;\r\n  }\r\n  /**\r\n   * Set scope id when creating hoisted vnodes.\r\n   * @private compiler helper\r\n   */\r\n  function pushScopeId(id) {\r\n      currentScopeId = id;\r\n  }\r\n  /**\r\n   * Technically we no longer need this after 3.0.8 but we need to keep the same\r\n   * API for backwards compat w/ code generated by compilers.\r\n   * @private\r\n   */\r\n  function popScopeId() {\r\n      currentScopeId = null;\r\n  }\r\n  /**\r\n   * Only for backwards compat\r\n   * @private\r\n   */\r\n  const withScopeId = (_id) => withCtx;\r\n  /**\r\n   * Wrap a slot function to memoize current rendering instance\r\n   * @private compiler helper\r\n   */\r\n  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only\r\n  ) {\r\n      if (!ctx)\r\n          return fn;\r\n      // already normalized\r\n      if (fn._n) {\r\n          return fn;\r\n      }\r\n      const renderFnWithContext = (...args) => {\r\n          // If a user calls a compiled slot inside a template expression (#1745), it\r\n          // can mess up block tracking, so by default we disable block tracking and\r\n          // force bail out when invoking a compiled slot (indicated by the ._d flag).\r\n          // This isn't necessary if rendering a compiled `<slot>`, so we flip the\r\n          // ._d flag off when invoking the wrapped fn inside `renderSlot`.\r\n          if (renderFnWithContext._d) {\r\n              setBlockTracking(-1);\r\n          }\r\n          const prevInstance = setCurrentRenderingInstance(ctx);\r\n          const res = fn(...args);\r\n          setCurrentRenderingInstance(prevInstance);\r\n          if (renderFnWithContext._d) {\r\n              setBlockTracking(1);\r\n          }\r\n          {\r\n              devtoolsComponentUpdated(ctx);\r\n          }\r\n          return res;\r\n      };\r\n      // mark normalized to avoid duplicated wrapping\r\n      renderFnWithContext._n = true;\r\n      // mark this as compiled by default\r\n      // this is used in vnode.ts -> normalizeChildren() to set the slot\r\n      // rendering flag.\r\n      renderFnWithContext._c = true;\r\n      // disable block tracking by default\r\n      renderFnWithContext._d = true;\r\n      return renderFnWithContext;\r\n  }\n\n  /**\r\n   * dev only flag to track whether $attrs was used during render.\r\n   * If $attrs was used during render then the warning for failed attrs\r\n   * fallthrough can be suppressed.\r\n   */\r\n  let accessedAttrs = false;\r\n  function markAttrsAccessed() {\r\n      accessedAttrs = true;\r\n  }\r\n  function renderComponentRoot(instance) {\r\n      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;\r\n      let result;\r\n      let fallthroughAttrs;\r\n      const prev = setCurrentRenderingInstance(instance);\r\n      {\r\n          accessedAttrs = false;\r\n      }\r\n      try {\r\n          if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n              // withProxy is a proxy with a different `has` trap only for\r\n              // runtime-compiled render functions using `with` block.\r\n              const proxyToUse = withProxy || proxy;\r\n              result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n              fallthroughAttrs = attrs;\r\n          }\r\n          else {\r\n              // functional\r\n              const render = Component;\r\n              // in dev, mark attrs accessed if optional props (attrs === props)\r\n              if (true && attrs === props) {\r\n                  markAttrsAccessed();\r\n              }\r\n              result = normalizeVNode(render.length > 1\r\n                  ? render(props, true\r\n                      ? {\r\n                          get attrs() {\r\n                              markAttrsAccessed();\r\n                              return attrs;\r\n                          },\r\n                          slots,\r\n                          emit\r\n                      }\r\n                      : { attrs, slots, emit })\r\n                  : render(props, null /* we know it doesn't need it */));\r\n              fallthroughAttrs = Component.props\r\n                  ? attrs\r\n                  : getFunctionalFallthrough(attrs);\r\n          }\r\n      }\r\n      catch (err) {\r\n          blockStack.length = 0;\r\n          handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n          result = createVNode(Comment);\r\n      }\r\n      // attr merging\r\n      // in dev mode, comments are preserved, and it's possible for a template\r\n      // to have comments along side the root element which makes it a fragment\r\n      let root = result;\r\n      let setRoot = undefined;\r\n      if (result.patchFlag > 0 &&\r\n          result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {\r\n          [root, setRoot] = getChildRoot(result);\r\n      }\r\n      if (fallthroughAttrs && inheritAttrs !== false) {\r\n          const keys = Object.keys(fallthroughAttrs);\r\n          const { shapeFlag } = root;\r\n          if (keys.length) {\r\n              if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {\r\n                  if (propsOptions && keys.some(isModelListener)) {\r\n                      // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                      // prop, it indicates this component expects to handle v-model and\r\n                      // it should not fallthrough.\r\n                      // related: #1543, #1643, #1989\r\n                      fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                  }\r\n                  root = cloneVNode(root, fallthroughAttrs);\r\n              }\r\n              else if (!accessedAttrs && root.type !== Comment) {\r\n                  const allAttrs = Object.keys(attrs);\r\n                  const eventAttrs = [];\r\n                  const extraAttrs = [];\r\n                  for (let i = 0, l = allAttrs.length; i < l; i++) {\r\n                      const key = allAttrs[i];\r\n                      if (isOn(key)) {\r\n                          // ignore v-model handlers when they fail to fallthrough\r\n                          if (!isModelListener(key)) {\r\n                              // remove `on`, lowercase first letter to reflect event casing\r\n                              // accurately\r\n                              eventAttrs.push(key[2].toLowerCase() + key.slice(3));\r\n                          }\r\n                      }\r\n                      else {\r\n                          extraAttrs.push(key);\r\n                      }\r\n                  }\r\n                  if (extraAttrs.length) {\r\n                      warn$1(`Extraneous non-props attributes (` +\r\n                          `${extraAttrs.join(', ')}) ` +\r\n                          `were passed to component but could not be automatically inherited ` +\r\n                          `because component renders fragment or text root nodes.`);\r\n                  }\r\n                  if (eventAttrs.length) {\r\n                      warn$1(`Extraneous non-emits event listeners (` +\r\n                          `${eventAttrs.join(', ')}) ` +\r\n                          `were passed to component but could not be automatically inherited ` +\r\n                          `because component renders fragment or text root nodes. ` +\r\n                          `If the listener is intended to be a component custom event listener only, ` +\r\n                          `declare it using the \"emits\" option.`);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      // inherit directives\r\n      if (vnode.dirs) {\r\n          if (!isElementRoot(root)) {\r\n              warn$1(`Runtime directive used on component with non-element root node. ` +\r\n                  `The directives will not function as intended.`);\r\n          }\r\n          root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n      }\r\n      // inherit transition data\r\n      if (vnode.transition) {\r\n          if (!isElementRoot(root)) {\r\n              warn$1(`Component inside <Transition> renders non-element root node ` +\r\n                  `that cannot be animated.`);\r\n          }\r\n          root.transition = vnode.transition;\r\n      }\r\n      if (setRoot) {\r\n          setRoot(root);\r\n      }\r\n      else {\r\n          result = root;\r\n      }\r\n      setCurrentRenderingInstance(prev);\r\n      return result;\r\n  }\r\n  /**\r\n   * dev only\r\n   * In dev mode, template root level comments are rendered, which turns the\r\n   * template into a fragment root, but we need to locate the single element\r\n   * root for attrs and scope id processing.\r\n   */\r\n  const getChildRoot = (vnode) => {\r\n      const rawChildren = vnode.children;\r\n      const dynamicChildren = vnode.dynamicChildren;\r\n      const childRoot = filterSingleRoot(rawChildren);\r\n      if (!childRoot) {\r\n          return [vnode, undefined];\r\n      }\r\n      const index = rawChildren.indexOf(childRoot);\r\n      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n      const setRoot = (updatedRoot) => {\r\n          rawChildren[index] = updatedRoot;\r\n          if (dynamicChildren) {\r\n              if (dynamicIndex > -1) {\r\n                  dynamicChildren[dynamicIndex] = updatedRoot;\r\n              }\r\n              else if (updatedRoot.patchFlag > 0) {\r\n                  vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\r\n              }\r\n          }\r\n      };\r\n      return [normalizeVNode(childRoot), setRoot];\r\n  };\r\n  function filterSingleRoot(children) {\r\n      let singleRoot;\r\n      for (let i = 0; i < children.length; i++) {\r\n          const child = children[i];\r\n          if (isVNode(child)) {\r\n              // ignore user comment\r\n              if (child.type !== Comment || child.children === 'v-if') {\r\n                  if (singleRoot) {\r\n                      // has more than 1 non-comment child, return now\r\n                      return;\r\n                  }\r\n                  else {\r\n                      singleRoot = child;\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              return;\r\n          }\r\n      }\r\n      return singleRoot;\r\n  }\r\n  const getFunctionalFallthrough = (attrs) => {\r\n      let res;\r\n      for (const key in attrs) {\r\n          if (key === 'class' || key === 'style' || isOn(key)) {\r\n              (res || (res = {}))[key] = attrs[key];\r\n          }\r\n      }\r\n      return res;\r\n  };\r\n  const filterModelListeners = (attrs, props) => {\r\n      const res = {};\r\n      for (const key in attrs) {\r\n          if (!isModelListener(key) || !(key.slice(9) in props)) {\r\n              res[key] = attrs[key];\r\n          }\r\n      }\r\n      return res;\r\n  };\r\n  const isElementRoot = (vnode) => {\r\n      return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||\r\n          vnode.type === Comment // potential v-if branch switch\r\n      );\r\n  };\r\n  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n      const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n      const emits = component.emitsOptions;\r\n      // Parent component's render function was hot-updated. Since this may have\r\n      // caused the child component's slots content to have changed, we need to\r\n      // force the child to update as well.\r\n      if ((prevChildren || nextChildren) && isHmrUpdating) {\r\n          return true;\r\n      }\r\n      // force child update for runtime directive or transition on component vnode.\r\n      if (nextVNode.dirs || nextVNode.transition) {\r\n          return true;\r\n      }\r\n      if (optimized && patchFlag >= 0) {\r\n          if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n              // slot content that references values that might have changed,\r\n              // e.g. in a v-for\r\n              return true;\r\n          }\r\n          if (patchFlag & 16 /* FULL_PROPS */) {\r\n              if (!prevProps) {\r\n                  return !!nextProps;\r\n              }\r\n              // presence of this flag indicates props are always non-null\r\n              return hasPropsChanged(prevProps, nextProps, emits);\r\n          }\r\n          else if (patchFlag & 8 /* PROPS */) {\r\n              const dynamicProps = nextVNode.dynamicProps;\r\n              for (let i = 0; i < dynamicProps.length; i++) {\r\n                  const key = dynamicProps[i];\r\n                  if (nextProps[key] !== prevProps[key] &&\r\n                      !isEmitListener(emits, key)) {\r\n                      return true;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          // this path is only taken by manually written render functions\r\n          // so presence of any children leads to a forced update\r\n          if (prevChildren || nextChildren) {\r\n              if (!nextChildren || !nextChildren.$stable) {\r\n                  return true;\r\n              }\r\n          }\r\n          if (prevProps === nextProps) {\r\n              return false;\r\n          }\r\n          if (!prevProps) {\r\n              return !!nextProps;\r\n          }\r\n          if (!nextProps) {\r\n              return true;\r\n          }\r\n          return hasPropsChanged(prevProps, nextProps, emits);\r\n      }\r\n      return false;\r\n  }\r\n  function hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n      const nextKeys = Object.keys(nextProps);\r\n      if (nextKeys.length !== Object.keys(prevProps).length) {\r\n          return true;\r\n      }\r\n      for (let i = 0; i < nextKeys.length; i++) {\r\n          const key = nextKeys[i];\r\n          if (nextProps[key] !== prevProps[key] &&\r\n              !isEmitListener(emitsOptions, key)) {\r\n              return true;\r\n          }\r\n      }\r\n      return false;\r\n  }\r\n  function updateHOCHostEl({ vnode, parent }, el // HostNode\r\n  ) {\r\n      while (parent && parent.subTree === vnode) {\r\n          (vnode = parent.vnode).el = el;\r\n          parent = parent.parent;\r\n      }\r\n  }\n\n  const isSuspense = (type) => type.__isSuspense;\r\n  // Suspense exposes a component-like API, and is treated like a component\r\n  // in the compiler, but internally it's a special built-in type that hooks\r\n  // directly into the renderer.\r\n  const SuspenseImpl = {\r\n      name: 'Suspense',\r\n      // In order to make Suspense tree-shakable, we need to avoid importing it\r\n      // directly in the renderer. The renderer checks for the __isSuspense flag\r\n      // on a vnode's type and calls the `process` method, passing in renderer\r\n      // internals.\r\n      __isSuspense: true,\r\n      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, \r\n      // platform-specific impl passed from renderer\r\n      rendererInternals) {\r\n          if (n1 == null) {\r\n              mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\r\n          }\r\n          else {\r\n              patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\r\n          }\r\n      },\r\n      hydrate: hydrateSuspense,\r\n      create: createSuspenseBoundary,\r\n      normalize: normalizeSuspenseChildren\r\n  };\r\n  // Force-casted public typing for h and TSX props inference\r\n  const Suspense = (SuspenseImpl );\r\n  function triggerEvent(vnode, name) {\r\n      const eventListener = vnode.props && vnode.props[name];\r\n      if (isFunction(eventListener)) {\r\n          eventListener();\r\n      }\r\n  }\r\n  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\r\n      const { p: patch, o: { createElement } } = rendererInternals;\r\n      const hiddenContainer = createElement('div');\r\n      const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));\r\n      // start mounting the content subtree in an off-dom container\r\n      patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\r\n      // now check if we have encountered any async deps\r\n      if (suspense.deps > 0) {\r\n          // has async\r\n          // invoke @fallback event\r\n          triggerEvent(vnode, 'onPending');\r\n          triggerEvent(vnode, 'onFallback');\r\n          // mount the fallback tree\r\n          patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n          isSVG, slotScopeIds);\r\n          setActiveBranch(suspense, vnode.ssFallback);\r\n      }\r\n      else {\r\n          // Suspense has no async deps. Just resolve.\r\n          suspense.resolve();\r\n      }\r\n  }\r\n  function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\r\n      const suspense = (n2.suspense = n1.suspense);\r\n      suspense.vnode = n2;\r\n      n2.el = n1.el;\r\n      const newBranch = n2.ssContent;\r\n      const newFallback = n2.ssFallback;\r\n      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n      if (pendingBranch) {\r\n          suspense.pendingBranch = newBranch;\r\n          if (isSameVNodeType(newBranch, pendingBranch)) {\r\n              // same root type but content may have changed.\r\n              patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n              if (suspense.deps <= 0) {\r\n                  suspense.resolve();\r\n              }\r\n              else if (isInFallback) {\r\n                  patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                  isSVG, slotScopeIds, optimized);\r\n                  setActiveBranch(suspense, newFallback);\r\n              }\r\n          }\r\n          else {\r\n              // toggled before pending tree is resolved\r\n              suspense.pendingId++;\r\n              if (isHydrating) {\r\n                  // if toggled before hydration is finished, the current DOM tree is\r\n                  // no longer valid. set it as the active branch so it will be unmounted\r\n                  // when resolved\r\n                  suspense.isHydrating = false;\r\n                  suspense.activeBranch = pendingBranch;\r\n              }\r\n              else {\r\n                  unmount(pendingBranch, parentComponent, suspense);\r\n              }\r\n              // increment pending ID. this is used to invalidate async callbacks\r\n              // reset suspense state\r\n              suspense.deps = 0;\r\n              // discard effects from pending branch\r\n              suspense.effects.length = 0;\r\n              // discard previous container\r\n              suspense.hiddenContainer = createElement('div');\r\n              if (isInFallback) {\r\n                  // already in fallback state\r\n                  patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                  if (suspense.deps <= 0) {\r\n                      suspense.resolve();\r\n                  }\r\n                  else {\r\n                      patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                      isSVG, slotScopeIds, optimized);\r\n                      setActiveBranch(suspense, newFallback);\r\n                  }\r\n              }\r\n              else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                  // toggled \"back\" to current active branch\r\n                  patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                  // force resolve\r\n                  suspense.resolve(true);\r\n              }\r\n              else {\r\n                  // switched to a 3rd branch\r\n                  patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                  if (suspense.deps <= 0) {\r\n                      suspense.resolve();\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n              // root did not change, just normal patch\r\n              patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n              setActiveBranch(suspense, newBranch);\r\n          }\r\n          else {\r\n              // root node toggled\r\n              // invoke @pending event\r\n              triggerEvent(n2, 'onPending');\r\n              // mount pending branch in off-dom container\r\n              suspense.pendingBranch = newBranch;\r\n              suspense.pendingId++;\r\n              patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n              if (suspense.deps <= 0) {\r\n                  // incoming branch has no async deps, resolve now.\r\n                  suspense.resolve();\r\n              }\r\n              else {\r\n                  const { timeout, pendingId } = suspense;\r\n                  if (timeout > 0) {\r\n                      setTimeout(() => {\r\n                          if (suspense.pendingId === pendingId) {\r\n                              suspense.fallback(newFallback);\r\n                          }\r\n                      }, timeout);\r\n                  }\r\n                  else if (timeout === 0) {\r\n                      suspense.fallback(newFallback);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n  }\r\n  let hasWarned = false;\r\n  function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\r\n      /* istanbul ignore if */\r\n      if (!hasWarned) {\r\n          hasWarned = true;\r\n          // @ts-ignore `console.info` cannot be null error\r\n          console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);\r\n      }\r\n      const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n      const timeout = toNumber(vnode.props && vnode.props.timeout);\r\n      const suspense = {\r\n          vnode,\r\n          parent,\r\n          parentComponent,\r\n          isSVG,\r\n          container,\r\n          hiddenContainer,\r\n          anchor,\r\n          deps: 0,\r\n          pendingId: 0,\r\n          timeout: typeof timeout === 'number' ? timeout : -1,\r\n          activeBranch: null,\r\n          pendingBranch: null,\r\n          isInFallback: true,\r\n          isHydrating,\r\n          isUnmounted: false,\r\n          effects: [],\r\n          resolve(resume = false) {\r\n              {\r\n                  if (!resume && !suspense.pendingBranch) {\r\n                      throw new Error(`suspense.resolve() is called without a pending branch.`);\r\n                  }\r\n                  if (suspense.isUnmounted) {\r\n                      throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\r\n                  }\r\n              }\r\n              const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n              if (suspense.isHydrating) {\r\n                  suspense.isHydrating = false;\r\n              }\r\n              else if (!resume) {\r\n                  const delayEnter = activeBranch &&\r\n                      pendingBranch.transition &&\r\n                      pendingBranch.transition.mode === 'out-in';\r\n                  if (delayEnter) {\r\n                      activeBranch.transition.afterLeave = () => {\r\n                          if (pendingId === suspense.pendingId) {\r\n                              move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                          }\r\n                      };\r\n                  }\r\n                  // this is initial anchor on mount\r\n                  let { anchor } = suspense;\r\n                  // unmount current active tree\r\n                  if (activeBranch) {\r\n                      // if the fallback tree was mounted, it may have been moved\r\n                      // as part of a parent suspense. get the latest anchor for insertion\r\n                      anchor = next(activeBranch);\r\n                      unmount(activeBranch, parentComponent, suspense, true);\r\n                  }\r\n                  if (!delayEnter) {\r\n                      // move content from off-dom container to actual container\r\n                      move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                  }\r\n              }\r\n              setActiveBranch(suspense, pendingBranch);\r\n              suspense.pendingBranch = null;\r\n              suspense.isInFallback = false;\r\n              // flush buffered effects\r\n              // check if there is a pending parent suspense\r\n              let parent = suspense.parent;\r\n              let hasUnresolvedAncestor = false;\r\n              while (parent) {\r\n                  if (parent.pendingBranch) {\r\n                      // found a pending parent suspense, merge buffered post jobs\r\n                      // into that parent\r\n                      parent.effects.push(...effects);\r\n                      hasUnresolvedAncestor = true;\r\n                      break;\r\n                  }\r\n                  parent = parent.parent;\r\n              }\r\n              // no pending parent suspense, flush all jobs\r\n              if (!hasUnresolvedAncestor) {\r\n                  queuePostFlushCb(effects);\r\n              }\r\n              suspense.effects = [];\r\n              // invoke @resolve event\r\n              triggerEvent(vnode, 'onResolve');\r\n          },\r\n          fallback(fallbackVNode) {\r\n              if (!suspense.pendingBranch) {\r\n                  return;\r\n              }\r\n              const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\r\n              // invoke @fallback event\r\n              triggerEvent(vnode, 'onFallback');\r\n              const anchor = next(activeBranch);\r\n              const mountFallback = () => {\r\n                  if (!suspense.isInFallback) {\r\n                      return;\r\n                  }\r\n                  // mount the fallback tree\r\n                  patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                  isSVG, slotScopeIds, optimized);\r\n                  setActiveBranch(suspense, fallbackVNode);\r\n              };\r\n              const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\r\n              if (delayEnter) {\r\n                  activeBranch.transition.afterLeave = mountFallback;\r\n              }\r\n              suspense.isInFallback = true;\r\n              // unmount current active branch\r\n              unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n              true // shouldRemove\r\n              );\r\n              if (!delayEnter) {\r\n                  mountFallback();\r\n              }\r\n          },\r\n          move(container, anchor, type) {\r\n              suspense.activeBranch &&\r\n                  move(suspense.activeBranch, container, anchor, type);\r\n              suspense.container = container;\r\n          },\r\n          next() {\r\n              return suspense.activeBranch && next(suspense.activeBranch);\r\n          },\r\n          registerDep(instance, setupRenderEffect) {\r\n              const isInPendingSuspense = !!suspense.pendingBranch;\r\n              if (isInPendingSuspense) {\r\n                  suspense.deps++;\r\n              }\r\n              const hydratedEl = instance.vnode.el;\r\n              instance\r\n                  .asyncDep.catch(err => {\r\n                  handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n              })\r\n                  .then(asyncSetupResult => {\r\n                  // retry when the setup() promise resolves.\r\n                  // component may have been unmounted before resolve.\r\n                  if (instance.isUnmounted ||\r\n                      suspense.isUnmounted ||\r\n                      suspense.pendingId !== instance.suspenseId) {\r\n                      return;\r\n                  }\r\n                  // retry from this component\r\n                  instance.asyncResolved = true;\r\n                  const { vnode } = instance;\r\n                  {\r\n                      pushWarningContext(vnode);\r\n                  }\r\n                  handleSetupResult(instance, asyncSetupResult, false);\r\n                  if (hydratedEl) {\r\n                      // vnode may have been replaced if an update happened before the\r\n                      // async dep is resolved.\r\n                      vnode.el = hydratedEl;\r\n                  }\r\n                  const placeholder = !hydratedEl && instance.subTree.el;\r\n                  setupRenderEffect(instance, vnode, \r\n                  // component may have been moved before resolve.\r\n                  // if this is not a hydration, instance.subTree will be the comment\r\n                  // placeholder.\r\n                  parentNode(hydratedEl || instance.subTree.el), \r\n                  // anchor will not be used if this is hydration, so only need to\r\n                  // consider the comment placeholder case.\r\n                  hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                  if (placeholder) {\r\n                      remove(placeholder);\r\n                  }\r\n                  updateHOCHostEl(instance, vnode.el);\r\n                  {\r\n                      popWarningContext();\r\n                  }\r\n                  // only decrease deps count if suspense is not already resolved\r\n                  if (isInPendingSuspense && --suspense.deps === 0) {\r\n                      suspense.resolve();\r\n                  }\r\n              });\r\n          },\r\n          unmount(parentSuspense, doRemove) {\r\n              suspense.isUnmounted = true;\r\n              if (suspense.activeBranch) {\r\n                  unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n              }\r\n              if (suspense.pendingBranch) {\r\n                  unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n              }\r\n          }\r\n      };\r\n      return suspense;\r\n  }\r\n  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\r\n      /* eslint-disable no-restricted-globals */\r\n      const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));\r\n      // there are two possible scenarios for server-rendered suspense:\r\n      // - success: ssr content should be fully resolved\r\n      // - failure: ssr content should be the fallback branch.\r\n      // however, on the client we don't really know if it has failed or not\r\n      // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n      // need to construct a suspense boundary first\r\n      const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);\r\n      if (suspense.deps === 0) {\r\n          suspense.resolve();\r\n      }\r\n      return result;\r\n      /* eslint-enable no-restricted-globals */\r\n  }\r\n  function normalizeSuspenseChildren(vnode) {\r\n      const { shapeFlag, children } = vnode;\r\n      const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;\r\n      vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\r\n      vnode.ssFallback = isSlotChildren\r\n          ? normalizeSuspenseSlot(children.fallback)\r\n          : createVNode(Comment);\r\n  }\r\n  function normalizeSuspenseSlot(s) {\r\n      let block;\r\n      if (isFunction(s)) {\r\n          const trackBlock = isBlockTreeEnabled && s._c;\r\n          if (trackBlock) {\r\n              // disableTracking: false\r\n              // allow block tracking for compiled slots\r\n              // (see ./componentRenderContext.ts)\r\n              s._d = false;\r\n              openBlock();\r\n          }\r\n          s = s();\r\n          if (trackBlock) {\r\n              s._d = true;\r\n              block = currentBlock;\r\n              closeBlock();\r\n          }\r\n      }\r\n      if (isArray(s)) {\r\n          const singleChild = filterSingleRoot(s);\r\n          if (!singleChild) {\r\n              warn$1(`<Suspense> slots expect a single root node.`);\r\n          }\r\n          s = singleChild;\r\n      }\r\n      s = normalizeVNode(s);\r\n      if (block && !s.dynamicChildren) {\r\n          s.dynamicChildren = block.filter(c => c !== s);\r\n      }\r\n      return s;\r\n  }\r\n  function queueEffectWithSuspense(fn, suspense) {\r\n      if (suspense && suspense.pendingBranch) {\r\n          if (isArray(fn)) {\r\n              suspense.effects.push(...fn);\r\n          }\r\n          else {\r\n              suspense.effects.push(fn);\r\n          }\r\n      }\r\n      else {\r\n          queuePostFlushCb(fn);\r\n      }\r\n  }\r\n  function setActiveBranch(suspense, branch) {\r\n      suspense.activeBranch = branch;\r\n      const { vnode, parentComponent } = suspense;\r\n      const el = (vnode.el = branch.el);\r\n      // in case suspense is the root node of a component,\r\n      // recursively update the HOC el\r\n      if (parentComponent && parentComponent.subTree === vnode) {\r\n          parentComponent.vnode.el = el;\r\n          updateHOCHostEl(parentComponent, el);\r\n      }\r\n  }\n\n  function provide(key, value) {\r\n      if (!currentInstance) {\r\n          {\r\n              warn$1(`provide() can only be used inside setup().`);\r\n          }\r\n      }\r\n      else {\r\n          let provides = currentInstance.provides;\r\n          // by default an instance inherits its parent's provides object\r\n          // but when it needs to provide values of its own, it creates its\r\n          // own provides object using parent provides object as prototype.\r\n          // this way in `inject` we can simply look up injections from direct\r\n          // parent and let the prototype chain do the work.\r\n          const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n          if (parentProvides === provides) {\r\n              provides = currentInstance.provides = Object.create(parentProvides);\r\n          }\r\n          // TS doesn't allow symbol as index type\r\n          provides[key] = value;\r\n      }\r\n  }\r\n  function inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n      // fallback to `currentRenderingInstance` so that this can be called in\r\n      // a functional component\r\n      const instance = currentInstance || currentRenderingInstance;\r\n      if (instance) {\r\n          // #2400\r\n          // to support `app.use` plugins,\r\n          // fallback to appContext's `provides` if the instance is at root\r\n          const provides = instance.parent == null\r\n              ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n              : instance.parent.provides;\r\n          if (provides && key in provides) {\r\n              // TS doesn't allow symbol as index type\r\n              return provides[key];\r\n          }\r\n          else if (arguments.length > 1) {\r\n              return treatDefaultAsFactory && isFunction(defaultValue)\r\n                  ? defaultValue.call(instance.proxy)\r\n                  : defaultValue;\r\n          }\r\n          else {\r\n              warn$1(`injection \"${String(key)}\" not found.`);\r\n          }\r\n      }\r\n      else {\r\n          warn$1(`inject() can only be used inside setup() or functional components.`);\r\n      }\r\n  }\n\n  // Simple effect.\r\n  function watchEffect(effect, options) {\r\n      return doWatch(effect, null, options);\r\n  }\r\n  function watchPostEffect(effect, options) {\r\n      return doWatch(effect, null, (Object.assign(options || {}, { flush: 'post' })\r\n          ));\r\n  }\r\n  function watchSyncEffect(effect, options) {\r\n      return doWatch(effect, null, (Object.assign(options || {}, { flush: 'sync' })\r\n          ));\r\n  }\r\n  // initial value for watchers to trigger on undefined initial values\r\n  const INITIAL_WATCHER_VALUE = {};\r\n  // implementation\r\n  function watch(source, cb, options) {\r\n      if (!isFunction(cb)) {\r\n          warn$1(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n              `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n              `supports \\`watch(source, cb, options?) signature.`);\r\n      }\r\n      return doWatch(source, cb, options);\r\n  }\r\n  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\r\n      if (!cb) {\r\n          if (immediate !== undefined) {\r\n              warn$1(`watch() \"immediate\" option is only respected when using the ` +\r\n                  `watch(source, callback, options?) signature.`);\r\n          }\r\n          if (deep !== undefined) {\r\n              warn$1(`watch() \"deep\" option is only respected when using the ` +\r\n                  `watch(source, callback, options?) signature.`);\r\n          }\r\n      }\r\n      const warnInvalidSource = (s) => {\r\n          warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n              `a reactive object, or an array of these types.`);\r\n      };\r\n      const instance = currentInstance;\r\n      let getter;\r\n      let forceTrigger = false;\r\n      let isMultiSource = false;\r\n      if (isRef(source)) {\r\n          getter = () => source.value;\r\n          forceTrigger = isShallow(source);\r\n      }\r\n      else if (isReactive(source)) {\r\n          getter = () => source;\r\n          deep = true;\r\n      }\r\n      else if (isArray(source)) {\r\n          isMultiSource = true;\r\n          forceTrigger = source.some(isReactive);\r\n          getter = () => source.map(s => {\r\n              if (isRef(s)) {\r\n                  return s.value;\r\n              }\r\n              else if (isReactive(s)) {\r\n                  return traverse(s);\r\n              }\r\n              else if (isFunction(s)) {\r\n                  return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n              }\r\n              else {\r\n                  warnInvalidSource(s);\r\n              }\r\n          });\r\n      }\r\n      else if (isFunction(source)) {\r\n          if (cb) {\r\n              // getter with cb\r\n              getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n          }\r\n          else {\r\n              // no cb -> simple effect\r\n              getter = () => {\r\n                  if (instance && instance.isUnmounted) {\r\n                      return;\r\n                  }\r\n                  if (cleanup) {\r\n                      cleanup();\r\n                  }\r\n                  return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);\r\n              };\r\n          }\r\n      }\r\n      else {\r\n          getter = NOOP;\r\n          warnInvalidSource(source);\r\n      }\r\n      if (cb && deep) {\r\n          const baseGetter = getter;\r\n          getter = () => traverse(baseGetter());\r\n      }\r\n      let cleanup;\r\n      let onCleanup = (fn) => {\r\n          cleanup = effect.onStop = () => {\r\n              callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n          };\r\n      };\r\n      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n      const job = () => {\r\n          if (!effect.active) {\r\n              return;\r\n          }\r\n          if (cb) {\r\n              // watch(source, cb)\r\n              const newValue = effect.run();\r\n              if (deep ||\r\n                  forceTrigger ||\r\n                  (isMultiSource\r\n                      ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\r\n                      : hasChanged(newValue, oldValue)) ||\r\n                  (false  )) {\r\n                  // cleanup before running cb again\r\n                  if (cleanup) {\r\n                      cleanup();\r\n                  }\r\n                  callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                      newValue,\r\n                      // pass undefined as the old value when it's changed for the first time\r\n                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                      onCleanup\r\n                  ]);\r\n                  oldValue = newValue;\r\n              }\r\n          }\r\n          else {\r\n              // watchEffect\r\n              effect.run();\r\n          }\r\n      };\r\n      // important: mark the job as a watcher callback so that scheduler knows\r\n      // it is allowed to self-trigger (#1727)\r\n      job.allowRecurse = !!cb;\r\n      let scheduler;\r\n      if (flush === 'sync') {\r\n          scheduler = job; // the scheduler function gets called directly\r\n      }\r\n      else if (flush === 'post') {\r\n          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n      }\r\n      else {\r\n          // default: 'pre'\r\n          scheduler = () => {\r\n              if (!instance || instance.isMounted) {\r\n                  queuePreFlushCb(job);\r\n              }\r\n              else {\r\n                  // with 'pre' option, the first call must happen before\r\n                  // the component is mounted so it is called synchronously.\r\n                  job();\r\n              }\r\n          };\r\n      }\r\n      const effect = new ReactiveEffect(getter, scheduler);\r\n      {\r\n          effect.onTrack = onTrack;\r\n          effect.onTrigger = onTrigger;\r\n      }\r\n      // initial run\r\n      if (cb) {\r\n          if (immediate) {\r\n              job();\r\n          }\r\n          else {\r\n              oldValue = effect.run();\r\n          }\r\n      }\r\n      else if (flush === 'post') {\r\n          queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\r\n      }\r\n      else {\r\n          effect.run();\r\n      }\r\n      return () => {\r\n          effect.stop();\r\n          if (instance && instance.scope) {\r\n              remove(instance.scope.effects, effect);\r\n          }\r\n      };\r\n  }\r\n  // this.$watch\r\n  function instanceWatch(source, value, options) {\r\n      const publicThis = this.proxy;\r\n      const getter = isString(source)\r\n          ? source.includes('.')\r\n              ? createPathGetter(publicThis, source)\r\n              : () => publicThis[source]\r\n          : source.bind(publicThis, publicThis);\r\n      let cb;\r\n      if (isFunction(value)) {\r\n          cb = value;\r\n      }\r\n      else {\r\n          cb = value.handler;\r\n          options = value;\r\n      }\r\n      const cur = currentInstance;\r\n      setCurrentInstance(this);\r\n      const res = doWatch(getter, cb.bind(publicThis), options);\r\n      if (cur) {\r\n          setCurrentInstance(cur);\r\n      }\r\n      else {\r\n          unsetCurrentInstance();\r\n      }\r\n      return res;\r\n  }\r\n  function createPathGetter(ctx, path) {\r\n      const segments = path.split('.');\r\n      return () => {\r\n          let cur = ctx;\r\n          for (let i = 0; i < segments.length && cur; i++) {\r\n              cur = cur[segments[i]];\r\n          }\r\n          return cur;\r\n      };\r\n  }\r\n  function traverse(value, seen) {\r\n      if (!isObject(value) || value[\"__v_skip\" /* SKIP */]) {\r\n          return value;\r\n      }\r\n      seen = seen || new Set();\r\n      if (seen.has(value)) {\r\n          return value;\r\n      }\r\n      seen.add(value);\r\n      if (isRef(value)) {\r\n          traverse(value.value, seen);\r\n      }\r\n      else if (isArray(value)) {\r\n          for (let i = 0; i < value.length; i++) {\r\n              traverse(value[i], seen);\r\n          }\r\n      }\r\n      else if (isSet(value) || isMap(value)) {\r\n          value.forEach((v) => {\r\n              traverse(v, seen);\r\n          });\r\n      }\r\n      else if (isPlainObject(value)) {\r\n          for (const key in value) {\r\n              traverse(value[key], seen);\r\n          }\r\n      }\r\n      return value;\r\n  }\n\n  function useTransitionState() {\r\n      const state = {\r\n          isMounted: false,\r\n          isLeaving: false,\r\n          isUnmounting: false,\r\n          leavingVNodes: new Map()\r\n      };\r\n      onMounted(() => {\r\n          state.isMounted = true;\r\n      });\r\n      onBeforeUnmount(() => {\r\n          state.isUnmounting = true;\r\n      });\r\n      return state;\r\n  }\r\n  const TransitionHookValidator = [Function, Array];\r\n  const BaseTransitionImpl = {\r\n      name: `BaseTransition`,\r\n      props: {\r\n          mode: String,\r\n          appear: Boolean,\r\n          persisted: Boolean,\r\n          // enter\r\n          onBeforeEnter: TransitionHookValidator,\r\n          onEnter: TransitionHookValidator,\r\n          onAfterEnter: TransitionHookValidator,\r\n          onEnterCancelled: TransitionHookValidator,\r\n          // leave\r\n          onBeforeLeave: TransitionHookValidator,\r\n          onLeave: TransitionHookValidator,\r\n          onAfterLeave: TransitionHookValidator,\r\n          onLeaveCancelled: TransitionHookValidator,\r\n          // appear\r\n          onBeforeAppear: TransitionHookValidator,\r\n          onAppear: TransitionHookValidator,\r\n          onAfterAppear: TransitionHookValidator,\r\n          onAppearCancelled: TransitionHookValidator\r\n      },\r\n      setup(props, { slots }) {\r\n          const instance = getCurrentInstance();\r\n          const state = useTransitionState();\r\n          let prevTransitionKey;\r\n          return () => {\r\n              const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n              if (!children || !children.length) {\r\n                  return;\r\n              }\r\n              // warn multiple elements\r\n              if (children.length > 1) {\r\n                  warn$1('<transition> can only be used on a single element or component. Use ' +\r\n                      '<transition-group> for lists.');\r\n              }\r\n              // there's no need to track reactivity for these props so use the raw\r\n              // props for a bit better perf\r\n              const rawProps = toRaw(props);\r\n              const { mode } = rawProps;\r\n              // check mode\r\n              if (mode &&\r\n                  mode !== 'in-out' && mode !== 'out-in' && mode !== 'default') {\r\n                  warn$1(`invalid <transition> mode: ${mode}`);\r\n              }\r\n              // at this point children has a guaranteed length of 1.\r\n              const child = children[0];\r\n              if (state.isLeaving) {\r\n                  return emptyPlaceholder(child);\r\n              }\r\n              // in the case of <transition><keep-alive/></transition>, we need to\r\n              // compare the type of the kept-alive children.\r\n              const innerChild = getKeepAliveChild(child);\r\n              if (!innerChild) {\r\n                  return emptyPlaceholder(child);\r\n              }\r\n              const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n              setTransitionHooks(innerChild, enterHooks);\r\n              const oldChild = instance.subTree;\r\n              const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n              let transitionKeyChanged = false;\r\n              const { getTransitionKey } = innerChild.type;\r\n              if (getTransitionKey) {\r\n                  const key = getTransitionKey();\r\n                  if (prevTransitionKey === undefined) {\r\n                      prevTransitionKey = key;\r\n                  }\r\n                  else if (key !== prevTransitionKey) {\r\n                      prevTransitionKey = key;\r\n                      transitionKeyChanged = true;\r\n                  }\r\n              }\r\n              // handle mode\r\n              if (oldInnerChild &&\r\n                  oldInnerChild.type !== Comment &&\r\n                  (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                  const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                  // update old tree's hooks in case of dynamic transition\r\n                  setTransitionHooks(oldInnerChild, leavingHooks);\r\n                  // switching between different views\r\n                  if (mode === 'out-in') {\r\n                      state.isLeaving = true;\r\n                      // return placeholder node and queue update when leave finishes\r\n                      leavingHooks.afterLeave = () => {\r\n                          state.isLeaving = false;\r\n                          instance.update();\r\n                      };\r\n                      return emptyPlaceholder(child);\r\n                  }\r\n                  else if (mode === 'in-out' && innerChild.type !== Comment) {\r\n                      leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                          const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                          leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                          // early removal callback\r\n                          el._leaveCb = () => {\r\n                              earlyRemove();\r\n                              el._leaveCb = undefined;\r\n                              delete enterHooks.delayedLeave;\r\n                          };\r\n                          enterHooks.delayedLeave = delayedLeave;\r\n                      };\r\n                  }\r\n              }\r\n              return child;\r\n          };\r\n      }\r\n  };\r\n  // export the public type for h/tsx inference\r\n  // also to avoid inline import() in generated d.ts files\r\n  const BaseTransition = BaseTransitionImpl;\r\n  function getLeavingNodesForType(state, vnode) {\r\n      const { leavingVNodes } = state;\r\n      let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n      if (!leavingVNodesCache) {\r\n          leavingVNodesCache = Object.create(null);\r\n          leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n      }\r\n      return leavingVNodesCache;\r\n  }\r\n  // The transition hooks are attached to the vnode as vnode.transition\r\n  // and will be called at appropriate timing in the renderer.\r\n  function resolveTransitionHooks(vnode, props, state, instance) {\r\n      const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n      const key = String(vnode.key);\r\n      const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n      const callHook = (hook, args) => {\r\n          hook &&\r\n              callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n      };\r\n      const hooks = {\r\n          mode,\r\n          persisted,\r\n          beforeEnter(el) {\r\n              let hook = onBeforeEnter;\r\n              if (!state.isMounted) {\r\n                  if (appear) {\r\n                      hook = onBeforeAppear || onBeforeEnter;\r\n                  }\r\n                  else {\r\n                      return;\r\n                  }\r\n              }\r\n              // for same element (v-show)\r\n              if (el._leaveCb) {\r\n                  el._leaveCb(true /* cancelled */);\r\n              }\r\n              // for toggled element with same key (v-if)\r\n              const leavingVNode = leavingVNodesCache[key];\r\n              if (leavingVNode &&\r\n                  isSameVNodeType(vnode, leavingVNode) &&\r\n                  leavingVNode.el._leaveCb) {\r\n                  // force early removal (not cancelled)\r\n                  leavingVNode.el._leaveCb();\r\n              }\r\n              callHook(hook, [el]);\r\n          },\r\n          enter(el) {\r\n              let hook = onEnter;\r\n              let afterHook = onAfterEnter;\r\n              let cancelHook = onEnterCancelled;\r\n              if (!state.isMounted) {\r\n                  if (appear) {\r\n                      hook = onAppear || onEnter;\r\n                      afterHook = onAfterAppear || onAfterEnter;\r\n                      cancelHook = onAppearCancelled || onEnterCancelled;\r\n                  }\r\n                  else {\r\n                      return;\r\n                  }\r\n              }\r\n              let called = false;\r\n              const done = (el._enterCb = (cancelled) => {\r\n                  if (called)\r\n                      return;\r\n                  called = true;\r\n                  if (cancelled) {\r\n                      callHook(cancelHook, [el]);\r\n                  }\r\n                  else {\r\n                      callHook(afterHook, [el]);\r\n                  }\r\n                  if (hooks.delayedLeave) {\r\n                      hooks.delayedLeave();\r\n                  }\r\n                  el._enterCb = undefined;\r\n              });\r\n              if (hook) {\r\n                  hook(el, done);\r\n                  if (hook.length <= 1) {\r\n                      done();\r\n                  }\r\n              }\r\n              else {\r\n                  done();\r\n              }\r\n          },\r\n          leave(el, remove) {\r\n              const key = String(vnode.key);\r\n              if (el._enterCb) {\r\n                  el._enterCb(true /* cancelled */);\r\n              }\r\n              if (state.isUnmounting) {\r\n                  return remove();\r\n              }\r\n              callHook(onBeforeLeave, [el]);\r\n              let called = false;\r\n              const done = (el._leaveCb = (cancelled) => {\r\n                  if (called)\r\n                      return;\r\n                  called = true;\r\n                  remove();\r\n                  if (cancelled) {\r\n                      callHook(onLeaveCancelled, [el]);\r\n                  }\r\n                  else {\r\n                      callHook(onAfterLeave, [el]);\r\n                  }\r\n                  el._leaveCb = undefined;\r\n                  if (leavingVNodesCache[key] === vnode) {\r\n                      delete leavingVNodesCache[key];\r\n                  }\r\n              });\r\n              leavingVNodesCache[key] = vnode;\r\n              if (onLeave) {\r\n                  onLeave(el, done);\r\n                  if (onLeave.length <= 1) {\r\n                      done();\r\n                  }\r\n              }\r\n              else {\r\n                  done();\r\n              }\r\n          },\r\n          clone(vnode) {\r\n              return resolveTransitionHooks(vnode, props, state, instance);\r\n          }\r\n      };\r\n      return hooks;\r\n  }\r\n  // the placeholder really only handles one special case: KeepAlive\r\n  // in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n  // placeholder with empty content to avoid the KeepAlive instance from being\r\n  // unmounted.\r\n  function emptyPlaceholder(vnode) {\r\n      if (isKeepAlive(vnode)) {\r\n          vnode = cloneVNode(vnode);\r\n          vnode.children = null;\r\n          return vnode;\r\n      }\r\n  }\r\n  function getKeepAliveChild(vnode) {\r\n      return isKeepAlive(vnode)\r\n          ? vnode.children\r\n              ? vnode.children[0]\r\n              : undefined\r\n          : vnode;\r\n  }\r\n  function setTransitionHooks(vnode, hooks) {\r\n      if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n          setTransitionHooks(vnode.component.subTree, hooks);\r\n      }\r\n      else if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n          vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n      }\r\n      else {\r\n          vnode.transition = hooks;\r\n      }\r\n  }\r\n  function getTransitionRawChildren(children, keepComment = false) {\r\n      let ret = [];\r\n      let keyedFragmentCount = 0;\r\n      for (let i = 0; i < children.length; i++) {\r\n          const child = children[i];\r\n          // handle fragment children case, e.g. v-for\r\n          if (child.type === Fragment) {\r\n              if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                  keyedFragmentCount++;\r\n              ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\r\n          }\r\n          // comment placeholders should be skipped, e.g. v-if\r\n          else if (keepComment || child.type !== Comment) {\r\n              ret.push(child);\r\n          }\r\n      }\r\n      // #1126 if a transition children list contains multiple sub fragments, these\r\n      // fragments will be merged into a flat children array. Since each v-for\r\n      // fragment may contain different static bindings inside, we need to de-op\r\n      // these children to force full diffs to ensure correct behavior.\r\n      if (keyedFragmentCount > 1) {\r\n          for (let i = 0; i < ret.length; i++) {\r\n              ret[i].patchFlag = -2 /* BAIL */;\r\n          }\r\n      }\r\n      return ret;\r\n  }\n\n  // implementation, close to no-op\r\n  function defineComponent(options) {\r\n      return isFunction(options) ? { setup: options, name: options.name } : options;\r\n  }\n\n  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;\r\n  function defineAsyncComponent(source) {\r\n      if (isFunction(source)) {\r\n          source = { loader: source };\r\n      }\r\n      const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n      suspensible = true, onError: userOnError } = source;\r\n      let pendingRequest = null;\r\n      let resolvedComp;\r\n      let retries = 0;\r\n      const retry = () => {\r\n          retries++;\r\n          pendingRequest = null;\r\n          return load();\r\n      };\r\n      const load = () => {\r\n          let thisRequest;\r\n          return (pendingRequest ||\r\n              (thisRequest = pendingRequest =\r\n                  loader()\r\n                      .catch(err => {\r\n                      err = err instanceof Error ? err : new Error(String(err));\r\n                      if (userOnError) {\r\n                          return new Promise((resolve, reject) => {\r\n                              const userRetry = () => resolve(retry());\r\n                              const userFail = () => reject(err);\r\n                              userOnError(err, userRetry, userFail, retries + 1);\r\n                          });\r\n                      }\r\n                      else {\r\n                          throw err;\r\n                      }\r\n                  })\r\n                      .then((comp) => {\r\n                      if (thisRequest !== pendingRequest && pendingRequest) {\r\n                          return pendingRequest;\r\n                      }\r\n                      if (!comp) {\r\n                          warn$1(`Async component loader resolved to undefined. ` +\r\n                              `If you are using retry(), make sure to return its return value.`);\r\n                      }\r\n                      // interop module default\r\n                      if (comp &&\r\n                          (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                          comp = comp.default;\r\n                      }\r\n                      if (comp && !isObject(comp) && !isFunction(comp)) {\r\n                          throw new Error(`Invalid async component load result: ${comp}`);\r\n                      }\r\n                      resolvedComp = comp;\r\n                      return comp;\r\n                  })));\r\n      };\r\n      return defineComponent({\r\n          name: 'AsyncComponentWrapper',\r\n          __asyncLoader: load,\r\n          get __asyncResolved() {\r\n              return resolvedComp;\r\n          },\r\n          setup() {\r\n              const instance = currentInstance;\r\n              // already resolved\r\n              if (resolvedComp) {\r\n                  return () => createInnerComp(resolvedComp, instance);\r\n              }\r\n              const onError = (err) => {\r\n                  pendingRequest = null;\r\n                  handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n              };\r\n              // suspense-controlled or SSR.\r\n              if ((suspensible && instance.suspense) ||\r\n                  (false )) {\r\n                  return load()\r\n                      .then(comp => {\r\n                      return () => createInnerComp(comp, instance);\r\n                  })\r\n                      .catch(err => {\r\n                      onError(err);\r\n                      return () => errorComponent\r\n                          ? createVNode(errorComponent, {\r\n                              error: err\r\n                          })\r\n                          : null;\r\n                  });\r\n              }\r\n              const loaded = ref(false);\r\n              const error = ref();\r\n              const delayed = ref(!!delay);\r\n              if (delay) {\r\n                  setTimeout(() => {\r\n                      delayed.value = false;\r\n                  }, delay);\r\n              }\r\n              if (timeout != null) {\r\n                  setTimeout(() => {\r\n                      if (!loaded.value && !error.value) {\r\n                          const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                          onError(err);\r\n                          error.value = err;\r\n                      }\r\n                  }, timeout);\r\n              }\r\n              load()\r\n                  .then(() => {\r\n                  loaded.value = true;\r\n                  if (instance.parent && isKeepAlive(instance.parent.vnode)) {\r\n                      // parent is keep-alive, force update so the loaded component's\r\n                      // name is taken into account\r\n                      queueJob(instance.parent.update);\r\n                  }\r\n              })\r\n                  .catch(err => {\r\n                  onError(err);\r\n                  error.value = err;\r\n              });\r\n              return () => {\r\n                  if (loaded.value && resolvedComp) {\r\n                      return createInnerComp(resolvedComp, instance);\r\n                  }\r\n                  else if (error.value && errorComponent) {\r\n                      return createVNode(errorComponent, {\r\n                          error: error.value\r\n                      });\r\n                  }\r\n                  else if (loadingComponent && !delayed.value) {\r\n                      return createVNode(loadingComponent);\r\n                  }\r\n              };\r\n          }\r\n      });\r\n  }\r\n  function createInnerComp(comp, { vnode: { ref, props, children } }) {\r\n      const vnode = createVNode(comp, props, children);\r\n      // ensure inner component inherits the async wrapper's ref owner\r\n      vnode.ref = ref;\r\n      return vnode;\r\n  }\n\n  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\n  const KeepAliveImpl = {\r\n      name: `KeepAlive`,\r\n      // Marker for special handling inside the renderer. We are not using a ===\r\n      // check directly on KeepAlive in the renderer, because importing it directly\r\n      // would prevent it from being tree-shaken.\r\n      __isKeepAlive: true,\r\n      props: {\r\n          include: [String, RegExp, Array],\r\n          exclude: [String, RegExp, Array],\r\n          max: [String, Number]\r\n      },\r\n      setup(props, { slots }) {\r\n          const instance = getCurrentInstance();\r\n          // KeepAlive communicates with the instantiated renderer via the\r\n          // ctx where the renderer passes in its internals,\r\n          // and the KeepAlive instance exposes activate/deactivate implementations.\r\n          // The whole point of this is to avoid importing KeepAlive directly in the\r\n          // renderer to facilitate tree-shaking.\r\n          const sharedContext = instance.ctx;\r\n          // if the internal renderer is not registered, it indicates that this is server-side rendering,\r\n          // for KeepAlive, we just need to render its children\r\n          if (!sharedContext.renderer) {\r\n              return slots.default;\r\n          }\r\n          const cache = new Map();\r\n          const keys = new Set();\r\n          let current = null;\r\n          {\r\n              instance.__v_cache = cache;\r\n          }\r\n          const parentSuspense = instance.suspense;\r\n          const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n          const storageContainer = createElement('div');\r\n          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n              const instance = vnode.component;\r\n              move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n              // in case props have changed\r\n              patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\r\n              queuePostRenderEffect(() => {\r\n                  instance.isDeactivated = false;\r\n                  if (instance.a) {\r\n                      invokeArrayFns(instance.a);\r\n                  }\r\n                  const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                  if (vnodeHook) {\r\n                      invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                  }\r\n              }, parentSuspense);\r\n              {\r\n                  // Update components tree\r\n                  devtoolsComponentAdded(instance);\r\n              }\r\n          };\r\n          sharedContext.deactivate = (vnode) => {\r\n              const instance = vnode.component;\r\n              move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n              queuePostRenderEffect(() => {\r\n                  if (instance.da) {\r\n                      invokeArrayFns(instance.da);\r\n                  }\r\n                  const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                  if (vnodeHook) {\r\n                      invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                  }\r\n                  instance.isDeactivated = true;\r\n              }, parentSuspense);\r\n              {\r\n                  // Update components tree\r\n                  devtoolsComponentAdded(instance);\r\n              }\r\n          };\r\n          function unmount(vnode) {\r\n              // reset the shapeFlag so it can be properly unmounted\r\n              resetShapeFlag(vnode);\r\n              _unmount(vnode, instance, parentSuspense, true);\r\n          }\r\n          function pruneCache(filter) {\r\n              cache.forEach((vnode, key) => {\r\n                  const name = getComponentName(vnode.type);\r\n                  if (name && (!filter || !filter(name))) {\r\n                      pruneCacheEntry(key);\r\n                  }\r\n              });\r\n          }\r\n          function pruneCacheEntry(key) {\r\n              const cached = cache.get(key);\r\n              if (!current || cached.type !== current.type) {\r\n                  unmount(cached);\r\n              }\r\n              else if (current) {\r\n                  // current active instance should no longer be kept-alive.\r\n                  // we can't unmount it now but it might be later, so reset its flag now.\r\n                  resetShapeFlag(current);\r\n              }\r\n              cache.delete(key);\r\n              keys.delete(key);\r\n          }\r\n          // prune cache on include/exclude prop change\r\n          watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n              include && pruneCache(name => matches(include, name));\r\n              exclude && pruneCache(name => !matches(exclude, name));\r\n          }, \r\n          // prune post-render after `current` has been updated\r\n          { flush: 'post', deep: true });\r\n          // cache sub tree after render\r\n          let pendingCacheKey = null;\r\n          const cacheSubtree = () => {\r\n              // fix #1621, the pendingCacheKey could be 0\r\n              if (pendingCacheKey != null) {\r\n                  cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n              }\r\n          };\r\n          onMounted(cacheSubtree);\r\n          onUpdated(cacheSubtree);\r\n          onBeforeUnmount(() => {\r\n              cache.forEach(cached => {\r\n                  const { subTree, suspense } = instance;\r\n                  const vnode = getInnerChild(subTree);\r\n                  if (cached.type === vnode.type) {\r\n                      // current instance will be unmounted as part of keep-alive's unmount\r\n                      resetShapeFlag(vnode);\r\n                      // but invoke its deactivated hook here\r\n                      const da = vnode.component.da;\r\n                      da && queuePostRenderEffect(da, suspense);\r\n                      return;\r\n                  }\r\n                  unmount(cached);\r\n              });\r\n          });\r\n          return () => {\r\n              pendingCacheKey = null;\r\n              if (!slots.default) {\r\n                  return null;\r\n              }\r\n              const children = slots.default();\r\n              const rawVNode = children[0];\r\n              if (children.length > 1) {\r\n                  {\r\n                      warn$1(`KeepAlive should contain exactly one component child.`);\r\n                  }\r\n                  current = null;\r\n                  return children;\r\n              }\r\n              else if (!isVNode(rawVNode) ||\r\n                  (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                      !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                  current = null;\r\n                  return rawVNode;\r\n              }\r\n              let vnode = getInnerChild(rawVNode);\r\n              const comp = vnode.type;\r\n              // for async components, name check should be based in its loaded\r\n              // inner component if available\r\n              const name = getComponentName(isAsyncWrapper(vnode)\r\n                  ? vnode.type.__asyncResolved || {}\r\n                  : comp);\r\n              const { include, exclude, max } = props;\r\n              if ((include && (!name || !matches(include, name))) ||\r\n                  (exclude && name && matches(exclude, name))) {\r\n                  current = vnode;\r\n                  return rawVNode;\r\n              }\r\n              const key = vnode.key == null ? comp : vnode.key;\r\n              const cachedVNode = cache.get(key);\r\n              // clone vnode if it's reused because we are going to mutate it\r\n              if (vnode.el) {\r\n                  vnode = cloneVNode(vnode);\r\n                  if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                      rawVNode.ssContent = vnode;\r\n                  }\r\n              }\r\n              // #1513 it's possible for the returned vnode to be cloned due to attr\r\n              // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n              // that is mounted. Instead of caching it directly, we store the pending\r\n              // key and cache `instance.subTree` (the normalized vnode) in\r\n              // beforeMount/beforeUpdate hooks.\r\n              pendingCacheKey = key;\r\n              if (cachedVNode) {\r\n                  // copy over mounted state\r\n                  vnode.el = cachedVNode.el;\r\n                  vnode.component = cachedVNode.component;\r\n                  if (vnode.transition) {\r\n                      // recursively update transition hooks on subTree\r\n                      setTransitionHooks(vnode, vnode.transition);\r\n                  }\r\n                  // avoid vnode being mounted as fresh\r\n                  vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                  // make this key the freshest\r\n                  keys.delete(key);\r\n                  keys.add(key);\r\n              }\r\n              else {\r\n                  keys.add(key);\r\n                  // prune oldest entry\r\n                  if (max && keys.size > parseInt(max, 10)) {\r\n                      pruneCacheEntry(keys.values().next().value);\r\n                  }\r\n              }\r\n              // avoid vnode being unmounted\r\n              vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n              current = vnode;\r\n              return rawVNode;\r\n          };\r\n      }\r\n  };\r\n  // export the public type for h/tsx inference\r\n  // also to avoid inline import() in generated d.ts files\r\n  const KeepAlive = KeepAliveImpl;\r\n  function matches(pattern, name) {\r\n      if (isArray(pattern)) {\r\n          return pattern.some((p) => matches(p, name));\r\n      }\r\n      else if (isString(pattern)) {\r\n          return pattern.split(',').includes(name);\r\n      }\r\n      else if (pattern.test) {\r\n          return pattern.test(name);\r\n      }\r\n      /* istanbul ignore next */\r\n      return false;\r\n  }\r\n  function onActivated(hook, target) {\r\n      registerKeepAliveHook(hook, \"a\" /* ACTIVATED */, target);\r\n  }\r\n  function onDeactivated(hook, target) {\r\n      registerKeepAliveHook(hook, \"da\" /* DEACTIVATED */, target);\r\n  }\r\n  function registerKeepAliveHook(hook, type, target = currentInstance) {\r\n      // cache the deactivate branch check wrapper for injected hooks so the same\r\n      // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n      // deactivation check\".\r\n      const wrappedHook = hook.__wdc ||\r\n          (hook.__wdc = () => {\r\n              // only fire the hook if the target instance is NOT in a deactivated branch.\r\n              let current = target;\r\n              while (current) {\r\n                  if (current.isDeactivated) {\r\n                      return;\r\n                  }\r\n                  current = current.parent;\r\n              }\r\n              return hook();\r\n          });\r\n      injectHook(type, wrappedHook, target);\r\n      // In addition to registering it on the target instance, we walk up the parent\r\n      // chain and register it on all ancestor instances that are keep-alive roots.\r\n      // This avoids the need to walk the entire component tree when invoking these\r\n      // hooks, and more importantly, avoids the need to track child components in\r\n      // arrays.\r\n      if (target) {\r\n          let current = target.parent;\r\n          while (current && current.parent) {\r\n              if (isKeepAlive(current.parent.vnode)) {\r\n                  injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n              }\r\n              current = current.parent;\r\n          }\r\n      }\r\n  }\r\n  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n      // injectHook wraps the original for error handling, so make sure to remove\r\n      // the wrapped version.\r\n      const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n      onUnmounted(() => {\r\n          remove(keepAliveRoot[type], injected);\r\n      }, target);\r\n  }\r\n  function resetShapeFlag(vnode) {\r\n      let shapeFlag = vnode.shapeFlag;\r\n      if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n          shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n      }\r\n      if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n          shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n      }\r\n      vnode.shapeFlag = shapeFlag;\r\n  }\r\n  function getInnerChild(vnode) {\r\n      return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n  }\n\n  function injectHook(type, hook, target = currentInstance, prepend = false) {\r\n      if (target) {\r\n          const hooks = target[type] || (target[type] = []);\r\n          // cache the error handling wrapper for injected hooks so the same hook\r\n          // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n          // handling\".\r\n          const wrappedHook = hook.__weh ||\r\n              (hook.__weh = (...args) => {\r\n                  if (target.isUnmounted) {\r\n                      return;\r\n                  }\r\n                  // disable tracking inside all lifecycle hooks\r\n                  // since they can potentially be called inside effects.\r\n                  pauseTracking();\r\n                  // Set currentInstance during hook invocation.\r\n                  // This assumes the hook does not synchronously trigger other hooks, which\r\n                  // can only be false when the user does something really funky.\r\n                  setCurrentInstance(target);\r\n                  const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                  unsetCurrentInstance();\r\n                  resetTracking();\r\n                  return res;\r\n              });\r\n          if (prepend) {\r\n              hooks.unshift(wrappedHook);\r\n          }\r\n          else {\r\n              hooks.push(wrappedHook);\r\n          }\r\n          return wrappedHook;\r\n      }\r\n      else {\r\n          const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));\r\n          warn$1(`${apiName} is called when there is no active component instance to be ` +\r\n              `associated with. ` +\r\n              `Lifecycle injection APIs can only be used during execution of setup().` +\r\n              (` If you are using async setup(), make sure to register lifecycle ` +\r\n                      `hooks before the first await statement.`\r\n                  ));\r\n      }\r\n  }\r\n  const createHook = (lifecycle) => (hook, target = currentInstance) => \r\n  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\r\n  (!isInSSRComponentSetup || lifecycle === \"sp\" /* SERVER_PREFETCH */) &&\r\n      injectHook(lifecycle, hook, target);\r\n  const onBeforeMount = createHook(\"bm\" /* BEFORE_MOUNT */);\r\n  const onMounted = createHook(\"m\" /* MOUNTED */);\r\n  const onBeforeUpdate = createHook(\"bu\" /* BEFORE_UPDATE */);\r\n  const onUpdated = createHook(\"u\" /* UPDATED */);\r\n  const onBeforeUnmount = createHook(\"bum\" /* BEFORE_UNMOUNT */);\r\n  const onUnmounted = createHook(\"um\" /* UNMOUNTED */);\r\n  const onServerPrefetch = createHook(\"sp\" /* SERVER_PREFETCH */);\r\n  const onRenderTriggered = createHook(\"rtg\" /* RENDER_TRIGGERED */);\r\n  const onRenderTracked = createHook(\"rtc\" /* RENDER_TRACKED */);\r\n  function onErrorCaptured(hook, target = currentInstance) {\r\n      injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n  }\n\n  function createDuplicateChecker() {\r\n      const cache = Object.create(null);\r\n      return (type, key) => {\r\n          if (cache[key]) {\r\n              warn$1(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\r\n          }\r\n          else {\r\n              cache[key] = type;\r\n          }\r\n      };\r\n  }\r\n  let shouldCacheAccess = true;\r\n  function applyOptions(instance) {\r\n      const options = resolveMergedOptions(instance);\r\n      const publicThis = instance.proxy;\r\n      const ctx = instance.ctx;\r\n      // do not cache property access on public proxy during state initialization\r\n      shouldCacheAccess = false;\r\n      // call beforeCreate first before accessing other options since\r\n      // the hook may mutate resolved options (#2791)\r\n      if (options.beforeCreate) {\r\n          callHook(options.beforeCreate, instance, \"bc\" /* BEFORE_CREATE */);\r\n      }\r\n      const { \r\n      // state\r\n      data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n      // lifecycle\r\n      created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, \r\n      // public API\r\n      expose, inheritAttrs, \r\n      // assets\r\n      components, directives, filters } = options;\r\n      const checkDuplicateProperties = createDuplicateChecker() ;\r\n      {\r\n          const [propsOptions] = instance.propsOptions;\r\n          if (propsOptions) {\r\n              for (const key in propsOptions) {\r\n                  checkDuplicateProperties(\"Props\" /* PROPS */, key);\r\n              }\r\n          }\r\n      }\r\n      // options initialization order (to be consistent with Vue 2):\r\n      // - props (already done outside of this function)\r\n      // - inject\r\n      // - methods\r\n      // - data (deferred since it relies on `this` access)\r\n      // - computed\r\n      // - watch (deferred since it relies on `this` access)\r\n      if (injectOptions) {\r\n          resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);\r\n      }\r\n      if (methods) {\r\n          for (const key in methods) {\r\n              const methodHandler = methods[key];\r\n              if (isFunction(methodHandler)) {\r\n                  // In dev mode, we use the `createRenderContext` function to define\r\n                  // methods to the proxy target, and those are read-only but\r\n                  // reconfigurable, so it needs to be redefined here\r\n                  {\r\n                      Object.defineProperty(ctx, key, {\r\n                          value: methodHandler.bind(publicThis),\r\n                          configurable: true,\r\n                          enumerable: true,\r\n                          writable: true\r\n                      });\r\n                  }\r\n                  {\r\n                      checkDuplicateProperties(\"Methods\" /* METHODS */, key);\r\n                  }\r\n              }\r\n              else {\r\n                  warn$1(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\r\n                      `Did you reference the function correctly?`);\r\n              }\r\n          }\r\n      }\r\n      if (dataOptions) {\r\n          if (!isFunction(dataOptions)) {\r\n              warn$1(`The data option must be a function. ` +\r\n                  `Plain object usage is no longer supported.`);\r\n          }\r\n          const data = dataOptions.call(publicThis, publicThis);\r\n          if (isPromise(data)) {\r\n              warn$1(`data() returned a Promise - note data() cannot be async; If you ` +\r\n                  `intend to perform data fetching before component renders, use ` +\r\n                  `async setup() + <Suspense>.`);\r\n          }\r\n          if (!isObject(data)) {\r\n              warn$1(`data() should return an object.`);\r\n          }\r\n          else {\r\n              instance.data = reactive(data);\r\n              {\r\n                  for (const key in data) {\r\n                      checkDuplicateProperties(\"Data\" /* DATA */, key);\r\n                      // expose data on ctx during dev\r\n                      if (key[0] !== '$' && key[0] !== '_') {\r\n                          Object.defineProperty(ctx, key, {\r\n                              configurable: true,\r\n                              enumerable: true,\r\n                              get: () => data[key],\r\n                              set: NOOP\r\n                          });\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      // state initialization complete at this point - start caching access\r\n      shouldCacheAccess = true;\r\n      if (computedOptions) {\r\n          for (const key in computedOptions) {\r\n              const opt = computedOptions[key];\r\n              const get = isFunction(opt)\r\n                  ? opt.bind(publicThis, publicThis)\r\n                  : isFunction(opt.get)\r\n                      ? opt.get.bind(publicThis, publicThis)\r\n                      : NOOP;\r\n              if (get === NOOP) {\r\n                  warn$1(`Computed property \"${key}\" has no getter.`);\r\n              }\r\n              const set = !isFunction(opt) && isFunction(opt.set)\r\n                  ? opt.set.bind(publicThis)\r\n                  : () => {\r\n                          warn$1(`Write operation failed: computed property \"${key}\" is readonly.`);\r\n                      }\r\n                      ;\r\n              const c = computed$1({\r\n                  get,\r\n                  set\r\n              });\r\n              Object.defineProperty(ctx, key, {\r\n                  enumerable: true,\r\n                  configurable: true,\r\n                  get: () => c.value,\r\n                  set: v => (c.value = v)\r\n              });\r\n              {\r\n                  checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\r\n              }\r\n          }\r\n      }\r\n      if (watchOptions) {\r\n          for (const key in watchOptions) {\r\n              createWatcher(watchOptions[key], ctx, publicThis, key);\r\n          }\r\n      }\r\n      if (provideOptions) {\r\n          const provides = isFunction(provideOptions)\r\n              ? provideOptions.call(publicThis)\r\n              : provideOptions;\r\n          Reflect.ownKeys(provides).forEach(key => {\r\n              provide(key, provides[key]);\r\n          });\r\n      }\r\n      if (created) {\r\n          callHook(created, instance, \"c\" /* CREATED */);\r\n      }\r\n      function registerLifecycleHook(register, hook) {\r\n          if (isArray(hook)) {\r\n              hook.forEach(_hook => register(_hook.bind(publicThis)));\r\n          }\r\n          else if (hook) {\r\n              register(hook.bind(publicThis));\r\n          }\r\n      }\r\n      registerLifecycleHook(onBeforeMount, beforeMount);\r\n      registerLifecycleHook(onMounted, mounted);\r\n      registerLifecycleHook(onBeforeUpdate, beforeUpdate);\r\n      registerLifecycleHook(onUpdated, updated);\r\n      registerLifecycleHook(onActivated, activated);\r\n      registerLifecycleHook(onDeactivated, deactivated);\r\n      registerLifecycleHook(onErrorCaptured, errorCaptured);\r\n      registerLifecycleHook(onRenderTracked, renderTracked);\r\n      registerLifecycleHook(onRenderTriggered, renderTriggered);\r\n      registerLifecycleHook(onBeforeUnmount, beforeUnmount);\r\n      registerLifecycleHook(onUnmounted, unmounted);\r\n      registerLifecycleHook(onServerPrefetch, serverPrefetch);\r\n      if (isArray(expose)) {\r\n          if (expose.length) {\r\n              const exposed = instance.exposed || (instance.exposed = {});\r\n              expose.forEach(key => {\r\n                  Object.defineProperty(exposed, key, {\r\n                      get: () => publicThis[key],\r\n                      set: val => (publicThis[key] = val)\r\n                  });\r\n              });\r\n          }\r\n          else if (!instance.exposed) {\r\n              instance.exposed = {};\r\n          }\r\n      }\r\n      // options that are handled when creating the instance but also need to be\r\n      // applied from mixins\r\n      if (render && instance.render === NOOP) {\r\n          instance.render = render;\r\n      }\r\n      if (inheritAttrs != null) {\r\n          instance.inheritAttrs = inheritAttrs;\r\n      }\r\n      // asset options.\r\n      if (components)\r\n          instance.components = components;\r\n      if (directives)\r\n          instance.directives = directives;\r\n  }\r\n  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {\r\n      if (isArray(injectOptions)) {\r\n          injectOptions = normalizeInject(injectOptions);\r\n      }\r\n      for (const key in injectOptions) {\r\n          const opt = injectOptions[key];\r\n          let injected;\r\n          if (isObject(opt)) {\r\n              if ('default' in opt) {\r\n                  injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n              }\r\n              else {\r\n                  injected = inject(opt.from || key);\r\n              }\r\n          }\r\n          else {\r\n              injected = inject(opt);\r\n          }\r\n          if (isRef(injected)) {\r\n              // TODO remove the check in 3.3\r\n              if (unwrapRef) {\r\n                  Object.defineProperty(ctx, key, {\r\n                      enumerable: true,\r\n                      configurable: true,\r\n                      get: () => injected.value,\r\n                      set: v => (injected.value = v)\r\n                  });\r\n              }\r\n              else {\r\n                  {\r\n                      warn$1(`injected property \"${key}\" is a ref and will be auto-unwrapped ` +\r\n                          `and no longer needs \\`.value\\` in the next minor release. ` +\r\n                          `To opt-in to the new behavior now, ` +\r\n                          `set \\`app.config.unwrapInjectedRef = true\\` (this config is ` +\r\n                          `temporary and will not be needed in the future.)`);\r\n                  }\r\n                  ctx[key] = injected;\r\n              }\r\n          }\r\n          else {\r\n              ctx[key] = injected;\r\n          }\r\n          {\r\n              checkDuplicateProperties(\"Inject\" /* INJECT */, key);\r\n          }\r\n      }\r\n  }\r\n  function callHook(hook, instance, type) {\r\n      callWithAsyncErrorHandling(isArray(hook)\r\n          ? hook.map(h => h.bind(instance.proxy))\r\n          : hook.bind(instance.proxy), instance, type);\r\n  }\r\n  function createWatcher(raw, ctx, publicThis, key) {\r\n      const getter = key.includes('.')\r\n          ? createPathGetter(publicThis, key)\r\n          : () => publicThis[key];\r\n      if (isString(raw)) {\r\n          const handler = ctx[raw];\r\n          if (isFunction(handler)) {\r\n              watch(getter, handler);\r\n          }\r\n          else {\r\n              warn$1(`Invalid watch handler specified by key \"${raw}\"`, handler);\r\n          }\r\n      }\r\n      else if (isFunction(raw)) {\r\n          watch(getter, raw.bind(publicThis));\r\n      }\r\n      else if (isObject(raw)) {\r\n          if (isArray(raw)) {\r\n              raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n          }\r\n          else {\r\n              const handler = isFunction(raw.handler)\r\n                  ? raw.handler.bind(publicThis)\r\n                  : ctx[raw.handler];\r\n              if (isFunction(handler)) {\r\n                  watch(getter, handler, raw);\r\n              }\r\n              else {\r\n                  warn$1(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          warn$1(`Invalid watch option: \"${key}\"`, raw);\r\n      }\r\n  }\r\n  /**\r\n   * Resolve merged options and cache it on the component.\r\n   * This is done only once per-component since the merging does not involve\r\n   * instances.\r\n   */\r\n  function resolveMergedOptions(instance) {\r\n      const base = instance.type;\r\n      const { mixins, extends: extendsOptions } = base;\r\n      const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;\r\n      const cached = cache.get(base);\r\n      let resolved;\r\n      if (cached) {\r\n          resolved = cached;\r\n      }\r\n      else if (!globalMixins.length && !mixins && !extendsOptions) {\r\n          {\r\n              resolved = base;\r\n          }\r\n      }\r\n      else {\r\n          resolved = {};\r\n          if (globalMixins.length) {\r\n              globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\r\n          }\r\n          mergeOptions(resolved, base, optionMergeStrategies);\r\n      }\r\n      cache.set(base, resolved);\r\n      return resolved;\r\n  }\r\n  function mergeOptions(to, from, strats, asMixin = false) {\r\n      const { mixins, extends: extendsOptions } = from;\r\n      if (extendsOptions) {\r\n          mergeOptions(to, extendsOptions, strats, true);\r\n      }\r\n      if (mixins) {\r\n          mixins.forEach((m) => mergeOptions(to, m, strats, true));\r\n      }\r\n      for (const key in from) {\r\n          if (asMixin && key === 'expose') {\r\n              warn$1(`\"expose\" option is ignored when declared in mixins or extends. ` +\r\n                      `It should only be declared in the base component itself.`);\r\n          }\r\n          else {\r\n              const strat = internalOptionMergeStrats[key] || (strats && strats[key]);\r\n              to[key] = strat ? strat(to[key], from[key]) : from[key];\r\n          }\r\n      }\r\n      return to;\r\n  }\r\n  const internalOptionMergeStrats = {\r\n      data: mergeDataFn,\r\n      props: mergeObjectOptions,\r\n      emits: mergeObjectOptions,\r\n      // objects\r\n      methods: mergeObjectOptions,\r\n      computed: mergeObjectOptions,\r\n      // lifecycle\r\n      beforeCreate: mergeAsArray,\r\n      created: mergeAsArray,\r\n      beforeMount: mergeAsArray,\r\n      mounted: mergeAsArray,\r\n      beforeUpdate: mergeAsArray,\r\n      updated: mergeAsArray,\r\n      beforeDestroy: mergeAsArray,\r\n      beforeUnmount: mergeAsArray,\r\n      destroyed: mergeAsArray,\r\n      unmounted: mergeAsArray,\r\n      activated: mergeAsArray,\r\n      deactivated: mergeAsArray,\r\n      errorCaptured: mergeAsArray,\r\n      serverPrefetch: mergeAsArray,\r\n      // assets\r\n      components: mergeObjectOptions,\r\n      directives: mergeObjectOptions,\r\n      // watch\r\n      watch: mergeWatchOptions,\r\n      // provide / inject\r\n      provide: mergeDataFn,\r\n      inject: mergeInject\r\n  };\r\n  function mergeDataFn(to, from) {\r\n      if (!from) {\r\n          return to;\r\n      }\r\n      if (!to) {\r\n          return from;\r\n      }\r\n      return function mergedDataFn() {\r\n          return (extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);\r\n      };\r\n  }\r\n  function mergeInject(to, from) {\r\n      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\r\n  }\r\n  function normalizeInject(raw) {\r\n      if (isArray(raw)) {\r\n          const res = {};\r\n          for (let i = 0; i < raw.length; i++) {\r\n              res[raw[i]] = raw[i];\r\n          }\r\n          return res;\r\n      }\r\n      return raw;\r\n  }\r\n  function mergeAsArray(to, from) {\r\n      return to ? [...new Set([].concat(to, from))] : from;\r\n  }\r\n  function mergeObjectOptions(to, from) {\r\n      return to ? extend(extend(Object.create(null), to), from) : from;\r\n  }\r\n  function mergeWatchOptions(to, from) {\r\n      if (!to)\r\n          return from;\r\n      if (!from)\r\n          return to;\r\n      const merged = extend(Object.create(null), to);\r\n      for (const key in from) {\r\n          merged[key] = mergeAsArray(to[key], from[key]);\r\n      }\r\n      return merged;\r\n  }\n\n  function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\n  isSSR = false) {\r\n      const props = {};\r\n      const attrs = {};\r\n      def(attrs, InternalObjectKey, 1);\r\n      instance.propsDefaults = Object.create(null);\r\n      setFullProps(instance, rawProps, props, attrs);\r\n      // ensure all declared prop keys are present\r\n      for (const key in instance.propsOptions[0]) {\r\n          if (!(key in props)) {\r\n              props[key] = undefined;\r\n          }\r\n      }\r\n      // validation\r\n      {\r\n          validateProps(rawProps || {}, props, instance);\r\n      }\r\n      if (isStateful) {\r\n          // stateful\r\n          instance.props = isSSR ? props : shallowReactive(props);\r\n      }\r\n      else {\r\n          if (!instance.type.props) {\r\n              // functional w/ optional props, props === attrs\r\n              instance.props = attrs;\r\n          }\r\n          else {\r\n              // functional w/ declared props\r\n              instance.props = props;\r\n          }\r\n      }\r\n      instance.attrs = attrs;\r\n  }\r\n  function updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n      const { props, attrs, vnode: { patchFlag } } = instance;\r\n      const rawCurrentProps = toRaw(props);\r\n      const [options] = instance.propsOptions;\r\n      let hasAttrsChanged = false;\r\n      if (\r\n      // always force full diff in dev\r\n      // - #1942 if hmr is enabled with sfc component\r\n      // - vite#872 non-sfc component used by sfc component\r\n      !((instance.type.__hmrId ||\r\n              (instance.parent && instance.parent.type.__hmrId))) &&\r\n          (optimized || patchFlag > 0) &&\r\n          !(patchFlag & 16 /* FULL_PROPS */)) {\r\n          if (patchFlag & 8 /* PROPS */) {\r\n              // Compiler-generated props & no keys change, just set the updated\r\n              // the props.\r\n              const propsToUpdate = instance.vnode.dynamicProps;\r\n              for (let i = 0; i < propsToUpdate.length; i++) {\r\n                  let key = propsToUpdate[i];\r\n                  // PROPS flag guarantees rawProps to be non-null\r\n                  const value = rawProps[key];\r\n                  if (options) {\r\n                      // attr / props separation was done on init and will be consistent\r\n                      // in this code path, so just check if attrs have it.\r\n                      if (hasOwn(attrs, key)) {\r\n                          if (value !== attrs[key]) {\r\n                              attrs[key] = value;\r\n                              hasAttrsChanged = true;\r\n                          }\r\n                      }\r\n                      else {\r\n                          const camelizedKey = camelize(key);\r\n                          props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);\r\n                      }\r\n                  }\r\n                  else {\r\n                      if (value !== attrs[key]) {\r\n                          attrs[key] = value;\r\n                          hasAttrsChanged = true;\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          // full props update.\r\n          if (setFullProps(instance, rawProps, props, attrs)) {\r\n              hasAttrsChanged = true;\r\n          }\r\n          // in case of dynamic props, check if we need to delete keys from\r\n          // the props object\r\n          let kebabKey;\r\n          for (const key in rawCurrentProps) {\r\n              if (!rawProps ||\r\n                  // for camelCase\r\n                  (!hasOwn(rawProps, key) &&\r\n                      // it's possible the original props was passed in as kebab-case\r\n                      // and converted to camelCase (#955)\r\n                      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {\r\n                  if (options) {\r\n                      if (rawPrevProps &&\r\n                          // for camelCase\r\n                          (rawPrevProps[key] !== undefined ||\r\n                              // for kebab-case\r\n                              rawPrevProps[kebabKey] !== undefined)) {\r\n                          props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);\r\n                      }\r\n                  }\r\n                  else {\r\n                      delete props[key];\r\n                  }\r\n              }\r\n          }\r\n          // in the case of functional component w/o props declaration, props and\r\n          // attrs point to the same object so it should already have been updated.\r\n          if (attrs !== rawCurrentProps) {\r\n              for (const key in attrs) {\r\n                  if (!rawProps ||\r\n                      (!hasOwn(rawProps, key) &&\r\n                          (!false ))) {\r\n                      delete attrs[key];\r\n                      hasAttrsChanged = true;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      // trigger updates for $attrs in case it's used in component slots\r\n      if (hasAttrsChanged) {\r\n          trigger(instance, \"set\" /* SET */, '$attrs');\r\n      }\r\n      {\r\n          validateProps(rawProps || {}, props, instance);\r\n      }\r\n  }\r\n  function setFullProps(instance, rawProps, props, attrs) {\r\n      const [options, needCastKeys] = instance.propsOptions;\r\n      let hasAttrsChanged = false;\r\n      let rawCastValues;\r\n      if (rawProps) {\r\n          for (let key in rawProps) {\r\n              // key, ref are reserved and never passed down\r\n              if (isReservedProp(key)) {\r\n                  continue;\r\n              }\r\n              const value = rawProps[key];\r\n              // prop option names are camelized during normalization, so to support\r\n              // kebab -> camel conversion here we need to camelize the key.\r\n              let camelKey;\r\n              if (options && hasOwn(options, (camelKey = camelize(key)))) {\r\n                  if (!needCastKeys || !needCastKeys.includes(camelKey)) {\r\n                      props[camelKey] = value;\r\n                  }\r\n                  else {\r\n                      (rawCastValues || (rawCastValues = {}))[camelKey] = value;\r\n                  }\r\n              }\r\n              else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                  if (!(key in attrs) || value !== attrs[key]) {\r\n                      attrs[key] = value;\r\n                      hasAttrsChanged = true;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      if (needCastKeys) {\r\n          const rawCurrentProps = toRaw(props);\r\n          const castValues = rawCastValues || EMPTY_OBJ;\r\n          for (let i = 0; i < needCastKeys.length; i++) {\r\n              const key = needCastKeys[i];\r\n              props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));\r\n          }\r\n      }\r\n      return hasAttrsChanged;\r\n  }\r\n  function resolvePropValue(options, props, key, value, instance, isAbsent) {\r\n      const opt = options[key];\r\n      if (opt != null) {\r\n          const hasDefault = hasOwn(opt, 'default');\r\n          // default values\r\n          if (hasDefault && value === undefined) {\r\n              const defaultValue = opt.default;\r\n              if (opt.type !== Function && isFunction(defaultValue)) {\r\n                  const { propsDefaults } = instance;\r\n                  if (key in propsDefaults) {\r\n                      value = propsDefaults[key];\r\n                  }\r\n                  else {\r\n                      setCurrentInstance(instance);\r\n                      value = propsDefaults[key] = defaultValue.call(null, props);\r\n                      unsetCurrentInstance();\r\n                  }\r\n              }\r\n              else {\r\n                  value = defaultValue;\r\n              }\r\n          }\r\n          // boolean casting\r\n          if (opt[0 /* shouldCast */]) {\r\n              if (isAbsent && !hasDefault) {\r\n                  value = false;\r\n              }\r\n              else if (opt[1 /* shouldCastTrue */] &&\r\n                  (value === '' || value === hyphenate(key))) {\r\n                  value = true;\r\n              }\r\n          }\r\n      }\r\n      return value;\r\n  }\r\n  function normalizePropsOptions(comp, appContext, asMixin = false) {\r\n      const cache = appContext.propsCache;\r\n      const cached = cache.get(comp);\r\n      if (cached) {\r\n          return cached;\r\n      }\r\n      const raw = comp.props;\r\n      const normalized = {};\r\n      const needCastKeys = [];\r\n      // apply mixin/extends props\r\n      let hasExtends = false;\r\n      if (!isFunction(comp)) {\r\n          const extendProps = (raw) => {\r\n              hasExtends = true;\r\n              const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n              extend(normalized, props);\r\n              if (keys)\r\n                  needCastKeys.push(...keys);\r\n          };\r\n          if (!asMixin && appContext.mixins.length) {\r\n              appContext.mixins.forEach(extendProps);\r\n          }\r\n          if (comp.extends) {\r\n              extendProps(comp.extends);\r\n          }\r\n          if (comp.mixins) {\r\n              comp.mixins.forEach(extendProps);\r\n          }\r\n      }\r\n      if (!raw && !hasExtends) {\r\n          cache.set(comp, EMPTY_ARR);\r\n          return EMPTY_ARR;\r\n      }\r\n      if (isArray(raw)) {\r\n          for (let i = 0; i < raw.length; i++) {\r\n              if (!isString(raw[i])) {\r\n                  warn$1(`props must be strings when using array syntax.`, raw[i]);\r\n              }\r\n              const normalizedKey = camelize(raw[i]);\r\n              if (validatePropName(normalizedKey)) {\r\n                  normalized[normalizedKey] = EMPTY_OBJ;\r\n              }\r\n          }\r\n      }\r\n      else if (raw) {\r\n          if (!isObject(raw)) {\r\n              warn$1(`invalid props options`, raw);\r\n          }\r\n          for (const key in raw) {\r\n              const normalizedKey = camelize(key);\r\n              if (validatePropName(normalizedKey)) {\r\n                  const opt = raw[key];\r\n                  const prop = (normalized[normalizedKey] =\r\n                      isArray(opt) || isFunction(opt) ? { type: opt } : opt);\r\n                  if (prop) {\r\n                      const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                      const stringIndex = getTypeIndex(String, prop.type);\r\n                      prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                      prop[1 /* shouldCastTrue */] =\r\n                          stringIndex < 0 || booleanIndex < stringIndex;\r\n                      // if the prop needs boolean casting or default value\r\n                      if (booleanIndex > -1 || hasOwn(prop, 'default')) {\r\n                          needCastKeys.push(normalizedKey);\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      const res = [normalized, needCastKeys];\r\n      cache.set(comp, res);\r\n      return res;\r\n  }\r\n  function validatePropName(key) {\r\n      if (key[0] !== '$') {\r\n          return true;\r\n      }\r\n      else {\r\n          warn$1(`Invalid prop name: \"${key}\" is a reserved property.`);\r\n      }\r\n      return false;\r\n  }\r\n  // use function string name to check type constructors\r\n  // so that it works across vms / iframes.\r\n  function getType(ctor) {\r\n      const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n      return match ? match[1] : ctor === null ? 'null' : '';\r\n  }\r\n  function isSameType(a, b) {\r\n      return getType(a) === getType(b);\r\n  }\r\n  function getTypeIndex(type, expectedTypes) {\r\n      if (isArray(expectedTypes)) {\r\n          return expectedTypes.findIndex(t => isSameType(t, type));\r\n      }\r\n      else if (isFunction(expectedTypes)) {\r\n          return isSameType(expectedTypes, type) ? 0 : -1;\r\n      }\r\n      return -1;\r\n  }\r\n  /**\r\n   * dev only\r\n   */\r\n  function validateProps(rawProps, props, instance) {\r\n      const resolvedValues = toRaw(props);\r\n      const options = instance.propsOptions[0];\r\n      for (const key in options) {\r\n          let opt = options[key];\r\n          if (opt == null)\r\n              continue;\r\n          validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));\r\n      }\r\n  }\r\n  /**\r\n   * dev only\r\n   */\r\n  function validateProp(name, value, prop, isAbsent) {\r\n      const { type, required, validator } = prop;\r\n      // required!\r\n      if (required && isAbsent) {\r\n          warn$1('Missing required prop: \"' + name + '\"');\r\n          return;\r\n      }\r\n      // missing but optional\r\n      if (value == null && !prop.required) {\r\n          return;\r\n      }\r\n      // type check\r\n      if (type != null && type !== true) {\r\n          let isValid = false;\r\n          const types = isArray(type) ? type : [type];\r\n          const expectedTypes = [];\r\n          // value is valid as long as one of the specified types match\r\n          for (let i = 0; i < types.length && !isValid; i++) {\r\n              const { valid, expectedType } = assertType(value, types[i]);\r\n              expectedTypes.push(expectedType || '');\r\n              isValid = valid;\r\n          }\r\n          if (!isValid) {\r\n              warn$1(getInvalidTypeMessage(name, value, expectedTypes));\r\n              return;\r\n          }\r\n      }\r\n      // custom validator\r\n      if (validator && !validator(value)) {\r\n          warn$1('Invalid prop: custom validator check failed for prop \"' + name + '\".');\r\n      }\r\n  }\r\n  const isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol,BigInt');\r\n  /**\r\n   * dev only\r\n   */\r\n  function assertType(value, type) {\r\n      let valid;\r\n      const expectedType = getType(type);\r\n      if (isSimpleType(expectedType)) {\r\n          const t = typeof value;\r\n          valid = t === expectedType.toLowerCase();\r\n          // for primitive wrapper objects\r\n          if (!valid && t === 'object') {\r\n              valid = value instanceof type;\r\n          }\r\n      }\r\n      else if (expectedType === 'Object') {\r\n          valid = isObject(value);\r\n      }\r\n      else if (expectedType === 'Array') {\r\n          valid = isArray(value);\r\n      }\r\n      else if (expectedType === 'null') {\r\n          valid = value === null;\r\n      }\r\n      else {\r\n          valid = value instanceof type;\r\n      }\r\n      return {\r\n          valid,\r\n          expectedType\r\n      };\r\n  }\r\n  /**\r\n   * dev only\r\n   */\r\n  function getInvalidTypeMessage(name, value, expectedTypes) {\r\n      let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n          ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;\r\n      const expectedType = expectedTypes[0];\r\n      const receivedType = toRawType(value);\r\n      const expectedValue = styleValue(value, expectedType);\r\n      const receivedValue = styleValue(value, receivedType);\r\n      // check if we need to specify expected value\r\n      if (expectedTypes.length === 1 &&\r\n          isExplicable(expectedType) &&\r\n          !isBoolean(expectedType, receivedType)) {\r\n          message += ` with value ${expectedValue}`;\r\n      }\r\n      message += `, got ${receivedType} `;\r\n      // check if we need to specify received value\r\n      if (isExplicable(receivedType)) {\r\n          message += `with value ${receivedValue}.`;\r\n      }\r\n      return message;\r\n  }\r\n  /**\r\n   * dev only\r\n   */\r\n  function styleValue(value, type) {\r\n      if (type === 'String') {\r\n          return `\"${value}\"`;\r\n      }\r\n      else if (type === 'Number') {\r\n          return `${Number(value)}`;\r\n      }\r\n      else {\r\n          return `${value}`;\r\n      }\r\n  }\r\n  /**\r\n   * dev only\r\n   */\r\n  function isExplicable(type) {\r\n      const explicitTypes = ['string', 'number', 'boolean'];\r\n      return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n  }\r\n  /**\r\n   * dev only\r\n   */\r\n  function isBoolean(...args) {\r\n      return args.some(elem => elem.toLowerCase() === 'boolean');\r\n  }\n\n  const isInternalKey = (key) => key[0] === '_' || key === '$stable';\r\n  const normalizeSlotValue = (value) => isArray(value)\r\n      ? value.map(normalizeVNode)\r\n      : [normalizeVNode(value)];\r\n  const normalizeSlot = (key, rawSlot, ctx) => {\r\n      const normalized = withCtx((...args) => {\r\n          if (currentInstance) {\r\n              warn$1(`Slot \"${key}\" invoked outside of the render function: ` +\r\n                  `this will not track dependencies used in the slot. ` +\r\n                  `Invoke the slot function inside the render function instead.`);\r\n          }\r\n          return normalizeSlotValue(rawSlot(...args));\r\n      }, ctx);\r\n      normalized._c = false;\r\n      return normalized;\r\n  };\r\n  const normalizeObjectSlots = (rawSlots, slots, instance) => {\r\n      const ctx = rawSlots._ctx;\r\n      for (const key in rawSlots) {\r\n          if (isInternalKey(key))\r\n              continue;\r\n          const value = rawSlots[key];\r\n          if (isFunction(value)) {\r\n              slots[key] = normalizeSlot(key, value, ctx);\r\n          }\r\n          else if (value != null) {\r\n              {\r\n                  warn$1(`Non-function value encountered for slot \"${key}\". ` +\r\n                      `Prefer function slots for better performance.`);\r\n              }\r\n              const normalized = normalizeSlotValue(value);\r\n              slots[key] = () => normalized;\r\n          }\r\n      }\r\n  };\r\n  const normalizeVNodeSlots = (instance, children) => {\r\n      if (!isKeepAlive(instance.vnode) &&\r\n          !(false )) {\r\n          warn$1(`Non-function value encountered for default slot. ` +\r\n              `Prefer function slots for better performance.`);\r\n      }\r\n      const normalized = normalizeSlotValue(children);\r\n      instance.slots.default = () => normalized;\r\n  };\r\n  const initSlots = (instance, children) => {\r\n      if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n          const type = children._;\r\n          if (type) {\r\n              // users can get the shallow readonly version of the slots object through `this.$slots`,\r\n              // we should avoid the proxy object polluting the slots of the internal instance\r\n              instance.slots = toRaw(children);\r\n              // make compiler marker non-enumerable\r\n              def(children, '_', type);\r\n          }\r\n          else {\r\n              normalizeObjectSlots(children, (instance.slots = {}));\r\n          }\r\n      }\r\n      else {\r\n          instance.slots = {};\r\n          if (children) {\r\n              normalizeVNodeSlots(instance, children);\r\n          }\r\n      }\r\n      def(instance.slots, InternalObjectKey, 1);\r\n  };\r\n  const updateSlots = (instance, children, optimized) => {\r\n      const { vnode, slots } = instance;\r\n      let needDeletionCheck = true;\r\n      let deletionComparisonTarget = EMPTY_OBJ;\r\n      if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n          const type = children._;\r\n          if (type) {\r\n              // compiled slots.\r\n              if (isHmrUpdating) {\r\n                  // Parent was HMR updated so slot content may have changed.\r\n                  // force update slots and mark instance for hmr as well\r\n                  extend(slots, children);\r\n              }\r\n              else if (optimized && type === 1 /* STABLE */) {\r\n                  // compiled AND stable.\r\n                  // no need to update, and skip stale slots removal.\r\n                  needDeletionCheck = false;\r\n              }\r\n              else {\r\n                  // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                  // normalization.\r\n                  extend(slots, children);\r\n                  // #2893\r\n                  // when rendering the optimized slots by manually written render function,\r\n                  // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\r\n                  // i.e. let the `renderSlot` create the bailed Fragment\r\n                  if (!optimized && type === 1 /* STABLE */) {\r\n                      delete slots._;\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              needDeletionCheck = !children.$stable;\r\n              normalizeObjectSlots(children, slots);\r\n          }\r\n          deletionComparisonTarget = children;\r\n      }\r\n      else if (children) {\r\n          // non slot object children (direct value) passed to a component\r\n          normalizeVNodeSlots(instance, children);\r\n          deletionComparisonTarget = { default: 1 };\r\n      }\r\n      // delete stale slots\r\n      if (needDeletionCheck) {\r\n          for (const key in slots) {\r\n              if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                  delete slots[key];\r\n              }\r\n          }\r\n      }\r\n  };\n\n  /**\r\n  Runtime helper for applying directives to a vnode. Example usage:\r\n\n  const comp = resolveComponent('comp')\r\n  const foo = resolveDirective('foo')\r\n  const bar = resolveDirective('bar')\r\n\n  return withDirectives(h(comp), [\r\n    [foo, this.x],\r\n    [bar, this.y]\r\n  ])\r\n  */\r\n  function validateDirectiveName(name) {\r\n      if (isBuiltInDirective(name)) {\r\n          warn$1('Do not use built-in directive ids as custom directive id: ' + name);\r\n      }\r\n  }\r\n  /**\r\n   * Adds directives to a VNode.\r\n   */\r\n  function withDirectives(vnode, directives) {\r\n      const internalInstance = currentRenderingInstance;\r\n      if (internalInstance === null) {\r\n          warn$1(`withDirectives can only be used inside render functions.`);\r\n          return vnode;\r\n      }\r\n      const instance = internalInstance.proxy;\r\n      const bindings = vnode.dirs || (vnode.dirs = []);\r\n      for (let i = 0; i < directives.length; i++) {\r\n          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\r\n          if (isFunction(dir)) {\r\n              dir = {\r\n                  mounted: dir,\r\n                  updated: dir\r\n              };\r\n          }\r\n          if (dir.deep) {\r\n              traverse(value);\r\n          }\r\n          bindings.push({\r\n              dir,\r\n              instance,\r\n              value,\r\n              oldValue: void 0,\r\n              arg,\r\n              modifiers\r\n          });\r\n      }\r\n      return vnode;\r\n  }\r\n  function invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n      const bindings = vnode.dirs;\r\n      const oldBindings = prevVNode && prevVNode.dirs;\r\n      for (let i = 0; i < bindings.length; i++) {\r\n          const binding = bindings[i];\r\n          if (oldBindings) {\r\n              binding.oldValue = oldBindings[i].value;\r\n          }\r\n          let hook = binding.dir[name];\r\n          if (hook) {\r\n              // disable tracking inside all lifecycle hooks\r\n              // since they can potentially be called inside effects.\r\n              pauseTracking();\r\n              callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                  vnode.el,\r\n                  binding,\r\n                  vnode,\r\n                  prevVNode\r\n              ]);\r\n              resetTracking();\r\n          }\r\n      }\r\n  }\n\n  function createAppContext() {\r\n      return {\r\n          app: null,\r\n          config: {\r\n              isNativeTag: NO,\r\n              performance: false,\r\n              globalProperties: {},\r\n              optionMergeStrategies: {},\r\n              errorHandler: undefined,\r\n              warnHandler: undefined,\r\n              compilerOptions: {}\r\n          },\r\n          mixins: [],\r\n          components: {},\r\n          directives: {},\r\n          provides: Object.create(null),\r\n          optionsCache: new WeakMap(),\r\n          propsCache: new WeakMap(),\r\n          emitsCache: new WeakMap()\r\n      };\r\n  }\r\n  let uid = 0;\r\n  function createAppAPI(render, hydrate) {\r\n      return function createApp(rootComponent, rootProps = null) {\r\n          if (rootProps != null && !isObject(rootProps)) {\r\n              warn$1(`root props passed to app.mount() must be an object.`);\r\n              rootProps = null;\r\n          }\r\n          const context = createAppContext();\r\n          const installedPlugins = new Set();\r\n          let isMounted = false;\r\n          const app = (context.app = {\r\n              _uid: uid++,\r\n              _component: rootComponent,\r\n              _props: rootProps,\r\n              _container: null,\r\n              _context: context,\r\n              _instance: null,\r\n              version,\r\n              get config() {\r\n                  return context.config;\r\n              },\r\n              set config(v) {\r\n                  {\r\n                      warn$1(`app.config cannot be replaced. Modify individual options instead.`);\r\n                  }\r\n              },\r\n              use(plugin, ...options) {\r\n                  if (installedPlugins.has(plugin)) {\r\n                      warn$1(`Plugin has already been applied to target app.`);\r\n                  }\r\n                  else if (plugin && isFunction(plugin.install)) {\r\n                      installedPlugins.add(plugin);\r\n                      plugin.install(app, ...options);\r\n                  }\r\n                  else if (isFunction(plugin)) {\r\n                      installedPlugins.add(plugin);\r\n                      plugin(app, ...options);\r\n                  }\r\n                  else {\r\n                      warn$1(`A plugin must either be a function or an object with an \"install\" ` +\r\n                          `function.`);\r\n                  }\r\n                  return app;\r\n              },\r\n              mixin(mixin) {\r\n                  {\r\n                      if (!context.mixins.includes(mixin)) {\r\n                          context.mixins.push(mixin);\r\n                      }\r\n                      else {\r\n                          warn$1('Mixin has already been applied to target app' +\r\n                              (mixin.name ? `: ${mixin.name}` : ''));\r\n                      }\r\n                  }\r\n                  return app;\r\n              },\r\n              component(name, component) {\r\n                  {\r\n                      validateComponentName(name, context.config);\r\n                  }\r\n                  if (!component) {\r\n                      return context.components[name];\r\n                  }\r\n                  if (context.components[name]) {\r\n                      warn$1(`Component \"${name}\" has already been registered in target app.`);\r\n                  }\r\n                  context.components[name] = component;\r\n                  return app;\r\n              },\r\n              directive(name, directive) {\r\n                  {\r\n                      validateDirectiveName(name);\r\n                  }\r\n                  if (!directive) {\r\n                      return context.directives[name];\r\n                  }\r\n                  if (context.directives[name]) {\r\n                      warn$1(`Directive \"${name}\" has already been registered in target app.`);\r\n                  }\r\n                  context.directives[name] = directive;\r\n                  return app;\r\n              },\r\n              mount(rootContainer, isHydrate, isSVG) {\r\n                  if (!isMounted) {\r\n                      const vnode = createVNode(rootComponent, rootProps);\r\n                      // store app context on the root VNode.\r\n                      // this will be set on the root instance on initial mount.\r\n                      vnode.appContext = context;\r\n                      // HMR root reload\r\n                      {\r\n                          context.reload = () => {\r\n                              render(cloneVNode(vnode), rootContainer, isSVG);\r\n                          };\r\n                      }\r\n                      if (isHydrate && hydrate) {\r\n                          hydrate(vnode, rootContainer);\r\n                      }\r\n                      else {\r\n                          render(vnode, rootContainer, isSVG);\r\n                      }\r\n                      isMounted = true;\r\n                      app._container = rootContainer;\r\n                      rootContainer.__vue_app__ = app;\r\n                      {\r\n                          app._instance = vnode.component;\r\n                          devtoolsInitApp(app, version);\r\n                      }\r\n                      return getExposeProxy(vnode.component) || vnode.component.proxy;\r\n                  }\r\n                  else {\r\n                      warn$1(`App has already been mounted.\\n` +\r\n                          `If you want to remount the same app, move your app creation logic ` +\r\n                          `into a factory function and create fresh app instances for each ` +\r\n                          `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\r\n                  }\r\n              },\r\n              unmount() {\r\n                  if (isMounted) {\r\n                      render(null, app._container);\r\n                      {\r\n                          app._instance = null;\r\n                          devtoolsUnmountApp(app);\r\n                      }\r\n                      delete app._container.__vue_app__;\r\n                  }\r\n                  else {\r\n                      warn$1(`Cannot unmount an app that is not mounted.`);\r\n                  }\r\n              },\r\n              provide(key, value) {\r\n                  if (key in context.provides) {\r\n                      warn$1(`App already provides property with key \"${String(key)}\". ` +\r\n                          `It will be overwritten with the new value.`);\r\n                  }\r\n                  // TypeScript doesn't allow symbols as index type\r\n                  // https://github.com/Microsoft/TypeScript/issues/24587\r\n                  context.provides[key] = value;\r\n                  return app;\r\n              }\r\n          });\r\n          return app;\r\n      };\r\n  }\n\n  /**\r\n   * Function for handling a template ref\r\n   */\r\n  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\r\n      if (isArray(rawRef)) {\r\n          rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\r\n          return;\r\n      }\r\n      if (isAsyncWrapper(vnode) && !isUnmount) {\r\n          // when mounting async components, nothing needs to be done,\r\n          // because the template ref is forwarded to inner component\r\n          return;\r\n      }\r\n      const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */\r\n          ? getExposeProxy(vnode.component) || vnode.component.proxy\r\n          : vnode.el;\r\n      const value = isUnmount ? null : refValue;\r\n      const { i: owner, r: ref } = rawRef;\r\n      if (!owner) {\r\n          warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\r\n              `A vnode with ref must be created inside the render function.`);\r\n          return;\r\n      }\r\n      const oldRef = oldRawRef && oldRawRef.r;\r\n      const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\r\n      const setupState = owner.setupState;\r\n      // dynamic ref changed. unset old ref\r\n      if (oldRef != null && oldRef !== ref) {\r\n          if (isString(oldRef)) {\r\n              refs[oldRef] = null;\r\n              if (hasOwn(setupState, oldRef)) {\r\n                  setupState[oldRef] = null;\r\n              }\r\n          }\r\n          else if (isRef(oldRef)) {\r\n              oldRef.value = null;\r\n          }\r\n      }\r\n      if (isFunction(ref)) {\r\n          callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n      }\r\n      else {\r\n          const _isString = isString(ref);\r\n          const _isRef = isRef(ref);\r\n          if (_isString || _isRef) {\r\n              const doSet = () => {\r\n                  if (rawRef.f) {\r\n                      const existing = _isString ? refs[ref] : ref.value;\r\n                      if (isUnmount) {\r\n                          isArray(existing) && remove(existing, refValue);\r\n                      }\r\n                      else {\r\n                          if (!isArray(existing)) {\r\n                              if (_isString) {\r\n                                  refs[ref] = [refValue];\r\n                              }\r\n                              else {\r\n                                  ref.value = [refValue];\r\n                                  if (rawRef.k)\r\n                                      refs[rawRef.k] = ref.value;\r\n                              }\r\n                          }\r\n                          else if (!existing.includes(refValue)) {\r\n                              existing.push(refValue);\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (_isString) {\r\n                      refs[ref] = value;\r\n                      if (hasOwn(setupState, ref)) {\r\n                          setupState[ref] = value;\r\n                      }\r\n                  }\r\n                  else if (isRef(ref)) {\r\n                      ref.value = value;\r\n                      if (rawRef.k)\r\n                          refs[rawRef.k] = value;\r\n                  }\r\n                  else {\r\n                      warn$1('Invalid template ref type:', ref, `(${typeof ref})`);\r\n                  }\r\n              };\r\n              if (value) {\r\n                  doSet.id = -1;\r\n                  queuePostRenderEffect(doSet, parentSuspense);\r\n              }\r\n              else {\r\n                  doSet();\r\n              }\r\n          }\r\n          else {\r\n              warn$1('Invalid template ref type:', ref, `(${typeof ref})`);\r\n          }\r\n      }\r\n  }\n\n  let hasMismatch = false;\r\n  const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\r\n  const isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n  // Note: hydration is DOM-specific\r\n  // But we have to place it in core due to tight coupling with core - splitting\r\n  // it out creates a ton of unnecessary complexity.\r\n  // Hydration also depends on some renderer internal logic which needs to be\r\n  // passed in via arguments.\r\n  function createHydrationFunctions(rendererInternals) {\r\n      const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n      const hydrate = (vnode, container) => {\r\n          if (!container.hasChildNodes()) {\r\n              warn$1(`Attempting to hydrate existing markup but container is empty. ` +\r\n                      `Performing full mount instead.`);\r\n              patch(null, vnode, container);\r\n              flushPostFlushCbs();\r\n              return;\r\n          }\r\n          hasMismatch = false;\r\n          hydrateNode(container.firstChild, vnode, null, null, null);\r\n          flushPostFlushCbs();\r\n          if (hasMismatch && !false) {\r\n              // this error should show up in production\r\n              console.error(`Hydration completed but contains mismatches.`);\r\n          }\r\n      };\r\n      const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\r\n          const isFragmentStart = isComment(node) && node.data === '[';\r\n          const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\r\n          const { type, ref, shapeFlag } = vnode;\r\n          const domType = node.nodeType;\r\n          vnode.el = node;\r\n          let nextNode = null;\r\n          switch (type) {\r\n              case Text:\r\n                  if (domType !== 3 /* TEXT */) {\r\n                      nextNode = onMismatch();\r\n                  }\r\n                  else {\r\n                      if (node.data !== vnode.children) {\r\n                          hasMismatch = true;\r\n                          warn$1(`Hydration text mismatch:` +\r\n                                  `\\n- Client: ${JSON.stringify(node.data)}` +\r\n                                  `\\n- Server: ${JSON.stringify(vnode.children)}`);\r\n                          node.data = vnode.children;\r\n                      }\r\n                      nextNode = nextSibling(node);\r\n                  }\r\n                  break;\r\n              case Comment:\r\n                  if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                      nextNode = onMismatch();\r\n                  }\r\n                  else {\r\n                      nextNode = nextSibling(node);\r\n                  }\r\n                  break;\r\n              case Static:\r\n                  if (domType !== 1 /* ELEMENT */) {\r\n                      nextNode = onMismatch();\r\n                  }\r\n                  else {\r\n                      // determine anchor, adopt content\r\n                      nextNode = node;\r\n                      // if the static vnode has its content stripped during build,\r\n                      // adopt it from the server-rendered HTML.\r\n                      const needToAdoptContent = !vnode.children.length;\r\n                      for (let i = 0; i < vnode.staticCount; i++) {\r\n                          if (needToAdoptContent)\r\n                              vnode.children += nextNode.outerHTML;\r\n                          if (i === vnode.staticCount - 1) {\r\n                              vnode.anchor = nextNode;\r\n                          }\r\n                          nextNode = nextSibling(nextNode);\r\n                      }\r\n                      return nextNode;\r\n                  }\r\n                  break;\r\n              case Fragment:\r\n                  if (!isFragmentStart) {\r\n                      nextNode = onMismatch();\r\n                  }\r\n                  else {\r\n                      nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                  }\r\n                  break;\r\n              default:\r\n                  if (shapeFlag & 1 /* ELEMENT */) {\r\n                      if (domType !== 1 /* ELEMENT */ ||\r\n                          vnode.type.toLowerCase() !==\r\n                              node.tagName.toLowerCase()) {\r\n                          nextNode = onMismatch();\r\n                      }\r\n                      else {\r\n                          nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                      }\r\n                  }\r\n                  else if (shapeFlag & 6 /* COMPONENT */) {\r\n                      // when setting up the render effect, if the initial vnode already\r\n                      // has .el set, the component will perform hydration instead of mount\r\n                      // on its sub-tree.\r\n                      vnode.slotScopeIds = slotScopeIds;\r\n                      const container = parentNode(node);\r\n                      mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                      // component may be async, so in the case of fragments we cannot rely\r\n                      // on component's rendered output to determine the end of the fragment\r\n                      // instead, we do a lookahead to find the end anchor node.\r\n                      nextNode = isFragmentStart\r\n                          ? locateClosingAsyncAnchor(node)\r\n                          : nextSibling(node);\r\n                      // #3787\r\n                      // if component is async, it may get moved / unmounted before its\r\n                      // inner component is loaded, so we need to give it a placeholder\r\n                      // vnode that matches its adopted DOM.\r\n                      if (isAsyncWrapper(vnode)) {\r\n                          let subTree;\r\n                          if (isFragmentStart) {\r\n                              subTree = createVNode(Fragment);\r\n                              subTree.anchor = nextNode\r\n                                  ? nextNode.previousSibling\r\n                                  : container.lastChild;\r\n                          }\r\n                          else {\r\n                              subTree =\r\n                                  node.nodeType === 3 ? createTextVNode('') : createVNode('div');\r\n                          }\r\n                          subTree.el = node;\r\n                          vnode.component.subTree = subTree;\r\n                      }\r\n                  }\r\n                  else if (shapeFlag & 64 /* TELEPORT */) {\r\n                      if (domType !== 8 /* COMMENT */) {\r\n                          nextNode = onMismatch();\r\n                      }\r\n                      else {\r\n                          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\r\n                      }\r\n                  }\r\n                  else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                      nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\r\n                  }\r\n                  else {\r\n                      warn$1('Invalid HostVNode type:', type, `(${typeof type})`);\r\n                  }\r\n          }\r\n          if (ref != null) {\r\n              setRef(ref, null, parentSuspense, vnode);\r\n          }\r\n          return nextNode;\r\n      };\r\n      const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n          optimized = optimized || !!vnode.dynamicChildren;\r\n          const { type, props, patchFlag, shapeFlag, dirs } = vnode;\r\n          // #4006 for form elements with non-string v-model value bindings\r\n          // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\r\n          const forcePatchValue = (type === 'input' && dirs) || type === 'option';\r\n          // skip props & children if this is hoisted static nodes\r\n          // #5405 in dev, always hydrate children for HMR\r\n          {\r\n              if (dirs) {\r\n                  invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n              }\r\n              // props\r\n              if (props) {\r\n                  if (forcePatchValue ||\r\n                      !optimized ||\r\n                      patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {\r\n                      for (const key in props) {\r\n                          if ((forcePatchValue && key.endsWith('value')) ||\r\n                              (isOn(key) && !isReservedProp(key))) {\r\n                              patchProp(el, key, null, props[key], false, undefined, parentComponent);\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (props.onClick) {\r\n                      // Fast path for click listeners (which is most often) to avoid\r\n                      // iterating through props.\r\n                      patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);\r\n                  }\r\n              }\r\n              // vnode / directive hooks\r\n              let vnodeHooks;\r\n              if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                  invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n              }\r\n              if (dirs) {\r\n                  invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n              }\r\n              if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                  queueEffectWithSuspense(() => {\r\n                      vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                      dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n                  }, parentSuspense);\r\n              }\r\n              // children\r\n              if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                  // skip if element has innerHTML / textContent\r\n                  !(props && (props.innerHTML || props.textContent))) {\r\n                  let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                  let hasWarned = false;\r\n                  while (next) {\r\n                      hasMismatch = true;\r\n                      if (!hasWarned) {\r\n                          warn$1(`Hydration children mismatch in <${vnode.type}>: ` +\r\n                              `server rendered element contains more child nodes than client vdom.`);\r\n                          hasWarned = true;\r\n                      }\r\n                      // The SSRed DOM contains more nodes than it should. Remove them.\r\n                      const cur = next;\r\n                      next = next.nextSibling;\r\n                      remove(cur);\r\n                  }\r\n              }\r\n              else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                  if (el.textContent !== vnode.children) {\r\n                      hasMismatch = true;\r\n                      warn$1(`Hydration text content mismatch in <${vnode.type}>:\\n` +\r\n                              `- Client: ${el.textContent}\\n` +\r\n                              `- Server: ${vnode.children}`);\r\n                      el.textContent = vnode.children;\r\n                  }\r\n              }\r\n          }\r\n          return el.nextSibling;\r\n      };\r\n      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n          optimized = optimized || !!parentVNode.dynamicChildren;\r\n          const children = parentVNode.children;\r\n          const l = children.length;\r\n          let hasWarned = false;\r\n          for (let i = 0; i < l; i++) {\r\n              const vnode = optimized\r\n                  ? children[i]\r\n                  : (children[i] = normalizeVNode(children[i]));\r\n              if (node) {\r\n                  node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n              }\r\n              else if (vnode.type === Text && !vnode.children) {\r\n                  continue;\r\n              }\r\n              else {\r\n                  hasMismatch = true;\r\n                  if (!hasWarned) {\r\n                      warn$1(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\r\n                          `server rendered element contains fewer child nodes than client vdom.`);\r\n                      hasWarned = true;\r\n                  }\r\n                  // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\r\n                  patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n              }\r\n          }\r\n          return node;\r\n      };\r\n      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n          const { slotScopeIds: fragmentSlotScopeIds } = vnode;\r\n          if (fragmentSlotScopeIds) {\r\n              slotScopeIds = slotScopeIds\r\n                  ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                  : fragmentSlotScopeIds;\r\n          }\r\n          const container = parentNode(node);\r\n          const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n          if (next && isComment(next) && next.data === ']') {\r\n              return nextSibling((vnode.anchor = next));\r\n          }\r\n          else {\r\n              // fragment didn't hydrate successfully, since we didn't get a end anchor\r\n              // back. This should have led to node/children mismatch warnings.\r\n              hasMismatch = true;\r\n              // since the anchor is missing, we need to create one and insert it\r\n              insert((vnode.anchor = createComment(`]`)), container, next);\r\n              return next;\r\n          }\r\n      };\r\n      const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\r\n          hasMismatch = true;\r\n          warn$1(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */\r\n                  ? `(text)`\r\n                  : isComment(node) && node.data === '['\r\n                      ? `(start of fragment)`\r\n                      : ``);\r\n          vnode.el = null;\r\n          if (isFragment) {\r\n              // remove excessive fragment nodes\r\n              const end = locateClosingAsyncAnchor(node);\r\n              while (true) {\r\n                  const next = nextSibling(node);\r\n                  if (next && next !== end) {\r\n                      remove(next);\r\n                  }\r\n                  else {\r\n                      break;\r\n                  }\r\n              }\r\n          }\r\n          const next = nextSibling(node);\r\n          const container = parentNode(node);\r\n          remove(node);\r\n          patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n          return next;\r\n      };\r\n      const locateClosingAsyncAnchor = (node) => {\r\n          let match = 0;\r\n          while (node) {\r\n              node = nextSibling(node);\r\n              if (node && isComment(node)) {\r\n                  if (node.data === '[')\r\n                      match++;\r\n                  if (node.data === ']') {\r\n                      if (match === 0) {\r\n                          return nextSibling(node);\r\n                      }\r\n                      else {\r\n                          match--;\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n          return node;\r\n      };\r\n      return [hydrate, hydrateNode];\r\n  }\n\n  /* eslint-disable no-restricted-globals */\r\n  let supported;\r\n  let perf;\r\n  function startMeasure(instance, type) {\r\n      if (instance.appContext.config.performance && isSupported()) {\r\n          perf.mark(`vue-${type}-${instance.uid}`);\r\n      }\r\n      {\r\n          devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());\r\n      }\r\n  }\r\n  function endMeasure(instance, type) {\r\n      if (instance.appContext.config.performance && isSupported()) {\r\n          const startTag = `vue-${type}-${instance.uid}`;\r\n          const endTag = startTag + `:end`;\r\n          perf.mark(endTag);\r\n          perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\r\n          perf.clearMarks(startTag);\r\n          perf.clearMarks(endTag);\r\n      }\r\n      {\r\n          devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());\r\n      }\r\n  }\r\n  function isSupported() {\r\n      if (supported !== undefined) {\r\n          return supported;\r\n      }\r\n      if (typeof window !== 'undefined' && window.performance) {\r\n          supported = true;\r\n          perf = window.performance;\r\n      }\r\n      else {\r\n          supported = false;\r\n      }\r\n      return supported;\r\n  }\n\n  const queuePostRenderEffect = queueEffectWithSuspense\r\n      ;\r\n  /**\r\n   * The createRenderer function accepts two generic arguments:\r\n   * HostNode and HostElement, corresponding to Node and Element types in the\r\n   * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n   * `Node` interface and HostElement would be the DOM `Element` interface.\r\n   *\r\n   * Custom renderers can pass in the platform specific types like this:\r\n   *\r\n   * ``` js\r\n   * const { render, createApp } = createRenderer<Node, Element>({\r\n   *   patchProp,\r\n   *   ...nodeOps\r\n   * })\r\n   * ```\r\n   */\r\n  function createRenderer(options) {\r\n      return baseCreateRenderer(options);\r\n  }\r\n  // Separate API for creating hydration-enabled renderer.\r\n  // Hydration logic is only used when calling this function, making it\r\n  // tree-shakable.\r\n  function createHydrationRenderer(options) {\r\n      return baseCreateRenderer(options, createHydrationFunctions);\r\n  }\r\n  // implementation\r\n  function baseCreateRenderer(options, createHydrationFns) {\r\n      const target = getGlobalThis();\r\n      target.__VUE__ = true;\r\n      {\r\n          setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\r\n      }\r\n      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n      // Note: functions inside this closure should use `const xxx = () => {}`\r\n      // style in order to prevent being inlined by minifiers.\r\n      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {\r\n          if (n1 === n2) {\r\n              return;\r\n          }\r\n          // patching & not same type, unmount old tree\r\n          if (n1 && !isSameVNodeType(n1, n2)) {\r\n              anchor = getNextHostNode(n1);\r\n              unmount(n1, parentComponent, parentSuspense, true);\r\n              n1 = null;\r\n          }\r\n          if (n2.patchFlag === -2 /* BAIL */) {\r\n              optimized = false;\r\n              n2.dynamicChildren = null;\r\n          }\r\n          const { type, ref, shapeFlag } = n2;\r\n          switch (type) {\r\n              case Text:\r\n                  processText(n1, n2, container, anchor);\r\n                  break;\r\n              case Comment:\r\n                  processCommentNode(n1, n2, container, anchor);\r\n                  break;\r\n              case Static:\r\n                  if (n1 == null) {\r\n                      mountStaticNode(n2, container, anchor, isSVG);\r\n                  }\r\n                  else {\r\n                      patchStaticNode(n1, n2, container, isSVG);\r\n                  }\r\n                  break;\r\n              case Fragment:\r\n                  processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  break;\r\n              default:\r\n                  if (shapeFlag & 1 /* ELEMENT */) {\r\n                      processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  }\r\n                  else if (shapeFlag & 6 /* COMPONENT */) {\r\n                      processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  }\r\n                  else if (shapeFlag & 64 /* TELEPORT */) {\r\n                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                  }\r\n                  else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                  }\r\n                  else {\r\n                      warn$1('Invalid VNode type:', type, `(${typeof type})`);\r\n                  }\r\n          }\r\n          // set ref\r\n          if (ref != null && parentComponent) {\r\n              setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\r\n          }\r\n      };\r\n      const processText = (n1, n2, container, anchor) => {\r\n          if (n1 == null) {\r\n              hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n          }\r\n          else {\r\n              const el = (n2.el = n1.el);\r\n              if (n2.children !== n1.children) {\r\n                  hostSetText(el, n2.children);\r\n              }\r\n          }\r\n      };\r\n      const processCommentNode = (n1, n2, container, anchor) => {\r\n          if (n1 == null) {\r\n              hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n          }\r\n          else {\r\n              // there's no support for dynamic comments\r\n              n2.el = n1.el;\r\n          }\r\n      };\r\n      const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n          [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\r\n      };\r\n      /**\r\n       * Dev / HMR only\r\n       */\r\n      const patchStaticNode = (n1, n2, container, isSVG) => {\r\n          // static nodes are only patched during dev for HMR\r\n          if (n2.children !== n1.children) {\r\n              const anchor = hostNextSibling(n1.anchor);\r\n              // remove existing\r\n              removeStaticNode(n1);\r\n              [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n          }\r\n          else {\r\n              n2.el = n1.el;\r\n              n2.anchor = n1.anchor;\r\n          }\r\n      };\r\n      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n          let next;\r\n          while (el && el !== anchor) {\r\n              next = hostNextSibling(el);\r\n              hostInsert(el, container, nextSibling);\r\n              el = next;\r\n          }\r\n          hostInsert(anchor, container, nextSibling);\r\n      };\r\n      const removeStaticNode = ({ el, anchor }) => {\r\n          let next;\r\n          while (el && el !== anchor) {\r\n              next = hostNextSibling(el);\r\n              hostRemove(el);\r\n              el = next;\r\n          }\r\n          hostRemove(anchor);\r\n      };\r\n      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          isSVG = isSVG || n2.type === 'svg';\r\n          if (n1 == null) {\r\n              mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n          }\r\n          else {\r\n              patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n          }\r\n      };\r\n      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          let el;\r\n          let vnodeHook;\r\n          const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;\r\n          {\r\n              el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\r\n              // mount children first, since some props may rely on child content\r\n              // being already rendered, e.g. `<select value>`\r\n              if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                  hostSetElementText(el, vnode.children);\r\n              }\r\n              else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                  mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\r\n              }\r\n              if (dirs) {\r\n                  invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n              }\r\n              // props\r\n              if (props) {\r\n                  for (const key in props) {\r\n                      if (key !== 'value' && !isReservedProp(key)) {\r\n                          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                      }\r\n                  }\r\n                  /**\r\n                   * Special case for setting value on DOM elements:\r\n                   * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\r\n                   * - it needs to be forced (#1471)\r\n                   * #2353 proposes adding another renderer option to configure this, but\r\n                   * the properties affects are so finite it is worth special casing it\r\n                   * here to reduce the complexity. (Special casing it also should not\r\n                   * affect non-DOM renderers)\r\n                   */\r\n                  if ('value' in props) {\r\n                      hostPatchProp(el, 'value', null, props.value);\r\n                  }\r\n                  if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                      invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                  }\r\n              }\r\n              // scopeId\r\n              setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\r\n          }\r\n          {\r\n              Object.defineProperty(el, '__vnode', {\r\n                  value: vnode,\r\n                  enumerable: false\r\n              });\r\n              Object.defineProperty(el, '__vueParentComponent', {\r\n                  value: parentComponent,\r\n                  enumerable: false\r\n              });\r\n          }\r\n          if (dirs) {\r\n              invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n          }\r\n          // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n          // #1689 For inside suspense + suspense resolved case, just call it\r\n          const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n              transition &&\r\n              !transition.persisted;\r\n          if (needCallTransitionHooks) {\r\n              transition.beforeEnter(el);\r\n          }\r\n          hostInsert(el, container, anchor);\r\n          if ((vnodeHook = props && props.onVnodeMounted) ||\r\n              needCallTransitionHooks ||\r\n              dirs) {\r\n              queuePostRenderEffect(() => {\r\n                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                  needCallTransitionHooks && transition.enter(el);\r\n                  dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n              }, parentSuspense);\r\n          }\r\n      };\r\n      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\r\n          if (scopeId) {\r\n              hostSetScopeId(el, scopeId);\r\n          }\r\n          if (slotScopeIds) {\r\n              for (let i = 0; i < slotScopeIds.length; i++) {\r\n                  hostSetScopeId(el, slotScopeIds[i]);\r\n              }\r\n          }\r\n          if (parentComponent) {\r\n              let subTree = parentComponent.subTree;\r\n              if (subTree.patchFlag > 0 &&\r\n                  subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {\r\n                  subTree =\r\n                      filterSingleRoot(subTree.children) || subTree;\r\n              }\r\n              if (vnode === subTree) {\r\n                  const parentVNode = parentComponent.vnode;\r\n                  setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\r\n              }\r\n          }\r\n      };\r\n      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\r\n          for (let i = start; i < children.length; i++) {\r\n              const child = (children[i] = optimized\r\n                  ? cloneIfMounted(children[i])\r\n                  : normalizeVNode(children[i]));\r\n              patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n          }\r\n      };\r\n      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          const el = (n2.el = n1.el);\r\n          let { patchFlag, dynamicChildren, dirs } = n2;\r\n          // #1426 take the old vnode's patch flag into account since user may clone a\r\n          // compiler-generated vnode, which de-opts to FULL_PROPS\r\n          patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n          const oldProps = n1.props || EMPTY_OBJ;\r\n          const newProps = n2.props || EMPTY_OBJ;\r\n          let vnodeHook;\r\n          // disable recurse in beforeUpdate hooks\r\n          parentComponent && toggleRecurse(parentComponent, false);\r\n          if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n              invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n          }\r\n          if (dirs) {\r\n              invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\r\n          }\r\n          parentComponent && toggleRecurse(parentComponent, true);\r\n          if (isHmrUpdating) {\r\n              // HMR updated, force full diff\r\n              patchFlag = 0;\r\n              optimized = false;\r\n              dynamicChildren = null;\r\n          }\r\n          const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\r\n          if (dynamicChildren) {\r\n              patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\r\n              if (parentComponent && parentComponent.type.__hmrId) {\r\n                  traverseStaticChildren(n1, n2);\r\n              }\r\n          }\r\n          else if (!optimized) {\r\n              // full diff\r\n              patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\r\n          }\r\n          if (patchFlag > 0) {\r\n              // the presence of a patchFlag means this element's render code was\r\n              // generated by the compiler and can take the fast path.\r\n              // in this path old node and new node are guaranteed to have the same shape\r\n              // (i.e. at the exact same position in the source template)\r\n              if (patchFlag & 16 /* FULL_PROPS */) {\r\n                  // element props contain dynamic keys, full diff needed\r\n                  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n              }\r\n              else {\r\n                  // class\r\n                  // this flag is matched when the element has dynamic class bindings.\r\n                  if (patchFlag & 2 /* CLASS */) {\r\n                      if (oldProps.class !== newProps.class) {\r\n                          hostPatchProp(el, 'class', null, newProps.class, isSVG);\r\n                      }\r\n                  }\r\n                  // style\r\n                  // this flag is matched when the element has dynamic style bindings\r\n                  if (patchFlag & 4 /* STYLE */) {\r\n                      hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\r\n                  }\r\n                  // props\r\n                  // This flag is matched when the element has dynamic prop/attr bindings\r\n                  // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                  // faster iteration.\r\n                  // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                  // bail out and go through a full diff because we need to unset the old key\r\n                  if (patchFlag & 8 /* PROPS */) {\r\n                      // if the flag is present then dynamicProps must be non-null\r\n                      const propsToUpdate = n2.dynamicProps;\r\n                      for (let i = 0; i < propsToUpdate.length; i++) {\r\n                          const key = propsToUpdate[i];\r\n                          const prev = oldProps[key];\r\n                          const next = newProps[key];\r\n                          // #1471 force patch value\r\n                          if (next !== prev || key === 'value') {\r\n                              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                          }\r\n                      }\r\n                  }\r\n              }\r\n              // text\r\n              // This flag is matched when the element has only dynamic text children.\r\n              if (patchFlag & 1 /* TEXT */) {\r\n                  if (n1.children !== n2.children) {\r\n                      hostSetElementText(el, n2.children);\r\n                  }\r\n              }\r\n          }\r\n          else if (!optimized && dynamicChildren == null) {\r\n              // unoptimized, full diff\r\n              patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n          }\r\n          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n              queuePostRenderEffect(() => {\r\n                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                  dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\r\n              }, parentSuspense);\r\n          }\r\n      };\r\n      // The fast path for blocks.\r\n      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\r\n          for (let i = 0; i < newChildren.length; i++) {\r\n              const oldVNode = oldChildren[i];\r\n              const newVNode = newChildren[i];\r\n              // Determine the container (parent element) for the patch.\r\n              const container = \r\n              // oldVNode may be an errored async setup() component inside Suspense\r\n              // which will not have a mounted element\r\n              oldVNode.el &&\r\n                  // - In the case of a Fragment, we need to provide the actual parent\r\n                  // of the Fragment itself so it can move its children.\r\n                  (oldVNode.type === Fragment ||\r\n                      // - In the case of different nodes, there is going to be a replacement\r\n                      // which also requires the correct parent container\r\n                      !isSameVNodeType(oldVNode, newVNode) ||\r\n                      // - In the case of a component, it could contain anything.\r\n                      oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))\r\n                  ? hostParentNode(oldVNode.el)\r\n                  : // In other cases, the parent container is not actually used so we\r\n                      // just pass the block element here to avoid a DOM parentNode call.\r\n                      fallbackContainer;\r\n              patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\r\n          }\r\n      };\r\n      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n          if (oldProps !== newProps) {\r\n              for (const key in newProps) {\r\n                  // empty string is not valid prop\r\n                  if (isReservedProp(key))\r\n                      continue;\r\n                  const next = newProps[key];\r\n                  const prev = oldProps[key];\r\n                  // defer patching value\r\n                  if (next !== prev && key !== 'value') {\r\n                      hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                  }\r\n              }\r\n              if (oldProps !== EMPTY_OBJ) {\r\n                  for (const key in oldProps) {\r\n                      if (!isReservedProp(key) && !(key in newProps)) {\r\n                          hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                      }\r\n                  }\r\n              }\r\n              if ('value' in newProps) {\r\n                  hostPatchProp(el, 'value', oldProps.value, newProps.value);\r\n              }\r\n          }\r\n      };\r\n      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\r\n          const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\r\n          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\r\n          if (isHmrUpdating) {\r\n              // HMR updated, force full diff\r\n              patchFlag = 0;\r\n              optimized = false;\r\n              dynamicChildren = null;\r\n          }\r\n          // check if this is a slot fragment with :slotted scope ids\r\n          if (fragmentSlotScopeIds) {\r\n              slotScopeIds = slotScopeIds\r\n                  ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                  : fragmentSlotScopeIds;\r\n          }\r\n          if (n1 == null) {\r\n              hostInsert(fragmentStartAnchor, container, anchor);\r\n              hostInsert(fragmentEndAnchor, container, anchor);\r\n              // a fragment can only have array children\r\n              // since they are either generated by the compiler, or implicitly created\r\n              // from arrays.\r\n              mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n          }\r\n          else {\r\n              if (patchFlag > 0 &&\r\n                  patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                  dynamicChildren &&\r\n                  // #2715 the previous fragment could've been a BAILed one as a result\r\n                  // of renderSlot() with no valid children\r\n                  n1.dynamicChildren) {\r\n                  // a stable fragment (template root or <template v-for>) doesn't need to\r\n                  // patch children order, but it may contain dynamicChildren.\r\n                  patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                  if (parentComponent && parentComponent.type.__hmrId) {\r\n                      traverseStaticChildren(n1, n2);\r\n                  }\r\n                  else if (\r\n                  // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n                  //  get moved around. Make sure all root level vnodes inherit el.\r\n                  // #2134 or if it's a component root, it may also get moved around\r\n                  // as the component is being moved.\r\n                  n2.key != null ||\r\n                      (parentComponent && n2 === parentComponent.subTree)) {\r\n                      traverseStaticChildren(n1, n2, true /* shallow */);\r\n                  }\r\n              }\r\n              else {\r\n                  // keyed / unkeyed, or manual fragments.\r\n                  // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                  // each child is guaranteed to be a block so the fragment will never\r\n                  // have dynamicChildren.\r\n                  patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n              }\r\n          }\r\n      };\r\n      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          n2.slotScopeIds = slotScopeIds;\r\n          if (n1 == null) {\r\n              if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                  parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n              }\r\n              else {\r\n                  mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n              }\r\n          }\r\n          else {\r\n              updateComponent(n1, n2, optimized);\r\n          }\r\n      };\r\n      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n          const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n          if (instance.type.__hmrId) {\r\n              registerHMR(instance);\r\n          }\r\n          {\r\n              pushWarningContext(initialVNode);\r\n              startMeasure(instance, `mount`);\r\n          }\r\n          // inject renderer internals for keepAlive\r\n          if (isKeepAlive(initialVNode)) {\r\n              instance.ctx.renderer = internals;\r\n          }\r\n          // resolve props and slots for setup context\r\n          {\r\n              {\r\n                  startMeasure(instance, `init`);\r\n              }\r\n              setupComponent(instance);\r\n              {\r\n                  endMeasure(instance, `init`);\r\n              }\r\n          }\r\n          // setup() is async. This component relies on async logic to be resolved\r\n          // before proceeding\r\n          if (instance.asyncDep) {\r\n              parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n              // Give it a placeholder if this is not hydration\r\n              // TODO handle self-defined fallback\r\n              if (!initialVNode.el) {\r\n                  const placeholder = (instance.subTree = createVNode(Comment));\r\n                  processCommentNode(null, placeholder, container, anchor);\r\n              }\r\n              return;\r\n          }\r\n          setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n          {\r\n              popWarningContext();\r\n              endMeasure(instance, `mount`);\r\n          }\r\n      };\r\n      const updateComponent = (n1, n2, optimized) => {\r\n          const instance = (n2.component = n1.component);\r\n          if (shouldUpdateComponent(n1, n2, optimized)) {\r\n              if (instance.asyncDep &&\r\n                  !instance.asyncResolved) {\r\n                  // async & still pending - just update props and slots\r\n                  // since the component's reactive effect for render isn't set-up yet\r\n                  {\r\n                      pushWarningContext(n2);\r\n                  }\r\n                  updateComponentPreRender(instance, n2, optimized);\r\n                  {\r\n                      popWarningContext();\r\n                  }\r\n                  return;\r\n              }\r\n              else {\r\n                  // normal update\r\n                  instance.next = n2;\r\n                  // in case the child component is also queued, remove it to avoid\r\n                  // double updating the same child component in the same flush.\r\n                  invalidateJob(instance.update);\r\n                  // instance.update is the reactive effect.\r\n                  instance.update();\r\n              }\r\n          }\r\n          else {\r\n              // no update needed. just copy over properties\r\n              n2.component = n1.component;\r\n              n2.el = n1.el;\r\n              instance.vnode = n2;\r\n          }\r\n      };\r\n      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n          const componentUpdateFn = () => {\r\n              if (!instance.isMounted) {\r\n                  let vnodeHook;\r\n                  const { el, props } = initialVNode;\r\n                  const { bm, m, parent } = instance;\r\n                  const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\r\n                  toggleRecurse(instance, false);\r\n                  // beforeMount hook\r\n                  if (bm) {\r\n                      invokeArrayFns(bm);\r\n                  }\r\n                  // onVnodeBeforeMount\r\n                  if (!isAsyncWrapperVNode &&\r\n                      (vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                      invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                  }\r\n                  toggleRecurse(instance, true);\r\n                  if (el && hydrateNode) {\r\n                      // vnode has adopted host node - perform hydration instead of mount.\r\n                      const hydrateSubTree = () => {\r\n                          {\r\n                              startMeasure(instance, `render`);\r\n                          }\r\n                          instance.subTree = renderComponentRoot(instance);\r\n                          {\r\n                              endMeasure(instance, `render`);\r\n                          }\r\n                          {\r\n                              startMeasure(instance, `hydrate`);\r\n                          }\r\n                          hydrateNode(el, instance.subTree, instance, parentSuspense, null);\r\n                          {\r\n                              endMeasure(instance, `hydrate`);\r\n                          }\r\n                      };\r\n                      if (isAsyncWrapperVNode) {\r\n                          initialVNode.type.__asyncLoader().then(\r\n                          // note: we are moving the render call into an async callback,\r\n                          // which means it won't track dependencies - but it's ok because\r\n                          // a server-rendered async wrapper is already in resolved state\r\n                          // and it will never need to change.\r\n                          () => !instance.isUnmounted && hydrateSubTree());\r\n                      }\r\n                      else {\r\n                          hydrateSubTree();\r\n                      }\r\n                  }\r\n                  else {\r\n                      {\r\n                          startMeasure(instance, `render`);\r\n                      }\r\n                      const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                      {\r\n                          endMeasure(instance, `render`);\r\n                      }\r\n                      {\r\n                          startMeasure(instance, `patch`);\r\n                      }\r\n                      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                      {\r\n                          endMeasure(instance, `patch`);\r\n                      }\r\n                      initialVNode.el = subTree.el;\r\n                  }\r\n                  // mounted hook\r\n                  if (m) {\r\n                      queuePostRenderEffect(m, parentSuspense);\r\n                  }\r\n                  // onVnodeMounted\r\n                  if (!isAsyncWrapperVNode &&\r\n                      (vnodeHook = props && props.onVnodeMounted)) {\r\n                      const scopedInitialVNode = initialVNode;\r\n                      queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\r\n                  }\r\n                  // activated hook for keep-alive roots.\r\n                  // #1742 activated hook must be accessed after first render\r\n                  // since the hook may be injected by a child keep-alive\r\n                  if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n                      instance.a && queuePostRenderEffect(instance.a, parentSuspense);\r\n                  }\r\n                  instance.isMounted = true;\r\n                  {\r\n                      devtoolsComponentAdded(instance);\r\n                  }\r\n                  // #2458: deference mount-only object parameters to prevent memleaks\r\n                  initialVNode = container = anchor = null;\r\n              }\r\n              else {\r\n                  // updateComponent\r\n                  // This is triggered by mutation of component's own state (next: null)\r\n                  // OR parent calling processComponent (next: VNode)\r\n                  let { next, bu, u, parent, vnode } = instance;\r\n                  let originNext = next;\r\n                  let vnodeHook;\r\n                  {\r\n                      pushWarningContext(next || instance.vnode);\r\n                  }\r\n                  // Disallow component effect recursion during pre-lifecycle hooks.\r\n                  toggleRecurse(instance, false);\r\n                  if (next) {\r\n                      next.el = vnode.el;\r\n                      updateComponentPreRender(instance, next, optimized);\r\n                  }\r\n                  else {\r\n                      next = vnode;\r\n                  }\r\n                  // beforeUpdate hook\r\n                  if (bu) {\r\n                      invokeArrayFns(bu);\r\n                  }\r\n                  // onVnodeBeforeUpdate\r\n                  if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                      invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                  }\r\n                  toggleRecurse(instance, true);\r\n                  // render\r\n                  {\r\n                      startMeasure(instance, `render`);\r\n                  }\r\n                  const nextTree = renderComponentRoot(instance);\r\n                  {\r\n                      endMeasure(instance, `render`);\r\n                  }\r\n                  const prevTree = instance.subTree;\r\n                  instance.subTree = nextTree;\r\n                  {\r\n                      startMeasure(instance, `patch`);\r\n                  }\r\n                  patch(prevTree, nextTree, \r\n                  // parent may have changed if it's in a teleport\r\n                  hostParentNode(prevTree.el), \r\n                  // anchor may have changed if it's in a fragment\r\n                  getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                  {\r\n                      endMeasure(instance, `patch`);\r\n                  }\r\n                  next.el = nextTree.el;\r\n                  if (originNext === null) {\r\n                      // self-triggered update. In case of HOC, update parent component\r\n                      // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                      // to child component's vnode\r\n                      updateHOCHostEl(instance, nextTree.el);\r\n                  }\r\n                  // updated hook\r\n                  if (u) {\r\n                      queuePostRenderEffect(u, parentSuspense);\r\n                  }\r\n                  // onVnodeUpdated\r\n                  if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                      queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\r\n                  }\r\n                  {\r\n                      devtoolsComponentUpdated(instance);\r\n                  }\r\n                  {\r\n                      popWarningContext();\r\n                  }\r\n              }\r\n          };\r\n          // create reactive effect for rendering\r\n          const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope // track it in component's effect scope\r\n          ));\r\n          const update = (instance.update = effect.run.bind(effect));\r\n          update.id = instance.uid;\r\n          // allowRecurse\r\n          // #1801, #2043 component render effects should allow recursive updates\r\n          toggleRecurse(instance, true);\r\n          {\r\n              effect.onTrack = instance.rtc\r\n                  ? e => invokeArrayFns(instance.rtc, e)\r\n                  : void 0;\r\n              effect.onTrigger = instance.rtg\r\n                  ? e => invokeArrayFns(instance.rtg, e)\r\n                  : void 0;\r\n              // @ts-ignore (for scheduler)\r\n              update.ownerInstance = instance;\r\n          }\r\n          update();\r\n      };\r\n      const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n          nextVNode.component = instance;\r\n          const prevProps = instance.vnode.props;\r\n          instance.vnode = nextVNode;\r\n          instance.next = null;\r\n          updateProps(instance, nextVNode.props, prevProps, optimized);\r\n          updateSlots(instance, nextVNode.children, optimized);\r\n          pauseTracking();\r\n          // props update may have triggered pre-flush watchers.\r\n          // flush them before the render update.\r\n          flushPreFlushCbs(undefined, instance.update);\r\n          resetTracking();\r\n      };\r\n      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\r\n          const c1 = n1 && n1.children;\r\n          const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n          const c2 = n2.children;\r\n          const { patchFlag, shapeFlag } = n2;\r\n          // fast path\r\n          if (patchFlag > 0) {\r\n              if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                  // this could be either fully-keyed or mixed (some keyed some not)\r\n                  // presence of patchFlag means children are guaranteed to be arrays\r\n                  patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  return;\r\n              }\r\n              else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                  // unkeyed\r\n                  patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  return;\r\n              }\r\n          }\r\n          // children has 3 possibilities: text, array or no children.\r\n          if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n              // text children fast path\r\n              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                  unmountChildren(c1, parentComponent, parentSuspense);\r\n              }\r\n              if (c2 !== c1) {\r\n                  hostSetElementText(container, c2);\r\n              }\r\n          }\r\n          else {\r\n              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                  // prev children was array\r\n                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                      // two arrays, cannot assume anything, do full diff\r\n                      patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  }\r\n                  else {\r\n                      // no new children, just unmount old\r\n                      unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                  }\r\n              }\r\n              else {\r\n                  // prev children was text OR null\r\n                  // new children is array OR null\r\n                  if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                      hostSetElementText(container, '');\r\n                  }\r\n                  // mount new if array\r\n                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  }\r\n              }\r\n          }\r\n      };\r\n      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          c1 = c1 || EMPTY_ARR;\r\n          c2 = c2 || EMPTY_ARR;\r\n          const oldLength = c1.length;\r\n          const newLength = c2.length;\r\n          const commonLength = Math.min(oldLength, newLength);\r\n          let i;\r\n          for (i = 0; i < commonLength; i++) {\r\n              const nextChild = (c2[i] = optimized\r\n                  ? cloneIfMounted(c2[i])\r\n                  : normalizeVNode(c2[i]));\r\n              patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n          }\r\n          if (oldLength > newLength) {\r\n              // remove old\r\n              unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n          }\r\n          else {\r\n              // mount new\r\n              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\r\n          }\r\n      };\r\n      // can be all-keyed or mixed\r\n      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n          let i = 0;\r\n          const l2 = c2.length;\r\n          let e1 = c1.length - 1; // prev ending index\r\n          let e2 = l2 - 1; // next ending index\r\n          // 1. sync from start\r\n          // (a b) c\r\n          // (a b) d e\r\n          while (i <= e1 && i <= e2) {\r\n              const n1 = c1[i];\r\n              const n2 = (c2[i] = optimized\r\n                  ? cloneIfMounted(c2[i])\r\n                  : normalizeVNode(c2[i]));\r\n              if (isSameVNodeType(n1, n2)) {\r\n                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n              }\r\n              else {\r\n                  break;\r\n              }\r\n              i++;\r\n          }\r\n          // 2. sync from end\r\n          // a (b c)\r\n          // d e (b c)\r\n          while (i <= e1 && i <= e2) {\r\n              const n1 = c1[e1];\r\n              const n2 = (c2[e2] = optimized\r\n                  ? cloneIfMounted(c2[e2])\r\n                  : normalizeVNode(c2[e2]));\r\n              if (isSameVNodeType(n1, n2)) {\r\n                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n              }\r\n              else {\r\n                  break;\r\n              }\r\n              e1--;\r\n              e2--;\r\n          }\r\n          // 3. common sequence + mount\r\n          // (a b)\r\n          // (a b) c\r\n          // i = 2, e1 = 1, e2 = 2\r\n          // (a b)\r\n          // c (a b)\r\n          // i = 0, e1 = -1, e2 = 0\r\n          if (i > e1) {\r\n              if (i <= e2) {\r\n                  const nextPos = e2 + 1;\r\n                  const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                  while (i <= e2) {\r\n                      patch(null, (c2[i] = optimized\r\n                          ? cloneIfMounted(c2[i])\r\n                          : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                      i++;\r\n                  }\r\n              }\r\n          }\r\n          // 4. common sequence + unmount\r\n          // (a b) c\r\n          // (a b)\r\n          // i = 2, e1 = 2, e2 = 1\r\n          // a (b c)\r\n          // (b c)\r\n          // i = 0, e1 = 0, e2 = -1\r\n          else if (i > e2) {\r\n              while (i <= e1) {\r\n                  unmount(c1[i], parentComponent, parentSuspense, true);\r\n                  i++;\r\n              }\r\n          }\r\n          // 5. unknown sequence\r\n          // [i ... e1 + 1]: a b [c d e] f g\r\n          // [i ... e2 + 1]: a b [e d c h] f g\r\n          // i = 2, e1 = 4, e2 = 5\r\n          else {\r\n              const s1 = i; // prev starting index\r\n              const s2 = i; // next starting index\r\n              // 5.1 build key:index map for newChildren\r\n              const keyToNewIndexMap = new Map();\r\n              for (i = s2; i <= e2; i++) {\r\n                  const nextChild = (c2[i] = optimized\r\n                      ? cloneIfMounted(c2[i])\r\n                      : normalizeVNode(c2[i]));\r\n                  if (nextChild.key != null) {\r\n                      if (keyToNewIndexMap.has(nextChild.key)) {\r\n                          warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\r\n                      }\r\n                      keyToNewIndexMap.set(nextChild.key, i);\r\n                  }\r\n              }\r\n              // 5.2 loop through old children left to be patched and try to patch\r\n              // matching nodes & remove nodes that are no longer present\r\n              let j;\r\n              let patched = 0;\r\n              const toBePatched = e2 - s2 + 1;\r\n              let moved = false;\r\n              // used to track whether any node has moved\r\n              let maxNewIndexSoFar = 0;\r\n              // works as Map<newIndex, oldIndex>\r\n              // Note that oldIndex is offset by +1\r\n              // and oldIndex = 0 is a special value indicating the new node has\r\n              // no corresponding old node.\r\n              // used for determining longest stable subsequence\r\n              const newIndexToOldIndexMap = new Array(toBePatched);\r\n              for (i = 0; i < toBePatched; i++)\r\n                  newIndexToOldIndexMap[i] = 0;\r\n              for (i = s1; i <= e1; i++) {\r\n                  const prevChild = c1[i];\r\n                  if (patched >= toBePatched) {\r\n                      // all new children have been patched so this can only be a removal\r\n                      unmount(prevChild, parentComponent, parentSuspense, true);\r\n                      continue;\r\n                  }\r\n                  let newIndex;\r\n                  if (prevChild.key != null) {\r\n                      newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                  }\r\n                  else {\r\n                      // key-less node, try to locate a key-less node of the same type\r\n                      for (j = s2; j <= e2; j++) {\r\n                          if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                              isSameVNodeType(prevChild, c2[j])) {\r\n                              newIndex = j;\r\n                              break;\r\n                          }\r\n                      }\r\n                  }\r\n                  if (newIndex === undefined) {\r\n                      unmount(prevChild, parentComponent, parentSuspense, true);\r\n                  }\r\n                  else {\r\n                      newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                      if (newIndex >= maxNewIndexSoFar) {\r\n                          maxNewIndexSoFar = newIndex;\r\n                      }\r\n                      else {\r\n                          moved = true;\r\n                      }\r\n                      patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                      patched++;\r\n                  }\r\n              }\r\n              // 5.3 move and mount\r\n              // generate longest stable subsequence only when nodes have moved\r\n              const increasingNewIndexSequence = moved\r\n                  ? getSequence(newIndexToOldIndexMap)\r\n                  : EMPTY_ARR;\r\n              j = increasingNewIndexSequence.length - 1;\r\n              // looping backwards so that we can use last patched node as anchor\r\n              for (i = toBePatched - 1; i >= 0; i--) {\r\n                  const nextIndex = s2 + i;\r\n                  const nextChild = c2[nextIndex];\r\n                  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                  if (newIndexToOldIndexMap[i] === 0) {\r\n                      // mount new\r\n                      patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  }\r\n                  else if (moved) {\r\n                      // move if:\r\n                      // There is no stable subsequence (e.g. a reverse)\r\n                      // OR current node is not among the stable sequence\r\n                      if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                          move(nextChild, container, anchor, 2 /* REORDER */);\r\n                      }\r\n                      else {\r\n                          j--;\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      };\r\n      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n          const { el, type, transition, children, shapeFlag } = vnode;\r\n          if (shapeFlag & 6 /* COMPONENT */) {\r\n              move(vnode.component.subTree, container, anchor, moveType);\r\n              return;\r\n          }\r\n          if (shapeFlag & 128 /* SUSPENSE */) {\r\n              vnode.suspense.move(container, anchor, moveType);\r\n              return;\r\n          }\r\n          if (shapeFlag & 64 /* TELEPORT */) {\r\n              type.move(vnode, container, anchor, internals);\r\n              return;\r\n          }\r\n          if (type === Fragment) {\r\n              hostInsert(el, container, anchor);\r\n              for (let i = 0; i < children.length; i++) {\r\n                  move(children[i], container, anchor, moveType);\r\n              }\r\n              hostInsert(vnode.anchor, container, anchor);\r\n              return;\r\n          }\r\n          if (type === Static) {\r\n              moveStaticNode(vnode, container, anchor);\r\n              return;\r\n          }\r\n          // single nodes\r\n          const needTransition = moveType !== 2 /* REORDER */ &&\r\n              shapeFlag & 1 /* ELEMENT */ &&\r\n              transition;\r\n          if (needTransition) {\r\n              if (moveType === 0 /* ENTER */) {\r\n                  transition.beforeEnter(el);\r\n                  hostInsert(el, container, anchor);\r\n                  queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n              }\r\n              else {\r\n                  const { leave, delayLeave, afterLeave } = transition;\r\n                  const remove = () => hostInsert(el, container, anchor);\r\n                  const performLeave = () => {\r\n                      leave(el, () => {\r\n                          remove();\r\n                          afterLeave && afterLeave();\r\n                      });\r\n                  };\r\n                  if (delayLeave) {\r\n                      delayLeave(el, remove, performLeave);\r\n                  }\r\n                  else {\r\n                      performLeave();\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              hostInsert(el, container, anchor);\r\n          }\r\n      };\r\n      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n          const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n          // unset ref\r\n          if (ref != null) {\r\n              setRef(ref, null, parentSuspense, vnode, true);\r\n          }\r\n          if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n              parentComponent.ctx.deactivate(vnode);\r\n              return;\r\n          }\r\n          const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\r\n          let vnodeHook;\r\n          if (shouldInvokeVnodeHook &&\r\n              (vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n              invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n          }\r\n          if (shapeFlag & 6 /* COMPONENT */) {\r\n              unmountComponent(vnode.component, parentSuspense, doRemove);\r\n          }\r\n          else {\r\n              if (shapeFlag & 128 /* SUSPENSE */) {\r\n                  vnode.suspense.unmount(parentSuspense, doRemove);\r\n                  return;\r\n              }\r\n              if (shouldInvokeDirs) {\r\n                  invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\r\n              }\r\n              if (shapeFlag & 64 /* TELEPORT */) {\r\n                  vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\r\n              }\r\n              else if (dynamicChildren &&\r\n                  // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                  (type !== Fragment ||\r\n                      (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                  // fast path for block nodes: only need to unmount dynamic children.\r\n                  unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n              }\r\n              else if ((type === Fragment &&\r\n                  patchFlag &\r\n                      (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||\r\n                  (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                  unmountChildren(children, parentComponent, parentSuspense);\r\n              }\r\n              if (doRemove) {\r\n                  remove(vnode);\r\n              }\r\n          }\r\n          if ((shouldInvokeVnodeHook &&\r\n              (vnodeHook = props && props.onVnodeUnmounted)) ||\r\n              shouldInvokeDirs) {\r\n              queuePostRenderEffect(() => {\r\n                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                  shouldInvokeDirs &&\r\n                      invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\r\n              }, parentSuspense);\r\n          }\r\n      };\r\n      const remove = vnode => {\r\n          const { type, el, anchor, transition } = vnode;\r\n          if (type === Fragment) {\r\n              removeFragment(el, anchor);\r\n              return;\r\n          }\r\n          if (type === Static) {\r\n              removeStaticNode(vnode);\r\n              return;\r\n          }\r\n          const performRemove = () => {\r\n              hostRemove(el);\r\n              if (transition && !transition.persisted && transition.afterLeave) {\r\n                  transition.afterLeave();\r\n              }\r\n          };\r\n          if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n              transition &&\r\n              !transition.persisted) {\r\n              const { leave, delayLeave } = transition;\r\n              const performLeave = () => leave(el, performRemove);\r\n              if (delayLeave) {\r\n                  delayLeave(vnode.el, performRemove, performLeave);\r\n              }\r\n              else {\r\n                  performLeave();\r\n              }\r\n          }\r\n          else {\r\n              performRemove();\r\n          }\r\n      };\r\n      const removeFragment = (cur, end) => {\r\n          // For fragments, directly remove all contained DOM nodes.\r\n          // (fragment child nodes cannot have transition)\r\n          let next;\r\n          while (cur !== end) {\r\n              next = hostNextSibling(cur);\r\n              hostRemove(cur);\r\n              cur = next;\r\n          }\r\n          hostRemove(end);\r\n      };\r\n      const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n          if (instance.type.__hmrId) {\r\n              unregisterHMR(instance);\r\n          }\r\n          const { bum, scope, update, subTree, um } = instance;\r\n          // beforeUnmount hook\r\n          if (bum) {\r\n              invokeArrayFns(bum);\r\n          }\r\n          // stop effects in component scope\r\n          scope.stop();\r\n          // update may be null if a component is unmounted before its async\r\n          // setup has resolved.\r\n          if (update) {\r\n              // so that scheduler will no longer invoke it\r\n              update.active = false;\r\n              unmount(subTree, instance, parentSuspense, doRemove);\r\n          }\r\n          // unmounted hook\r\n          if (um) {\r\n              queuePostRenderEffect(um, parentSuspense);\r\n          }\r\n          queuePostRenderEffect(() => {\r\n              instance.isUnmounted = true;\r\n          }, parentSuspense);\r\n          // A component with async dep inside a pending suspense is unmounted before\r\n          // its async dep resolves. This should remove the dep from the suspense, and\r\n          // cause the suspense to resolve immediately if that was the last dep.\r\n          if (parentSuspense &&\r\n              parentSuspense.pendingBranch &&\r\n              !parentSuspense.isUnmounted &&\r\n              instance.asyncDep &&\r\n              !instance.asyncResolved &&\r\n              instance.suspenseId === parentSuspense.pendingId) {\r\n              parentSuspense.deps--;\r\n              if (parentSuspense.deps === 0) {\r\n                  parentSuspense.resolve();\r\n              }\r\n          }\r\n          {\r\n              devtoolsComponentRemoved(instance);\r\n          }\r\n      };\r\n      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n          for (let i = start; i < children.length; i++) {\r\n              unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n          }\r\n      };\r\n      const getNextHostNode = vnode => {\r\n          if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n              return getNextHostNode(vnode.component.subTree);\r\n          }\r\n          if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n              return vnode.suspense.next();\r\n          }\r\n          return hostNextSibling((vnode.anchor || vnode.el));\r\n      };\r\n      const render = (vnode, container, isSVG) => {\r\n          if (vnode == null) {\r\n              if (container._vnode) {\r\n                  unmount(container._vnode, null, null, true);\r\n              }\r\n          }\r\n          else {\r\n              patch(container._vnode || null, vnode, container, null, null, null, isSVG);\r\n          }\r\n          flushPostFlushCbs();\r\n          container._vnode = vnode;\r\n      };\r\n      const internals = {\r\n          p: patch,\r\n          um: unmount,\r\n          m: move,\r\n          r: remove,\r\n          mt: mountComponent,\r\n          mc: mountChildren,\r\n          pc: patchChildren,\r\n          pbc: patchBlockChildren,\r\n          n: getNextHostNode,\r\n          o: options\r\n      };\r\n      let hydrate;\r\n      let hydrateNode;\r\n      if (createHydrationFns) {\r\n          [hydrate, hydrateNode] = createHydrationFns(internals);\r\n      }\r\n      return {\r\n          render,\r\n          hydrate,\r\n          createApp: createAppAPI(render, hydrate)\r\n      };\r\n  }\r\n  function toggleRecurse({ effect, update }, allowed) {\r\n      effect.allowRecurse = update.allowRecurse = allowed;\r\n  }\r\n  /**\r\n   * #1156\r\n   * When a component is HMR-enabled, we need to make sure that all static nodes\r\n   * inside a block also inherit the DOM element from the previous tree so that\r\n   * HMR updates (which are full updates) can retrieve the element for patching.\r\n   *\r\n   * #2080\r\n   * Inside keyed `template` fragment static children, if a fragment is moved,\r\n   * the children will always be moved. Therefore, in order to ensure correct move\r\n   * position, el should be inherited from previous nodes.\r\n   */\r\n  function traverseStaticChildren(n1, n2, shallow = false) {\r\n      const ch1 = n1.children;\r\n      const ch2 = n2.children;\r\n      if (isArray(ch1) && isArray(ch2)) {\r\n          for (let i = 0; i < ch1.length; i++) {\r\n              // this is only called in the optimized path so array children are\r\n              // guaranteed to be vnodes\r\n              const c1 = ch1[i];\r\n              let c2 = ch2[i];\r\n              if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                  if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                      c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                      c2.el = c1.el;\r\n                  }\r\n                  if (!shallow)\r\n                      traverseStaticChildren(c1, c2);\r\n              }\r\n              // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n              // would have received .el during block patch)\r\n              if (c2.type === Comment && !c2.el) {\r\n                  c2.el = c1.el;\r\n              }\r\n          }\r\n      }\r\n  }\r\n  // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\n  function getSequence(arr) {\r\n      const p = arr.slice();\r\n      const result = [0];\r\n      let i, j, u, v, c;\r\n      const len = arr.length;\r\n      for (i = 0; i < len; i++) {\r\n          const arrI = arr[i];\r\n          if (arrI !== 0) {\r\n              j = result[result.length - 1];\r\n              if (arr[j] < arrI) {\r\n                  p[i] = j;\r\n                  result.push(i);\r\n                  continue;\r\n              }\r\n              u = 0;\r\n              v = result.length - 1;\r\n              while (u < v) {\r\n                  c = (u + v) >> 1;\r\n                  if (arr[result[c]] < arrI) {\r\n                      u = c + 1;\r\n                  }\r\n                  else {\r\n                      v = c;\r\n                  }\r\n              }\r\n              if (arrI < arr[result[u]]) {\r\n                  if (u > 0) {\r\n                      p[i] = result[u - 1];\r\n                  }\r\n                  result[u] = i;\r\n              }\r\n          }\r\n      }\r\n      u = result.length;\r\n      v = result[u - 1];\r\n      while (u-- > 0) {\r\n          result[u] = v;\r\n          v = p[v];\r\n      }\r\n      return result;\r\n  }\n\n  const isTeleport = (type) => type.__isTeleport;\r\n  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');\r\n  const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\r\n  const resolveTarget = (props, select) => {\r\n      const targetSelector = props && props.to;\r\n      if (isString(targetSelector)) {\r\n          if (!select) {\r\n              warn$1(`Current renderer does not support string target for Teleports. ` +\r\n                      `(missing querySelector renderer option)`);\r\n              return null;\r\n          }\r\n          else {\r\n              const target = select(targetSelector);\r\n              if (!target) {\r\n                  warn$1(`Failed to locate Teleport target with selector \"${targetSelector}\". ` +\r\n                          `Note the target element must exist before the component is mounted - ` +\r\n                          `i.e. the target cannot be rendered by the component itself, and ` +\r\n                          `ideally should be outside of the entire Vue component tree.`);\r\n              }\r\n              return target;\r\n          }\r\n      }\r\n      else {\r\n          if (!targetSelector && !isTeleportDisabled(props)) {\r\n              warn$1(`Invalid Teleport target: ${targetSelector}`);\r\n          }\r\n          return targetSelector;\r\n      }\r\n  };\r\n  const TeleportImpl = {\r\n      __isTeleport: true,\r\n      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\r\n          const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n          const disabled = isTeleportDisabled(n2.props);\r\n          let { shapeFlag, children, dynamicChildren } = n2;\r\n          // #3302\r\n          // HMR updated, force full diff\r\n          if (isHmrUpdating) {\r\n              optimized = false;\r\n              dynamicChildren = null;\r\n          }\r\n          if (n1 == null) {\r\n              // insert anchors in the main view\r\n              const placeholder = (n2.el = createComment('teleport start')\r\n                  );\r\n              const mainAnchor = (n2.anchor = createComment('teleport end')\r\n                  );\r\n              insert(placeholder, container, anchor);\r\n              insert(mainAnchor, container, anchor);\r\n              const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n              const targetAnchor = (n2.targetAnchor = createText(''));\r\n              if (target) {\r\n                  insert(targetAnchor, target);\r\n                  // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n                  isSVG = isSVG || isTargetSVG(target);\r\n              }\r\n              else if (!disabled) {\r\n                  warn$1('Invalid Teleport target on mount:', target, `(${typeof target})`);\r\n              }\r\n              const mount = (container, anchor) => {\r\n                  // Teleport *always* has Array children. This is enforced in both the\r\n                  // compiler and vnode children normalization.\r\n                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                      mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                  }\r\n              };\r\n              if (disabled) {\r\n                  mount(container, mainAnchor);\r\n              }\r\n              else if (target) {\r\n                  mount(target, targetAnchor);\r\n              }\r\n          }\r\n          else {\r\n              // update content\r\n              n2.el = n1.el;\r\n              const mainAnchor = (n2.anchor = n1.anchor);\r\n              const target = (n2.target = n1.target);\r\n              const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n              const wasDisabled = isTeleportDisabled(n1.props);\r\n              const currentContainer = wasDisabled ? container : target;\r\n              const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n              isSVG = isSVG || isTargetSVG(target);\r\n              if (dynamicChildren) {\r\n                  // fast path when the teleport happens to be a block root\r\n                  patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                  // even in block tree mode we need to make sure all root-level nodes\r\n                  // in the teleport inherit previous DOM references so that they can\r\n                  // be moved in future patches.\r\n                  traverseStaticChildren(n1, n2, true);\r\n              }\r\n              else if (!optimized) {\r\n                  patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\r\n              }\r\n              if (disabled) {\r\n                  if (!wasDisabled) {\r\n                      // enabled -> disabled\r\n                      // move into main container\r\n                      moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                  }\r\n              }\r\n              else {\r\n                  // target changed\r\n                  if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                      const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                      if (nextTarget) {\r\n                          moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                      }\r\n                      else {\r\n                          warn$1('Invalid Teleport target on update:', target, `(${typeof target})`);\r\n                      }\r\n                  }\r\n                  else if (wasDisabled) {\r\n                      // disabled -> enabled\r\n                      // move into teleport target\r\n                      moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                  }\r\n              }\r\n          }\r\n      },\r\n      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\r\n          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\r\n          if (target) {\r\n              hostRemove(targetAnchor);\r\n          }\r\n          // an unmounted teleport should always remove its children if not disabled\r\n          if (doRemove || !isTeleportDisabled(props)) {\r\n              hostRemove(anchor);\r\n              if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                  for (let i = 0; i < children.length; i++) {\r\n                      const child = children[i];\r\n                      unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\r\n                  }\r\n              }\r\n          }\r\n      },\r\n      move: moveTeleport,\r\n      hydrate: hydrateTeleport\r\n  };\r\n  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n      // move target anchor if this is a target change.\r\n      if (moveType === 0 /* TARGET_CHANGE */) {\r\n          insert(vnode.targetAnchor, container, parentAnchor);\r\n      }\r\n      const { el, anchor, shapeFlag, children, props } = vnode;\r\n      const isReorder = moveType === 2 /* REORDER */;\r\n      // move main view anchor if this is a re-order.\r\n      if (isReorder) {\r\n          insert(el, container, parentAnchor);\r\n      }\r\n      // if this is a re-order and teleport is enabled (content is in target)\r\n      // do not move children. So the opposite is: only move children if this\r\n      // is not a reorder, or the teleport is disabled\r\n      if (!isReorder || isTeleportDisabled(props)) {\r\n          // Teleport has either Array children or no children.\r\n          if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n              for (let i = 0; i < children.length; i++) {\r\n                  move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n              }\r\n          }\r\n      }\r\n      // move main view anchor if this is a re-order.\r\n      if (isReorder) {\r\n          insert(anchor, container, parentAnchor);\r\n      }\r\n  }\r\n  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n      const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n      if (target) {\r\n          // if multiple teleports rendered to the same target element, we need to\r\n          // pick up from where the last teleport finished instead of the first node\r\n          const targetNode = target._lpa || target.firstChild;\r\n          if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n              if (isTeleportDisabled(vnode.props)) {\r\n                  vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                  vnode.targetAnchor = targetNode;\r\n              }\r\n              else {\r\n                  vnode.anchor = nextSibling(node);\r\n                  vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n              }\r\n              target._lpa =\r\n                  vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n          }\r\n      }\r\n      return vnode.anchor && nextSibling(vnode.anchor);\r\n  }\r\n  // Force-casted public typing for h and TSX props inference\r\n  const Teleport = TeleportImpl;\n\n  const COMPONENTS = 'components';\r\n  const DIRECTIVES = 'directives';\r\n  /**\r\n   * @private\r\n   */\r\n  function resolveComponent(name, maybeSelfReference) {\r\n      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\r\n  }\r\n  const NULL_DYNAMIC_COMPONENT = Symbol();\r\n  /**\r\n   * @private\r\n   */\r\n  function resolveDynamicComponent(component) {\r\n      if (isString(component)) {\r\n          return resolveAsset(COMPONENTS, component, false) || component;\r\n      }\r\n      else {\r\n          // invalid types will fallthrough to createVNode and raise warning\r\n          return (component || NULL_DYNAMIC_COMPONENT);\r\n      }\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  function resolveDirective(name) {\r\n      return resolveAsset(DIRECTIVES, name);\r\n  }\r\n  // implementation\r\n  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\r\n      const instance = currentRenderingInstance || currentInstance;\r\n      if (instance) {\r\n          const Component = instance.type;\r\n          // explicit self name has highest priority\r\n          if (type === COMPONENTS) {\r\n              const selfName = getComponentName(Component);\r\n              if (selfName &&\r\n                  (selfName === name ||\r\n                      selfName === camelize(name) ||\r\n                      selfName === capitalize(camelize(name)))) {\r\n                  return Component;\r\n              }\r\n          }\r\n          const res = \r\n          // local registration\r\n          // check instance[type] first which is resolved for options API\r\n          resolve(instance[type] || Component[type], name) ||\r\n              // global registration\r\n              resolve(instance.appContext[type], name);\r\n          if (!res && maybeSelfReference) {\r\n              // fallback to implicit self-reference\r\n              return Component;\r\n          }\r\n          if (warnMissing && !res) {\r\n              const extra = type === COMPONENTS\r\n                  ? `\\nIf this is a native custom element, make sure to exclude it from ` +\r\n                      `component resolution via compilerOptions.isCustomElement.`\r\n                  : ``;\r\n              warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\r\n          }\r\n          return res;\r\n      }\r\n      else {\r\n          warn$1(`resolve${capitalize(type.slice(0, -1))} ` +\r\n              `can only be used in render() or setup().`);\r\n      }\r\n  }\r\n  function resolve(registry, name) {\r\n      return (registry &&\r\n          (registry[name] ||\r\n              registry[camelize(name)] ||\r\n              registry[capitalize(camelize(name))]));\r\n  }\n\n  const Fragment = Symbol('Fragment' );\r\n  const Text = Symbol('Text' );\r\n  const Comment = Symbol('Comment' );\r\n  const Static = Symbol('Static' );\r\n  // Since v-if and v-for are the two possible ways node structure can dynamically\r\n  // change, once we consider v-if branches and each v-for fragment a block, we\r\n  // can divide a template into nested blocks, and within each block the node\r\n  // structure would be stable. This allows us to skip most children diffing\r\n  // and only worry about the dynamic nodes (indicated by patch flags).\r\n  const blockStack = [];\r\n  let currentBlock = null;\r\n  /**\r\n   * Open a block.\r\n   * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n   * because the children of the block are evaluated before `createBlock` itself\r\n   * is called. The generated code typically looks like this:\r\n   *\r\n   * ```js\r\n   * function render() {\r\n   *   return (openBlock(),createBlock('div', null, [...]))\r\n   * }\r\n   * ```\r\n   * disableTracking is true when creating a v-for fragment block, since a v-for\r\n   * fragment always diffs its children.\r\n   *\r\n   * @private\r\n   */\r\n  function openBlock(disableTracking = false) {\r\n      blockStack.push((currentBlock = disableTracking ? null : []));\r\n  }\r\n  function closeBlock() {\r\n      blockStack.pop();\r\n      currentBlock = blockStack[blockStack.length - 1] || null;\r\n  }\r\n  // Whether we should be tracking dynamic child nodes inside a block.\r\n  // Only tracks when this value is > 0\r\n  // We are not using a simple boolean because this value may need to be\r\n  // incremented/decremented by nested usage of v-once (see below)\r\n  let isBlockTreeEnabled = 1;\r\n  /**\r\n   * Block tracking sometimes needs to be disabled, for example during the\r\n   * creation of a tree that needs to be cached by v-once. The compiler generates\r\n   * code like this:\r\n   *\r\n   * ``` js\r\n   * _cache[1] || (\r\n   *   setBlockTracking(-1),\r\n   *   _cache[1] = createVNode(...),\r\n   *   setBlockTracking(1),\r\n   *   _cache[1]\r\n   * )\r\n   * ```\r\n   *\r\n   * @private\r\n   */\r\n  function setBlockTracking(value) {\r\n      isBlockTreeEnabled += value;\r\n  }\r\n  function setupBlock(vnode) {\r\n      // save current block children on the block vnode\r\n      vnode.dynamicChildren =\r\n          isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;\r\n      // close block\r\n      closeBlock();\r\n      // a block is always going to be patched, so track it as a child of its\r\n      // parent block\r\n      if (isBlockTreeEnabled > 0 && currentBlock) {\r\n          currentBlock.push(vnode);\r\n      }\r\n      return vnode;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\r\n      return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\r\n  }\r\n  /**\r\n   * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n   * A block root keeps track of dynamic nodes within the block in the\r\n   * `dynamicChildren` array.\r\n   *\r\n   * @private\r\n   */\r\n  function createBlock(type, props, children, patchFlag, dynamicProps) {\r\n      return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));\r\n  }\r\n  function isVNode(value) {\r\n      return value ? value.__v_isVNode === true : false;\r\n  }\r\n  function isSameVNodeType(n1, n2) {\r\n      if (n2.shapeFlag & 6 /* COMPONENT */ &&\r\n          hmrDirtyComponents.has(n2.type)) {\r\n          // HMR only: if the component has been hot-updated, force a reload.\r\n          return false;\r\n      }\r\n      return n1.type === n2.type && n1.key === n2.key;\r\n  }\r\n  let vnodeArgsTransformer;\r\n  /**\r\n   * Internal API for registering an arguments transform for createVNode\r\n   * used for creating stubs in the test-utils\r\n   * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n   * typings\r\n   */\r\n  function transformVNodeArgs(transformer) {\r\n      vnodeArgsTransformer = transformer;\r\n  }\r\n  const createVNodeWithArgsTransform = (...args) => {\r\n      return _createVNode(...(vnodeArgsTransformer\r\n          ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n          : args));\r\n  };\r\n  const InternalObjectKey = `__vInternal`;\r\n  const normalizeKey = ({ key }) => key != null ? key : null;\r\n  const normalizeRef = ({ ref, ref_key, ref_for }) => {\r\n      return (ref != null\r\n          ? isString(ref) || isRef(ref) || isFunction(ref)\r\n              ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\r\n              : ref\r\n          : null);\r\n  };\r\n  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {\r\n      const vnode = {\r\n          __v_isVNode: true,\r\n          __v_skip: true,\r\n          type,\r\n          props,\r\n          key: props && normalizeKey(props),\r\n          ref: props && normalizeRef(props),\r\n          scopeId: currentScopeId,\r\n          slotScopeIds: null,\r\n          children,\r\n          component: null,\r\n          suspense: null,\r\n          ssContent: null,\r\n          ssFallback: null,\r\n          dirs: null,\r\n          transition: null,\r\n          el: null,\r\n          anchor: null,\r\n          target: null,\r\n          targetAnchor: null,\r\n          staticCount: 0,\r\n          shapeFlag,\r\n          patchFlag,\r\n          dynamicProps,\r\n          dynamicChildren: null,\r\n          appContext: null\r\n      };\r\n      if (needFullChildrenNormalization) {\r\n          normalizeChildren(vnode, children);\r\n          // normalize suspense children\r\n          if (shapeFlag & 128 /* SUSPENSE */) {\r\n              type.normalize(vnode);\r\n          }\r\n      }\r\n      else if (children) {\r\n          // compiled element vnode - if children is passed, only possible types are\r\n          // string or Array.\r\n          vnode.shapeFlag |= isString(children)\r\n              ? 8 /* TEXT_CHILDREN */\r\n              : 16 /* ARRAY_CHILDREN */;\r\n      }\r\n      // validate key\r\n      if (vnode.key !== vnode.key) {\r\n          warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\r\n      }\r\n      // track vnode for block tree\r\n      if (isBlockTreeEnabled > 0 &&\r\n          // avoid a block node from tracking itself\r\n          !isBlockNode &&\r\n          // has current parent block\r\n          currentBlock &&\r\n          // presence of a patch flag indicates this node needs patching on updates.\r\n          // component nodes also should always be patched, because even if the\r\n          // component doesn't need to update, it needs to persist the instance on to\r\n          // the next vnode so that it can be properly unmounted later.\r\n          (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n          // the EVENTS flag is only for hydration and if it is the only flag, the\r\n          // vnode should not be considered dynamic due to handler caching.\r\n          vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n          currentBlock.push(vnode);\r\n      }\r\n      return vnode;\r\n  }\r\n  const createVNode = (createVNodeWithArgsTransform );\r\n  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n      if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n          if (!type) {\r\n              warn$1(`Invalid vnode type when creating vnode: ${type}.`);\r\n          }\r\n          type = Comment;\r\n      }\r\n      if (isVNode(type)) {\r\n          // createVNode receiving an existing vnode. This happens in cases like\r\n          // <component :is=\"vnode\"/>\r\n          // #2078 make sure to merge refs during the clone instead of overwriting it\r\n          const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n          if (children) {\r\n              normalizeChildren(cloned, children);\r\n          }\r\n          return cloned;\r\n      }\r\n      // class component normalization.\r\n      if (isClassComponent(type)) {\r\n          type = type.__vccOpts;\r\n      }\r\n      // class & style normalization.\r\n      if (props) {\r\n          // for reactive or proxy objects, we need to clone it to enable mutation.\r\n          props = guardReactiveProps(props);\r\n          let { class: klass, style } = props;\r\n          if (klass && !isString(klass)) {\r\n              props.class = normalizeClass(klass);\r\n          }\r\n          if (isObject(style)) {\r\n              // reactive state objects need to be cloned since they are likely to be\r\n              // mutated\r\n              if (isProxy(style) && !isArray(style)) {\r\n                  style = extend({}, style);\r\n              }\r\n              props.style = normalizeStyle(style);\r\n          }\r\n      }\r\n      // encode the vnode type information into a bitmap\r\n      const shapeFlag = isString(type)\r\n          ? 1 /* ELEMENT */\r\n          : isSuspense(type)\r\n              ? 128 /* SUSPENSE */\r\n              : isTeleport(type)\r\n                  ? 64 /* TELEPORT */\r\n                  : isObject(type)\r\n                      ? 4 /* STATEFUL_COMPONENT */\r\n                      : isFunction(type)\r\n                          ? 2 /* FUNCTIONAL_COMPONENT */\r\n                          : 0;\r\n      if (shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {\r\n          type = toRaw(type);\r\n          warn$1(`Vue received a Component which was made a reactive object. This can ` +\r\n              `lead to unnecessary performance overhead, and should be avoided by ` +\r\n              `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n              `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\r\n      }\r\n      return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\r\n  }\r\n  function guardReactiveProps(props) {\r\n      if (!props)\r\n          return null;\r\n      return isProxy(props) || InternalObjectKey in props\r\n          ? extend({}, props)\r\n          : props;\r\n  }\r\n  function cloneVNode(vnode, extraProps, mergeRef = false) {\r\n      // This is intentionally NOT using spread or extend to avoid the runtime\r\n      // key enumeration cost.\r\n      const { props, ref, patchFlag, children } = vnode;\r\n      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n      const cloned = {\r\n          __v_isVNode: true,\r\n          __v_skip: true,\r\n          type: vnode.type,\r\n          props: mergedProps,\r\n          key: mergedProps && normalizeKey(mergedProps),\r\n          ref: extraProps && extraProps.ref\r\n              ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                  // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                  // the refs so the single vnode can be set on multiple refs\r\n                  mergeRef && ref\r\n                      ? isArray(ref)\r\n                          ? ref.concat(normalizeRef(extraProps))\r\n                          : [ref, normalizeRef(extraProps)]\r\n                      : normalizeRef(extraProps)\r\n              : ref,\r\n          scopeId: vnode.scopeId,\r\n          slotScopeIds: vnode.slotScopeIds,\r\n          children: patchFlag === -1 /* HOISTED */ && isArray(children)\r\n              ? children.map(deepCloneVNode)\r\n              : children,\r\n          target: vnode.target,\r\n          targetAnchor: vnode.targetAnchor,\r\n          staticCount: vnode.staticCount,\r\n          shapeFlag: vnode.shapeFlag,\r\n          // if the vnode is cloned with extra props, we can no longer assume its\r\n          // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n          // note: preserve flag for fragments since they use the flag for children\r\n          // fast paths only.\r\n          patchFlag: extraProps && vnode.type !== Fragment\r\n              ? patchFlag === -1 // hoisted node\r\n                  ? 16 /* FULL_PROPS */\r\n                  : patchFlag | 16 /* FULL_PROPS */\r\n              : patchFlag,\r\n          dynamicProps: vnode.dynamicProps,\r\n          dynamicChildren: vnode.dynamicChildren,\r\n          appContext: vnode.appContext,\r\n          dirs: vnode.dirs,\r\n          transition: vnode.transition,\r\n          // These should technically only be non-null on mounted VNodes. However,\r\n          // they *should* be copied for kept-alive vnodes. So we just always copy\r\n          // them since them being non-null during a mount doesn't affect the logic as\r\n          // they will simply be overwritten.\r\n          component: vnode.component,\r\n          suspense: vnode.suspense,\r\n          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n          el: vnode.el,\r\n          anchor: vnode.anchor\r\n      };\r\n      return cloned;\r\n  }\r\n  /**\r\n   * Dev only, for HMR of hoisted vnodes reused in v-for\r\n   * https://github.com/vitejs/vite/issues/2022\r\n   */\r\n  function deepCloneVNode(vnode) {\r\n      const cloned = cloneVNode(vnode);\r\n      if (isArray(vnode.children)) {\r\n          cloned.children = vnode.children.map(deepCloneVNode);\r\n      }\r\n      return cloned;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  function createTextVNode(text = ' ', flag = 0) {\r\n      return createVNode(Text, null, text, flag);\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  function createStaticVNode(content, numberOfNodes) {\r\n      // A static vnode can contain multiple stringified elements, and the number\r\n      // of elements is necessary for hydration.\r\n      const vnode = createVNode(Static, null, content);\r\n      vnode.staticCount = numberOfNodes;\r\n      return vnode;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  function createCommentVNode(text = '', \r\n  // when used as the v-else branch, the comment node must be created as a\r\n  // block to ensure correct updates.\r\n  asBlock = false) {\r\n      return asBlock\r\n          ? (openBlock(), createBlock(Comment, null, text))\r\n          : createVNode(Comment, null, text);\r\n  }\r\n  function normalizeVNode(child) {\r\n      if (child == null || typeof child === 'boolean') {\r\n          // empty placeholder\r\n          return createVNode(Comment);\r\n      }\r\n      else if (isArray(child)) {\r\n          // fragment\r\n          return createVNode(Fragment, null, \r\n          // #3666, avoid reference pollution when reusing vnode\r\n          child.slice());\r\n      }\r\n      else if (typeof child === 'object') {\r\n          // already vnode, this should be the most common since compiled templates\r\n          // always produce all-vnode children arrays\r\n          return cloneIfMounted(child);\r\n      }\r\n      else {\r\n          // strings and numbers\r\n          return createVNode(Text, null, String(child));\r\n      }\r\n  }\r\n  // optimized normalization for template-compiled render fns\r\n  function cloneIfMounted(child) {\r\n      return child.el === null || child.memo ? child : cloneVNode(child);\r\n  }\r\n  function normalizeChildren(vnode, children) {\r\n      let type = 0;\r\n      const { shapeFlag } = vnode;\r\n      if (children == null) {\r\n          children = null;\r\n      }\r\n      else if (isArray(children)) {\r\n          type = 16 /* ARRAY_CHILDREN */;\r\n      }\r\n      else if (typeof children === 'object') {\r\n          if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {\r\n              // Normalize slot to plain children for plain element and Teleport\r\n              const slot = children.default;\r\n              if (slot) {\r\n                  // _c marker is added by withCtx() indicating this is a compiled slot\r\n                  slot._c && (slot._d = false);\r\n                  normalizeChildren(vnode, slot());\r\n                  slot._c && (slot._d = true);\r\n              }\r\n              return;\r\n          }\r\n          else {\r\n              type = 32 /* SLOTS_CHILDREN */;\r\n              const slotFlag = children._;\r\n              if (!slotFlag && !(InternalObjectKey in children)) {\r\n                  children._ctx = currentRenderingInstance;\r\n              }\r\n              else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                  // a child component receives forwarded slots from the parent.\r\n                  // its slot type is determined by its parent's slot type.\r\n                  if (currentRenderingInstance.slots._ === 1 /* STABLE */) {\r\n                      children._ = 1 /* STABLE */;\r\n                  }\r\n                  else {\r\n                      children._ = 2 /* DYNAMIC */;\r\n                      vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      else if (isFunction(children)) {\r\n          children = { default: children, _ctx: currentRenderingInstance };\r\n          type = 32 /* SLOTS_CHILDREN */;\r\n      }\r\n      else {\r\n          children = String(children);\r\n          // force teleport children to array so it can be moved around\r\n          if (shapeFlag & 64 /* TELEPORT */) {\r\n              type = 16 /* ARRAY_CHILDREN */;\r\n              children = [createTextVNode(children)];\r\n          }\r\n          else {\r\n              type = 8 /* TEXT_CHILDREN */;\r\n          }\r\n      }\r\n      vnode.children = children;\r\n      vnode.shapeFlag |= type;\r\n  }\r\n  function mergeProps(...args) {\r\n      const ret = {};\r\n      for (let i = 0; i < args.length; i++) {\r\n          const toMerge = args[i];\r\n          for (const key in toMerge) {\r\n              if (key === 'class') {\r\n                  if (ret.class !== toMerge.class) {\r\n                      ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                  }\r\n              }\r\n              else if (key === 'style') {\r\n                  ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n              }\r\n              else if (isOn(key)) {\r\n                  const existing = ret[key];\r\n                  const incoming = toMerge[key];\r\n                  if (incoming &&\r\n                      existing !== incoming &&\r\n                      !(isArray(existing) && existing.includes(incoming))) {\r\n                      ret[key] = existing\r\n                          ? [].concat(existing, incoming)\r\n                          : incoming;\r\n                  }\r\n              }\r\n              else if (key !== '') {\r\n                  ret[key] = toMerge[key];\r\n              }\r\n          }\r\n      }\r\n      return ret;\r\n  }\r\n  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n      callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n          vnode,\r\n          prevVNode\r\n      ]);\r\n  }\n\n  /**\r\n   * Actual implementation\r\n   */\r\n  function renderList(source, renderItem, cache, index) {\r\n      let ret;\r\n      const cached = (cache && cache[index]);\r\n      if (isArray(source) || isString(source)) {\r\n          ret = new Array(source.length);\r\n          for (let i = 0, l = source.length; i < l; i++) {\r\n              ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);\r\n          }\r\n      }\r\n      else if (typeof source === 'number') {\r\n          if (!Number.isInteger(source)) {\r\n              warn$1(`The v-for range expect an integer value but got ${source}.`);\r\n              return [];\r\n          }\r\n          ret = new Array(source);\r\n          for (let i = 0; i < source; i++) {\r\n              ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);\r\n          }\r\n      }\r\n      else if (isObject(source)) {\r\n          if (source[Symbol.iterator]) {\r\n              ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));\r\n          }\r\n          else {\r\n              const keys = Object.keys(source);\r\n              ret = new Array(keys.length);\r\n              for (let i = 0, l = keys.length; i < l; i++) {\r\n                  const key = keys[i];\r\n                  ret[i] = renderItem(source[key], key, i, cached && cached[i]);\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          ret = [];\r\n      }\r\n      if (cache) {\r\n          cache[index] = ret;\r\n      }\r\n      return ret;\r\n  }\n\n  /**\r\n   * Compiler runtime helper for creating dynamic slots object\r\n   * @private\r\n   */\r\n  function createSlots(slots, dynamicSlots) {\r\n      for (let i = 0; i < dynamicSlots.length; i++) {\r\n          const slot = dynamicSlots[i];\r\n          // array of dynamic slot generated by <template v-for=\"...\" #[...]>\r\n          if (isArray(slot)) {\r\n              for (let j = 0; j < slot.length; j++) {\r\n                  slots[slot[j].name] = slot[j].fn;\r\n              }\r\n          }\r\n          else if (slot) {\r\n              // conditional single slot generated by <template v-if=\"...\" #foo>\r\n              slots[slot.name] = slot.fn;\r\n          }\r\n      }\r\n      return slots;\r\n  }\n\n  /**\r\n   * Compiler runtime helper for rendering `<slot/>`\r\n   * @private\r\n   */\r\n  function renderSlot(slots, name, props = {}, \r\n  // this is not a user-facing function, so the fallback is always generated by\r\n  // the compiler and guaranteed to be a function returning an array\r\n  fallback, noSlotted) {\r\n      if (currentRenderingInstance.isCE) {\r\n          return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());\r\n      }\r\n      let slot = slots[name];\r\n      if (slot && slot.length > 1) {\r\n          warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render ` +\r\n              `function. You need to mark this component with $dynamic-slots in the ` +\r\n              `parent template.`);\r\n          slot = () => [];\r\n      }\r\n      // a compiled slot disables block tracking by default to avoid manual\r\n      // invocation interfering with template-based block tracking, but in\r\n      // `renderSlot` we can be sure that it's template-based so we can force\r\n      // enable it.\r\n      if (slot && slot._c) {\r\n          slot._d = false;\r\n      }\r\n      openBlock();\r\n      const validSlotContent = slot && ensureValidVNode(slot(props));\r\n      const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */\r\n          ? 64 /* STABLE_FRAGMENT */\r\n          : -2 /* BAIL */);\r\n      if (!noSlotted && rendered.scopeId) {\r\n          rendered.slotScopeIds = [rendered.scopeId + '-s'];\r\n      }\r\n      if (slot && slot._c) {\r\n          slot._d = true;\r\n      }\r\n      return rendered;\r\n  }\r\n  function ensureValidVNode(vnodes) {\r\n      return vnodes.some(child => {\r\n          if (!isVNode(child))\r\n              return true;\r\n          if (child.type === Comment)\r\n              return false;\r\n          if (child.type === Fragment &&\r\n              !ensureValidVNode(child.children))\r\n              return false;\r\n          return true;\r\n      })\r\n          ? vnodes\r\n          : null;\r\n  }\n\n  /**\r\n   * For prefixing keys in v-on=\"obj\" with \"on\"\r\n   * @private\r\n   */\r\n  function toHandlers(obj) {\r\n      const ret = {};\r\n      if (!isObject(obj)) {\r\n          warn$1(`v-on with no argument expects an object value.`);\r\n          return ret;\r\n      }\r\n      for (const key in obj) {\r\n          ret[toHandlerKey(key)] = obj[key];\r\n      }\r\n      return ret;\r\n  }\n\n  /**\r\n   * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n   * they exist in the internal parent chain. For code that relies on traversing\r\n   * public $parent chains, skip functional ones and go to the parent instead.\r\n   */\r\n  const getPublicInstance = (i) => {\r\n      if (!i)\r\n          return null;\r\n      if (isStatefulComponent(i))\r\n          return getExposeProxy(i) || i.proxy;\r\n      return getPublicInstance(i.parent);\r\n  };\r\n  const publicPropertiesMap = extend(Object.create(null), {\r\n      $: i => i,\r\n      $el: i => i.vnode.el,\r\n      $data: i => i.data,\r\n      $props: i => (shallowReadonly(i.props) ),\r\n      $attrs: i => (shallowReadonly(i.attrs) ),\r\n      $slots: i => (shallowReadonly(i.slots) ),\r\n      $refs: i => (shallowReadonly(i.refs) ),\r\n      $parent: i => getPublicInstance(i.parent),\r\n      $root: i => getPublicInstance(i.root),\r\n      $emit: i => i.emit,\r\n      $options: i => (resolveMergedOptions(i) ),\r\n      $forceUpdate: i => () => queueJob(i.update),\r\n      $nextTick: i => nextTick.bind(i.proxy),\r\n      $watch: i => (instanceWatch.bind(i) )\r\n  });\r\n  const PublicInstanceProxyHandlers = {\r\n      get({ _: instance }, key) {\r\n          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n          // for internal formatters to know that this is a Vue instance\r\n          if (key === '__isVue') {\r\n              return true;\r\n          }\r\n          // prioritize <script setup> bindings during dev.\r\n          // this allows even properties that start with _ or $ to be used - so that\r\n          // it aligns with the production behavior where the render fn is inlined and\r\n          // indeed has access to all declared variables.\r\n          if (setupState !== EMPTY_OBJ &&\r\n              setupState.__isScriptSetup &&\r\n              hasOwn(setupState, key)) {\r\n              return setupState[key];\r\n          }\r\n          // data / props / ctx\r\n          // This getter gets called for every property access on the render context\r\n          // during render and is a major hotspot. The most expensive part of this\r\n          // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n          // access on a plain object, so we use an accessCache object (with null\r\n          // prototype) to memoize what access type a key corresponds to.\r\n          let normalizedProps;\r\n          if (key[0] !== '$') {\r\n              const n = accessCache[key];\r\n              if (n !== undefined) {\r\n                  switch (n) {\r\n                      case 1 /* SETUP */:\r\n                          return setupState[key];\r\n                      case 2 /* DATA */:\r\n                          return data[key];\r\n                      case 4 /* CONTEXT */:\r\n                          return ctx[key];\r\n                      case 3 /* PROPS */:\r\n                          return props[key];\r\n                      // default: just fallthrough\r\n                  }\r\n              }\r\n              else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n                  accessCache[key] = 1 /* SETUP */;\r\n                  return setupState[key];\r\n              }\r\n              else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n                  accessCache[key] = 2 /* DATA */;\r\n                  return data[key];\r\n              }\r\n              else if (\r\n              // only cache other properties when instance has declared (thus stable)\r\n              // props\r\n              (normalizedProps = instance.propsOptions[0]) &&\r\n                  hasOwn(normalizedProps, key)) {\r\n                  accessCache[key] = 3 /* PROPS */;\r\n                  return props[key];\r\n              }\r\n              else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n                  accessCache[key] = 4 /* CONTEXT */;\r\n                  return ctx[key];\r\n              }\r\n              else if (shouldCacheAccess) {\r\n                  accessCache[key] = 0 /* OTHER */;\r\n              }\r\n          }\r\n          const publicGetter = publicPropertiesMap[key];\r\n          let cssModule, globalProperties;\r\n          // public $xxx properties\r\n          if (publicGetter) {\r\n              if (key === '$attrs') {\r\n                  track(instance, \"get\" /* GET */, key);\r\n                  markAttrsAccessed();\r\n              }\r\n              return publicGetter(instance);\r\n          }\r\n          else if (\r\n          // css module (injected by vue-loader)\r\n          (cssModule = type.__cssModules) &&\r\n              (cssModule = cssModule[key])) {\r\n              return cssModule;\r\n          }\r\n          else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n              // user may set custom properties to `this` that start with `$`\r\n              accessCache[key] = 4 /* CONTEXT */;\r\n              return ctx[key];\r\n          }\r\n          else if (\r\n          // global properties\r\n          ((globalProperties = appContext.config.globalProperties),\r\n              hasOwn(globalProperties, key))) {\r\n              {\r\n                  return globalProperties[key];\r\n              }\r\n          }\r\n          else if (currentRenderingInstance &&\r\n              (!isString(key) ||\r\n                  // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n                  // to infinite warning loop\r\n                  key.indexOf('__v') !== 0)) {\r\n              if (data !== EMPTY_OBJ &&\r\n                  (key[0] === '$' || key[0] === '_') &&\r\n                  hasOwn(data, key)) {\r\n                  warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\r\n                      `character (\"$\" or \"_\") and is not proxied on the render context.`);\r\n              }\r\n              else if (instance === currentRenderingInstance) {\r\n                  warn$1(`Property ${JSON.stringify(key)} was accessed during render ` +\r\n                      `but is not defined on instance.`);\r\n              }\r\n          }\r\n      },\r\n      set({ _: instance }, key, value) {\r\n          const { data, setupState, ctx } = instance;\r\n          if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\r\n              setupState[key] = value;\r\n              return true;\r\n          }\r\n          else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n              data[key] = value;\r\n              return true;\r\n          }\r\n          else if (hasOwn(instance.props, key)) {\r\n              warn$1(`Attempting to mutate prop \"${key}\". Props are readonly.`, instance);\r\n              return false;\r\n          }\r\n          if (key[0] === '$' && key.slice(1) in instance) {\r\n              warn$1(`Attempting to mutate public property \"${key}\". ` +\r\n                      `Properties starting with $ are reserved and readonly.`, instance);\r\n              return false;\r\n          }\r\n          else {\r\n              if (key in instance.appContext.config.globalProperties) {\r\n                  Object.defineProperty(ctx, key, {\r\n                      enumerable: true,\r\n                      configurable: true,\r\n                      value\r\n                  });\r\n              }\r\n              else {\r\n                  ctx[key] = value;\r\n              }\r\n          }\r\n          return true;\r\n      },\r\n      has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n          let normalizedProps;\r\n          return (!!accessCache[key] ||\r\n              (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n              (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\r\n              ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n              hasOwn(ctx, key) ||\r\n              hasOwn(publicPropertiesMap, key) ||\r\n              hasOwn(appContext.config.globalProperties, key));\r\n      },\r\n      defineProperty(target, key, descriptor) {\r\n          if (descriptor.get != null) {\r\n              this.set(target, key, descriptor.get(), null);\r\n          }\r\n          else if (descriptor.value != null) {\r\n              this.set(target, key, descriptor.value, null);\r\n          }\r\n          return Reflect.defineProperty(target, key, descriptor);\r\n      }\r\n  };\r\n  {\r\n      PublicInstanceProxyHandlers.ownKeys = (target) => {\r\n          warn$1(`Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n              `The keys will be empty in production mode to avoid performance overhead.`);\r\n          return Reflect.ownKeys(target);\r\n      };\r\n  }\r\n  const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend({}, PublicInstanceProxyHandlers, {\r\n      get(target, key) {\r\n          // fast path for unscopables when using `with` block\r\n          if (key === Symbol.unscopables) {\r\n              return;\r\n          }\r\n          return PublicInstanceProxyHandlers.get(target, key, target);\r\n      },\r\n      has(_, key) {\r\n          const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n          if (!has && PublicInstanceProxyHandlers.has(_, key)) {\r\n              warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\r\n          }\r\n          return has;\r\n      }\r\n  });\r\n  // dev only\r\n  // In dev mode, the proxy target exposes the same properties as seen on `this`\r\n  // for easier console inspection. In prod mode it will be an empty object so\r\n  // these properties definitions can be skipped.\r\n  function createDevRenderContext(instance) {\r\n      const target = {};\r\n      // expose internal instance for proxy handlers\r\n      Object.defineProperty(target, `_`, {\r\n          configurable: true,\r\n          enumerable: false,\r\n          get: () => instance\r\n      });\r\n      // expose public properties\r\n      Object.keys(publicPropertiesMap).forEach(key => {\r\n          Object.defineProperty(target, key, {\r\n              configurable: true,\r\n              enumerable: false,\r\n              get: () => publicPropertiesMap[key](instance),\r\n              // intercepted by the proxy so no need for implementation,\r\n              // but needed to prevent set errors\r\n              set: NOOP\r\n          });\r\n      });\r\n      return target;\r\n  }\r\n  // dev only\r\n  function exposePropsOnRenderContext(instance) {\r\n      const { ctx, propsOptions: [propsOptions] } = instance;\r\n      if (propsOptions) {\r\n          Object.keys(propsOptions).forEach(key => {\r\n              Object.defineProperty(ctx, key, {\r\n                  enumerable: true,\r\n                  configurable: true,\r\n                  get: () => instance.props[key],\r\n                  set: NOOP\r\n              });\r\n          });\r\n      }\r\n  }\r\n  // dev only\r\n  function exposeSetupStateOnRenderContext(instance) {\r\n      const { ctx, setupState } = instance;\r\n      Object.keys(toRaw(setupState)).forEach(key => {\r\n          if (!setupState.__isScriptSetup) {\r\n              if (key[0] === '$' || key[0] === '_') {\r\n                  warn$1(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` +\r\n                      `which are reserved prefixes for Vue internals.`);\r\n                  return;\r\n              }\r\n              Object.defineProperty(ctx, key, {\r\n                  enumerable: true,\r\n                  configurable: true,\r\n                  get: () => setupState[key],\r\n                  set: NOOP\r\n              });\r\n          }\r\n      });\r\n  }\n\n  const emptyAppContext = createAppContext();\r\n  let uid$1 = 0;\r\n  function createComponentInstance(vnode, parent, suspense) {\r\n      const type = vnode.type;\r\n      // inherit parent app context - or - if root, adopt from root vnode\r\n      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n      const instance = {\r\n          uid: uid$1++,\r\n          vnode,\r\n          type,\r\n          parent,\r\n          appContext,\r\n          root: null,\r\n          next: null,\r\n          subTree: null,\r\n          effect: null,\r\n          update: null,\r\n          scope: new EffectScope(true /* detached */),\r\n          render: null,\r\n          proxy: null,\r\n          exposed: null,\r\n          exposeProxy: null,\r\n          withProxy: null,\r\n          provides: parent ? parent.provides : Object.create(appContext.provides),\r\n          accessCache: null,\r\n          renderCache: [],\r\n          // local resovled assets\r\n          components: null,\r\n          directives: null,\r\n          // resolved props and emits options\r\n          propsOptions: normalizePropsOptions(type, appContext),\r\n          emitsOptions: normalizeEmitsOptions(type, appContext),\r\n          // emit\r\n          emit: null,\r\n          emitted: null,\r\n          // props default value\r\n          propsDefaults: EMPTY_OBJ,\r\n          // inheritAttrs\r\n          inheritAttrs: type.inheritAttrs,\r\n          // state\r\n          ctx: EMPTY_OBJ,\r\n          data: EMPTY_OBJ,\r\n          props: EMPTY_OBJ,\r\n          attrs: EMPTY_OBJ,\r\n          slots: EMPTY_OBJ,\r\n          refs: EMPTY_OBJ,\r\n          setupState: EMPTY_OBJ,\r\n          setupContext: null,\r\n          // suspense related\r\n          suspense,\r\n          suspenseId: suspense ? suspense.pendingId : 0,\r\n          asyncDep: null,\r\n          asyncResolved: false,\r\n          // lifecycle hooks\r\n          // not using enums here because it results in computed properties\r\n          isMounted: false,\r\n          isUnmounted: false,\r\n          isDeactivated: false,\r\n          bc: null,\r\n          c: null,\r\n          bm: null,\r\n          m: null,\r\n          bu: null,\r\n          u: null,\r\n          um: null,\r\n          bum: null,\r\n          da: null,\r\n          a: null,\r\n          rtg: null,\r\n          rtc: null,\r\n          ec: null,\r\n          sp: null\r\n      };\r\n      {\r\n          instance.ctx = createDevRenderContext(instance);\r\n      }\r\n      instance.root = parent ? parent.root : instance;\r\n      instance.emit = emit$1.bind(null, instance);\r\n      // apply custom element special handling\r\n      if (vnode.ce) {\r\n          vnode.ce(instance);\r\n      }\r\n      return instance;\r\n  }\r\n  let currentInstance = null;\r\n  const getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\n  const setCurrentInstance = (instance) => {\r\n      currentInstance = instance;\r\n      instance.scope.on();\r\n  };\r\n  const unsetCurrentInstance = () => {\r\n      currentInstance && currentInstance.scope.off();\r\n      currentInstance = null;\r\n  };\r\n  const isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');\r\n  function validateComponentName(name, config) {\r\n      const appIsNativeTag = config.isNativeTag || NO;\r\n      if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n          warn$1('Do not use built-in or reserved HTML elements as component id: ' + name);\r\n      }\r\n  }\r\n  function isStatefulComponent(instance) {\r\n      return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n  }\r\n  let isInSSRComponentSetup = false;\r\n  function setupComponent(instance, isSSR = false) {\r\n      isInSSRComponentSetup = isSSR;\r\n      const { props, children } = instance.vnode;\r\n      const isStateful = isStatefulComponent(instance);\r\n      initProps(instance, props, isStateful, isSSR);\r\n      initSlots(instance, children);\r\n      const setupResult = isStateful\r\n          ? setupStatefulComponent(instance, isSSR)\r\n          : undefined;\r\n      isInSSRComponentSetup = false;\r\n      return setupResult;\r\n  }\r\n  function setupStatefulComponent(instance, isSSR) {\r\n      const Component = instance.type;\r\n      {\r\n          if (Component.name) {\r\n              validateComponentName(Component.name, instance.appContext.config);\r\n          }\r\n          if (Component.components) {\r\n              const names = Object.keys(Component.components);\r\n              for (let i = 0; i < names.length; i++) {\r\n                  validateComponentName(names[i], instance.appContext.config);\r\n              }\r\n          }\r\n          if (Component.directives) {\r\n              const names = Object.keys(Component.directives);\r\n              for (let i = 0; i < names.length; i++) {\r\n                  validateDirectiveName(names[i]);\r\n              }\r\n          }\r\n          if (Component.compilerOptions && isRuntimeOnly()) {\r\n              warn$1(`\"compilerOptions\" is only supported when using a build of Vue that ` +\r\n                  `includes the runtime compiler. Since you are using a runtime-only ` +\r\n                  `build, the options should be passed via your build tool config instead.`);\r\n          }\r\n      }\r\n      // 0. create render proxy property access cache\r\n      instance.accessCache = Object.create(null);\r\n      // 1. create public instance / render proxy\r\n      // also mark it raw so it's never observed\r\n      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\r\n      {\r\n          exposePropsOnRenderContext(instance);\r\n      }\r\n      // 2. call setup()\r\n      const { setup } = Component;\r\n      if (setup) {\r\n          const setupContext = (instance.setupContext =\r\n              setup.length > 1 ? createSetupContext(instance) : null);\r\n          setCurrentInstance(instance);\r\n          pauseTracking();\r\n          const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [shallowReadonly(instance.props) , setupContext]);\r\n          resetTracking();\r\n          unsetCurrentInstance();\r\n          if (isPromise(setupResult)) {\r\n              setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\r\n              if (isSSR) {\r\n                  // return the promise so server-renderer can wait on it\r\n                  return setupResult\r\n                      .then((resolvedResult) => {\r\n                      handleSetupResult(instance, resolvedResult, isSSR);\r\n                  })\r\n                      .catch(e => {\r\n                      handleError(e, instance, 0 /* SETUP_FUNCTION */);\r\n                  });\r\n              }\r\n              else {\r\n                  // async setup returned Promise.\r\n                  // bail here and wait for re-entry.\r\n                  instance.asyncDep = setupResult;\r\n              }\r\n          }\r\n          else {\r\n              handleSetupResult(instance, setupResult, isSSR);\r\n          }\r\n      }\r\n      else {\r\n          finishComponentSetup(instance, isSSR);\r\n      }\r\n  }\r\n  function handleSetupResult(instance, setupResult, isSSR) {\r\n      if (isFunction(setupResult)) {\r\n          // setup returned an inline render function\r\n          {\r\n              instance.render = setupResult;\r\n          }\r\n      }\r\n      else if (isObject(setupResult)) {\r\n          if (isVNode(setupResult)) {\r\n              warn$1(`setup() should not return VNodes directly - ` +\r\n                  `return a render function instead.`);\r\n          }\r\n          // setup returned bindings.\r\n          // assuming a render function compiled from template is present.\r\n          {\r\n              instance.devtoolsRawSetupState = setupResult;\r\n          }\r\n          instance.setupState = proxyRefs(setupResult);\r\n          {\r\n              exposeSetupStateOnRenderContext(instance);\r\n          }\r\n      }\r\n      else if (setupResult !== undefined) {\r\n          warn$1(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\r\n      }\r\n      finishComponentSetup(instance, isSSR);\r\n  }\r\n  let compile;\r\n  let installWithProxy;\r\n  /**\r\n   * For runtime-dom to register the compiler.\r\n   * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n   */\r\n  function registerRuntimeCompiler(_compile) {\r\n      compile = _compile;\r\n      installWithProxy = i => {\r\n          if (i.render._rc) {\r\n              i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n          }\r\n      };\r\n  }\r\n  // dev only\r\n  const isRuntimeOnly = () => !compile;\r\n  function finishComponentSetup(instance, isSSR, skipOptions) {\r\n      const Component = instance.type;\r\n      // template / render function normalization\r\n      // could be already set when returned from setup()\r\n      if (!instance.render) {\r\n          // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\r\n          // is done by server-renderer\r\n          if (!isSSR && compile && !Component.render) {\r\n              const template = Component.template;\r\n              if (template) {\r\n                  {\r\n                      startMeasure(instance, `compile`);\r\n                  }\r\n                  const { isCustomElement, compilerOptions } = instance.appContext.config;\r\n                  const { delimiters, compilerOptions: componentCompilerOptions } = Component;\r\n                  const finalCompilerOptions = extend(extend({\r\n                      isCustomElement,\r\n                      delimiters\r\n                  }, compilerOptions), componentCompilerOptions);\r\n                  Component.render = compile(template, finalCompilerOptions);\r\n                  {\r\n                      endMeasure(instance, `compile`);\r\n                  }\r\n              }\r\n          }\r\n          instance.render = (Component.render || NOOP);\r\n          // for runtime-compiled render functions using `with` blocks, the render\r\n          // proxy used needs a different `has` handler which is more performant and\r\n          // also only allows a whitelist of globals to fallthrough.\r\n          if (installWithProxy) {\r\n              installWithProxy(instance);\r\n          }\r\n      }\r\n      // support for 2.x options\r\n      {\r\n          setCurrentInstance(instance);\r\n          pauseTracking();\r\n          applyOptions(instance);\r\n          resetTracking();\r\n          unsetCurrentInstance();\r\n      }\r\n      // warn missing template/render\r\n      // the runtime compilation of template in SSR is done by server-render\r\n      if (!Component.render && instance.render === NOOP && !isSSR) {\r\n          /* istanbul ignore if */\r\n          if (!compile && Component.template) {\r\n              warn$1(`Component provided template option but ` +\r\n                  `runtime compilation is not supported in this build of Vue.` +\r\n                  (` Use \"vue.global.js\" instead.`\r\n                              ) /* should not happen */);\r\n          }\r\n          else {\r\n              warn$1(`Component is missing template or render function.`);\r\n          }\r\n      }\r\n  }\r\n  function createAttrsProxy(instance) {\r\n      return new Proxy(instance.attrs, {\r\n              get(target, key) {\r\n                  markAttrsAccessed();\r\n                  track(instance, \"get\" /* GET */, '$attrs');\r\n                  return target[key];\r\n              },\r\n              set() {\r\n                  warn$1(`setupContext.attrs is readonly.`);\r\n                  return false;\r\n              },\r\n              deleteProperty() {\r\n                  warn$1(`setupContext.attrs is readonly.`);\r\n                  return false;\r\n              }\r\n          }\r\n          );\r\n  }\r\n  function createSetupContext(instance) {\r\n      const expose = exposed => {\r\n          if (instance.exposed) {\r\n              warn$1(`expose() should be called only once per setup().`);\r\n          }\r\n          instance.exposed = exposed || {};\r\n      };\r\n      let attrs;\r\n      {\r\n          // We use getters in dev in case libs like test-utils overwrite instance\r\n          // properties (overwrites should not be done in prod)\r\n          return Object.freeze({\r\n              get attrs() {\r\n                  return attrs || (attrs = createAttrsProxy(instance));\r\n              },\r\n              get slots() {\r\n                  return shallowReadonly(instance.slots);\r\n              },\r\n              get emit() {\r\n                  return (event, ...args) => instance.emit(event, ...args);\r\n              },\r\n              expose\r\n          });\r\n      }\r\n  }\r\n  function getExposeProxy(instance) {\r\n      if (instance.exposed) {\r\n          return (instance.exposeProxy ||\r\n              (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\r\n                  get(target, key) {\r\n                      if (key in target) {\r\n                          return target[key];\r\n                      }\r\n                      else if (key in publicPropertiesMap) {\r\n                          return publicPropertiesMap[key](instance);\r\n                      }\r\n                  }\r\n              })));\r\n      }\r\n  }\r\n  const classifyRE = /(?:^|[-_])(\\w)/g;\r\n  const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\n  function getComponentName(Component) {\r\n      return isFunction(Component)\r\n          ? Component.displayName || Component.name\r\n          : Component.name;\r\n  }\r\n  /* istanbul ignore next */\r\n  function formatComponentName(instance, Component, isRoot = false) {\r\n      let name = getComponentName(Component);\r\n      if (!name && Component.__file) {\r\n          const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n          if (match) {\r\n              name = match[1];\r\n          }\r\n      }\r\n      if (!name && instance && instance.parent) {\r\n          // try to infer the name based on reverse resolution\r\n          const inferFromRegistry = (registry) => {\r\n              for (const key in registry) {\r\n                  if (registry[key] === Component) {\r\n                      return key;\r\n                  }\r\n              }\r\n          };\r\n          name =\r\n              inferFromRegistry(instance.components ||\r\n                  instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n      }\r\n      return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n  }\r\n  function isClassComponent(value) {\r\n      return isFunction(value) && '__vccOpts' in value;\r\n  }\n\n  const computed$1 = ((getterOrOptions, debugOptions) => {\r\n      // @ts-ignore\r\n      return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);\r\n  });\n\n  // dev only\r\n  const warnRuntimeUsage = (method) => warn$1(`${method}() is a compiler-hint helper that is only usable inside ` +\r\n      `<script setup> of a single file component. Its arguments should be ` +\r\n      `compiled away and passing it at runtime has no effect.`);\r\n  // implementation\r\n  function defineProps() {\r\n      {\r\n          warnRuntimeUsage(`defineProps`);\r\n      }\r\n      return null;\r\n  }\r\n  // implementation\r\n  function defineEmits() {\r\n      {\r\n          warnRuntimeUsage(`defineEmits`);\r\n      }\r\n      return null;\r\n  }\r\n  /**\r\n   * Vue `<script setup>` compiler macro for declaring a component's exposed\r\n   * instance properties when it is accessed by a parent component via template\r\n   * refs.\r\n   *\r\n   * `<script setup>` components are closed by default - i.e. variables inside\r\n   * the `<script setup>` scope is not exposed to parent unless explicitly exposed\r\n   * via `defineExpose`.\r\n   *\r\n   * This is only usable inside `<script setup>`, is compiled away in the\r\n   * output and should **not** be actually called at runtime.\r\n   */\r\n  function defineExpose(exposed) {\r\n      {\r\n          warnRuntimeUsage(`defineExpose`);\r\n      }\r\n  }\r\n  /**\r\n   * Vue `<script setup>` compiler macro for providing props default values when\r\n   * using type-based `defineProps` declaration.\r\n   *\r\n   * Example usage:\r\n   * ```ts\r\n   * withDefaults(defineProps<{\r\n   *   size?: number\r\n   *   labels?: string[]\r\n   * }>(), {\r\n   *   size: 3,\r\n   *   labels: () => ['default label']\r\n   * })\r\n   * ```\r\n   *\r\n   * This is only usable inside `<script setup>`, is compiled away in the output\r\n   * and should **not** be actually called at runtime.\r\n   */\r\n  function withDefaults(props, defaults) {\r\n      {\r\n          warnRuntimeUsage(`withDefaults`);\r\n      }\r\n      return null;\r\n  }\r\n  function useSlots() {\r\n      return getContext().slots;\r\n  }\r\n  function useAttrs() {\r\n      return getContext().attrs;\r\n  }\r\n  function getContext() {\r\n      const i = getCurrentInstance();\r\n      if (!i) {\r\n          warn$1(`useContext() called without active instance.`);\r\n      }\r\n      return i.setupContext || (i.setupContext = createSetupContext(i));\r\n  }\r\n  /**\r\n   * Runtime helper for merging default declarations. Imported by compiled code\r\n   * only.\r\n   * @internal\r\n   */\r\n  function mergeDefaults(raw, defaults) {\r\n      const props = isArray(raw)\r\n          ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})\r\n          : raw;\r\n      for (const key in defaults) {\r\n          const opt = props[key];\r\n          if (opt) {\r\n              if (isArray(opt) || isFunction(opt)) {\r\n                  props[key] = { type: opt, default: defaults[key] };\r\n              }\r\n              else {\r\n                  opt.default = defaults[key];\r\n              }\r\n          }\r\n          else if (opt === null) {\r\n              props[key] = { default: defaults[key] };\r\n          }\r\n          else {\r\n              warn$1(`props default key \"${key}\" has no corresponding declaration.`);\r\n          }\r\n      }\r\n      return props;\r\n  }\r\n  /**\r\n   * Used to create a proxy for the rest element when destructuring props with\r\n   * defineProps().\r\n   * @internal\r\n   */\r\n  function createPropsRestProxy(props, excludedKeys) {\r\n      const ret = {};\r\n      for (const key in props) {\r\n          if (!excludedKeys.includes(key)) {\r\n              Object.defineProperty(ret, key, {\r\n                  enumerable: true,\r\n                  get: () => props[key]\r\n              });\r\n          }\r\n      }\r\n      return ret;\r\n  }\r\n  /**\r\n   * `<script setup>` helper for persisting the current instance context over\r\n   * async/await flows.\r\n   *\r\n   * `@vue/compiler-sfc` converts the following:\r\n   *\r\n   * ```ts\r\n   * const x = await foo()\r\n   * ```\r\n   *\r\n   * into:\r\n   *\r\n   * ```ts\r\n   * let __temp, __restore\r\n   * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\r\n   * ```\r\n   * @internal\r\n   */\r\n  function withAsyncContext(getAwaitable) {\r\n      const ctx = getCurrentInstance();\r\n      if (!ctx) {\r\n          warn$1(`withAsyncContext called without active current instance. ` +\r\n              `This is likely a bug.`);\r\n      }\r\n      let awaitable = getAwaitable();\r\n      unsetCurrentInstance();\r\n      if (isPromise(awaitable)) {\r\n          awaitable = awaitable.catch(e => {\r\n              setCurrentInstance(ctx);\r\n              throw e;\r\n          });\r\n      }\r\n      return [awaitable, () => setCurrentInstance(ctx)];\r\n  }\n\n  // Actual implementation\r\n  function h(type, propsOrChildren, children) {\r\n      const l = arguments.length;\r\n      if (l === 2) {\r\n          if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\r\n              // single vnode without props\r\n              if (isVNode(propsOrChildren)) {\r\n                  return createVNode(type, null, [propsOrChildren]);\r\n              }\r\n              // props without children\r\n              return createVNode(type, propsOrChildren);\r\n          }\r\n          else {\r\n              // omit props\r\n              return createVNode(type, null, propsOrChildren);\r\n          }\r\n      }\r\n      else {\r\n          if (l > 3) {\r\n              children = Array.prototype.slice.call(arguments, 2);\r\n          }\r\n          else if (l === 3 && isVNode(children)) {\r\n              children = [children];\r\n          }\r\n          return createVNode(type, propsOrChildren, children);\r\n      }\r\n  }\n\n  const ssrContextKey = Symbol(`ssrContext` );\r\n  const useSSRContext = () => {\r\n      {\r\n          warn$1(`useSSRContext() is not supported in the global build.`);\r\n      }\r\n  };\n\n  function initCustomFormatter() {\r\n      /* eslint-disable no-restricted-globals */\r\n      if (typeof window === 'undefined') {\r\n          return;\r\n      }\r\n      const vueStyle = { style: 'color:#3ba776' };\r\n      const numberStyle = { style: 'color:#0b1bc9' };\r\n      const stringStyle = { style: 'color:#b62e24' };\r\n      const keywordStyle = { style: 'color:#9d288c' };\r\n      // custom formatter for Chrome\r\n      // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n      const formatter = {\r\n          header(obj) {\r\n              // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n              if (!isObject(obj)) {\r\n                  return null;\r\n              }\r\n              if (obj.__isVue) {\r\n                  return ['div', vueStyle, `VueInstance`];\r\n              }\r\n              else if (isRef(obj)) {\r\n                  return [\r\n                      'div',\r\n                      {},\r\n                      ['span', vueStyle, genRefFlag(obj)],\r\n                      '<',\r\n                      formatValue(obj.value),\r\n                      `>`\r\n                  ];\r\n              }\r\n              else if (isReactive(obj)) {\r\n                  return [\r\n                      'div',\r\n                      {},\r\n                      ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],\r\n                      '<',\r\n                      formatValue(obj),\r\n                      `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                  ];\r\n              }\r\n              else if (isReadonly(obj)) {\r\n                  return [\r\n                      'div',\r\n                      {},\r\n                      ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],\r\n                      '<',\r\n                      formatValue(obj),\r\n                      '>'\r\n                  ];\r\n              }\r\n              return null;\r\n          },\r\n          hasBody(obj) {\r\n              return obj && obj.__isVue;\r\n          },\r\n          body(obj) {\r\n              if (obj && obj.__isVue) {\r\n                  return [\r\n                      'div',\r\n                      {},\r\n                      ...formatInstance(obj.$)\r\n                  ];\r\n              }\r\n          }\r\n      };\r\n      function formatInstance(instance) {\r\n          const blocks = [];\r\n          if (instance.type.props && instance.props) {\r\n              blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n          }\r\n          if (instance.setupState !== EMPTY_OBJ) {\r\n              blocks.push(createInstanceBlock('setup', instance.setupState));\r\n          }\r\n          if (instance.data !== EMPTY_OBJ) {\r\n              blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n          }\r\n          const computed = extractKeys(instance, 'computed');\r\n          if (computed) {\r\n              blocks.push(createInstanceBlock('computed', computed));\r\n          }\r\n          const injected = extractKeys(instance, 'inject');\r\n          if (injected) {\r\n              blocks.push(createInstanceBlock('injected', injected));\r\n          }\r\n          blocks.push([\r\n              'div',\r\n              {},\r\n              [\r\n                  'span',\r\n                  {\r\n                      style: keywordStyle.style + ';opacity:0.66'\r\n                  },\r\n                  '$ (internal): '\r\n              ],\r\n              ['object', { object: instance }]\r\n          ]);\r\n          return blocks;\r\n      }\r\n      function createInstanceBlock(type, target) {\r\n          target = extend({}, target);\r\n          if (!Object.keys(target).length) {\r\n              return ['span', {}];\r\n          }\r\n          return [\r\n              'div',\r\n              { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n              [\r\n                  'div',\r\n                  {\r\n                      style: 'color:#476582'\r\n                  },\r\n                  type\r\n              ],\r\n              [\r\n                  'div',\r\n                  {\r\n                      style: 'padding-left:1.25em'\r\n                  },\r\n                  ...Object.keys(target).map(key => {\r\n                      return [\r\n                          'div',\r\n                          {},\r\n                          ['span', keywordStyle, key + ': '],\r\n                          formatValue(target[key], false)\r\n                      ];\r\n                  })\r\n              ]\r\n          ];\r\n      }\r\n      function formatValue(v, asRaw = true) {\r\n          if (typeof v === 'number') {\r\n              return ['span', numberStyle, v];\r\n          }\r\n          else if (typeof v === 'string') {\r\n              return ['span', stringStyle, JSON.stringify(v)];\r\n          }\r\n          else if (typeof v === 'boolean') {\r\n              return ['span', keywordStyle, v];\r\n          }\r\n          else if (isObject(v)) {\r\n              return ['object', { object: asRaw ? toRaw(v) : v }];\r\n          }\r\n          else {\r\n              return ['span', stringStyle, String(v)];\r\n          }\r\n      }\r\n      function extractKeys(instance, type) {\r\n          const Comp = instance.type;\r\n          if (isFunction(Comp)) {\r\n              return;\r\n          }\r\n          const extracted = {};\r\n          for (const key in instance.ctx) {\r\n              if (isKeyOfType(Comp, key, type)) {\r\n                  extracted[key] = instance.ctx[key];\r\n              }\r\n          }\r\n          return extracted;\r\n      }\r\n      function isKeyOfType(Comp, key, type) {\r\n          const opts = Comp[type];\r\n          if ((isArray(opts) && opts.includes(key)) ||\r\n              (isObject(opts) && key in opts)) {\r\n              return true;\r\n          }\r\n          if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n              return true;\r\n          }\r\n          if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n              return true;\r\n          }\r\n      }\r\n      function genRefFlag(v) {\r\n          if (isShallow(v)) {\r\n              return `ShallowRef`;\r\n          }\r\n          if (v.effect) {\r\n              return `ComputedRef`;\r\n          }\r\n          return `Ref`;\r\n      }\r\n      if (window.devtoolsFormatters) {\r\n          window.devtoolsFormatters.push(formatter);\r\n      }\r\n      else {\r\n          window.devtoolsFormatters = [formatter];\r\n      }\r\n  }\n\n  function withMemo(memo, render, cache, index) {\r\n      const cached = cache[index];\r\n      if (cached && isMemoSame(cached, memo)) {\r\n          return cached;\r\n      }\r\n      const ret = render();\r\n      // shallow clone\r\n      ret.memo = memo.slice();\r\n      return (cache[index] = ret);\r\n  }\r\n  function isMemoSame(cached, memo) {\r\n      const prev = cached.memo;\r\n      if (prev.length != memo.length) {\r\n          return false;\r\n      }\r\n      for (let i = 0; i < prev.length; i++) {\r\n          if (prev[i] !== memo[i]) {\r\n              return false;\r\n          }\r\n      }\r\n      // make sure to let parent block track it when returning cached\r\n      if (isBlockTreeEnabled > 0 && currentBlock) {\r\n          currentBlock.push(cached);\r\n      }\r\n      return true;\r\n  }\n\n  // Core API ------------------------------------------------------------------\r\n  const version = \"3.2.31\";\r\n  /**\r\n   * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n   * @internal\r\n   */\r\n  const ssrUtils = (null);\r\n  /**\r\n   * @internal only exposed in compat builds\r\n   */\r\n  const resolveFilter = null;\r\n  /**\r\n   * @internal only exposed in compat builds.\r\n   */\r\n  const compatUtils = (null);\n\n  const svgNS = 'http://www.w3.org/2000/svg';\r\n  const doc = (typeof document !== 'undefined' ? document : null);\r\n  const templateContainer = doc && doc.createElement('template');\r\n  const nodeOps = {\r\n      insert: (child, parent, anchor) => {\r\n          parent.insertBefore(child, anchor || null);\r\n      },\r\n      remove: child => {\r\n          const parent = child.parentNode;\r\n          if (parent) {\r\n              parent.removeChild(child);\r\n          }\r\n      },\r\n      createElement: (tag, isSVG, is, props) => {\r\n          const el = isSVG\r\n              ? doc.createElementNS(svgNS, tag)\r\n              : doc.createElement(tag, is ? { is } : undefined);\r\n          if (tag === 'select' && props && props.multiple != null) {\r\n              el.setAttribute('multiple', props.multiple);\r\n          }\r\n          return el;\r\n      },\r\n      createText: text => doc.createTextNode(text),\r\n      createComment: text => doc.createComment(text),\r\n      setText: (node, text) => {\r\n          node.nodeValue = text;\r\n      },\r\n      setElementText: (el, text) => {\r\n          el.textContent = text;\r\n      },\r\n      parentNode: node => node.parentNode,\r\n      nextSibling: node => node.nextSibling,\r\n      querySelector: selector => doc.querySelector(selector),\r\n      setScopeId(el, id) {\r\n          el.setAttribute(id, '');\r\n      },\r\n      cloneNode(el) {\r\n          const cloned = el.cloneNode(true);\r\n          // #3072\r\n          // - in `patchDOMProp`, we store the actual value in the `el._value` property.\r\n          // - normally, elements using `:value` bindings will not be hoisted, but if\r\n          //   the bound value is a constant, e.g. `:value=\"true\"` - they do get\r\n          //   hoisted.\r\n          // - in production, hoisted nodes are cloned when subsequent inserts, but\r\n          //   cloneNode() does not copy the custom property we attached.\r\n          // - This may need to account for other custom DOM properties we attach to\r\n          //   elements in addition to `_value` in the future.\r\n          if (`_value` in el) {\r\n              cloned._value = el._value;\r\n          }\r\n          return cloned;\r\n      },\r\n      // __UNSAFE__\r\n      // Reason: innerHTML.\r\n      // Static content here can only come from compiled templates.\r\n      // As long as the user only uses trusted templates, this is safe.\r\n      insertStaticContent(content, parent, anchor, isSVG, start, end) {\r\n          // <parent> before | first ... last | anchor </parent>\r\n          const before = anchor ? anchor.previousSibling : parent.lastChild;\r\n          // #5308 can only take cached path if:\r\n          // - has a single root node\r\n          // - nextSibling info is still available\r\n          if (start && (start === end || start.nextSibling)) {\r\n              // cached\r\n              while (true) {\r\n                  parent.insertBefore(start.cloneNode(true), anchor);\r\n                  if (start === end || !(start = start.nextSibling))\r\n                      break;\r\n              }\r\n          }\r\n          else {\r\n              // fresh insert\r\n              templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\r\n              const template = templateContainer.content;\r\n              if (isSVG) {\r\n                  // remove outer svg wrapper\r\n                  const wrapper = template.firstChild;\r\n                  while (wrapper.firstChild) {\r\n                      template.appendChild(wrapper.firstChild);\r\n                  }\r\n                  template.removeChild(wrapper);\r\n              }\r\n              parent.insertBefore(template, anchor);\r\n          }\r\n          return [\r\n              // first\r\n              before ? before.nextSibling : parent.firstChild,\r\n              // last\r\n              anchor ? anchor.previousSibling : parent.lastChild\r\n          ];\r\n      }\r\n  };\n\n  // compiler should normalize class + :class bindings on the same element\r\n  // into a single binding ['staticClass', dynamic]\r\n  function patchClass(el, value, isSVG) {\r\n      // directly setting className should be faster than setAttribute in theory\r\n      // if this is an element during a transition, take the temporary transition\r\n      // classes into account.\r\n      const transitionClasses = el._vtc;\r\n      if (transitionClasses) {\r\n          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\r\n      }\r\n      if (value == null) {\r\n          el.removeAttribute('class');\r\n      }\r\n      else if (isSVG) {\r\n          el.setAttribute('class', value);\r\n      }\r\n      else {\r\n          el.className = value;\r\n      }\r\n  }\n\n  function patchStyle(el, prev, next) {\r\n      const style = el.style;\r\n      const isCssString = isString(next);\r\n      if (next && !isCssString) {\r\n          for (const key in next) {\r\n              setStyle(style, key, next[key]);\r\n          }\r\n          if (prev && !isString(prev)) {\r\n              for (const key in prev) {\r\n                  if (next[key] == null) {\r\n                      setStyle(style, key, '');\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          const currentDisplay = style.display;\r\n          if (isCssString) {\r\n              if (prev !== next) {\r\n                  style.cssText = next;\r\n              }\r\n          }\r\n          else if (prev) {\r\n              el.removeAttribute('style');\r\n          }\r\n          // indicates that the `display` of the element is controlled by `v-show`,\r\n          // so we always keep the current `display` value regardless of the `style`\r\n          // value, thus handing over control to `v-show`.\r\n          if ('_vod' in el) {\r\n              style.display = currentDisplay;\r\n          }\r\n      }\r\n  }\r\n  const importantRE = /\\s*!important$/;\r\n  function setStyle(style, name, val) {\r\n      if (isArray(val)) {\r\n          val.forEach(v => setStyle(style, name, v));\r\n      }\r\n      else {\r\n          if (name.startsWith('--')) {\r\n              // custom property definition\r\n              style.setProperty(name, val);\r\n          }\r\n          else {\r\n              const prefixed = autoPrefix(style, name);\r\n              if (importantRE.test(val)) {\r\n                  // !important\r\n                  style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');\r\n              }\r\n              else {\r\n                  style[prefixed] = val;\r\n              }\r\n          }\r\n      }\r\n  }\r\n  const prefixes = ['Webkit', 'Moz', 'ms'];\r\n  const prefixCache = {};\r\n  function autoPrefix(style, rawName) {\r\n      const cached = prefixCache[rawName];\r\n      if (cached) {\r\n          return cached;\r\n      }\r\n      let name = camelize(rawName);\r\n      if (name !== 'filter' && name in style) {\r\n          return (prefixCache[rawName] = name);\r\n      }\r\n      name = capitalize(name);\r\n      for (let i = 0; i < prefixes.length; i++) {\r\n          const prefixed = prefixes[i] + name;\r\n          if (prefixed in style) {\r\n              return (prefixCache[rawName] = prefixed);\r\n          }\r\n      }\r\n      return rawName;\r\n  }\n\n  const xlinkNS = 'http://www.w3.org/1999/xlink';\r\n  function patchAttr(el, key, value, isSVG, instance) {\r\n      if (isSVG && key.startsWith('xlink:')) {\r\n          if (value == null) {\r\n              el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n          }\r\n          else {\r\n              el.setAttributeNS(xlinkNS, key, value);\r\n          }\r\n      }\r\n      else {\r\n          // note we are only checking boolean attributes that don't have a\r\n          // corresponding dom prop of the same name here.\r\n          const isBoolean = isSpecialBooleanAttr(key);\r\n          if (value == null || (isBoolean && !includeBooleanAttr(value))) {\r\n              el.removeAttribute(key);\r\n          }\r\n          else {\r\n              el.setAttribute(key, isBoolean ? '' : value);\r\n          }\r\n      }\r\n  }\n\n  // __UNSAFE__\r\n  // functions. The user is responsible for using them with only trusted content.\r\n  function patchDOMProp(el, key, value, \r\n  // the following args are passed only due to potential innerHTML/textContent\r\n  // overriding existing VNodes, in which case the old tree must be properly\r\n  // unmounted.\r\n  prevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n      if (key === 'innerHTML' || key === 'textContent') {\r\n          if (prevChildren) {\r\n              unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n          }\r\n          el[key] = value == null ? '' : value;\r\n          return;\r\n      }\r\n      if (key === 'value' &&\r\n          el.tagName !== 'PROGRESS' &&\r\n          // custom elements may use _value internally\r\n          !el.tagName.includes('-')) {\r\n          // store value as _value as well since\r\n          // non-string values will be stringified.\r\n          el._value = value;\r\n          const newValue = value == null ? '' : value;\r\n          if (el.value !== newValue ||\r\n              // #4956: always set for OPTION elements because its value falls back to\r\n              // textContent if no value attribute is present. And setting .value for\r\n              // OPTION has no side effect\r\n              el.tagName === 'OPTION') {\r\n              el.value = newValue;\r\n          }\r\n          if (value == null) {\r\n              el.removeAttribute(key);\r\n          }\r\n          return;\r\n      }\r\n      if (value === '' || value == null) {\r\n          const type = typeof el[key];\r\n          if (type === 'boolean') {\r\n              // e.g. <select multiple> compiles to { multiple: '' }\r\n              el[key] = includeBooleanAttr(value);\r\n              return;\r\n          }\r\n          else if (value == null && type === 'string') {\r\n              // e.g. <div :id=\"null\">\r\n              el[key] = '';\r\n              el.removeAttribute(key);\r\n              return;\r\n          }\r\n          else if (type === 'number') {\r\n              // e.g. <img :width=\"null\">\r\n              // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error\r\n              try {\r\n                  el[key] = 0;\r\n              }\r\n              catch (_a) { }\r\n              el.removeAttribute(key);\r\n              return;\r\n          }\r\n      }\r\n      // some properties perform value validation and throw\r\n      try {\r\n          el[key] = value;\r\n      }\r\n      catch (e) {\r\n          {\r\n              warn$1(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\r\n                  `value ${value} is invalid.`, e);\r\n          }\r\n      }\r\n  }\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\r\n  let _getNow = Date.now;\r\n  let skipTimestampCheck = false;\r\n  if (typeof window !== 'undefined') {\r\n      // Determine what event timestamp the browser is using. Annoyingly, the\r\n      // timestamp can either be hi-res (relative to page load) or low-res\r\n      // (relative to UNIX epoch), so in order to compare time we have to use the\r\n      // same timestamp type when saving the flush timestamp.\r\n      if (_getNow() > document.createEvent('Event').timeStamp) {\r\n          // if the low-res timestamp which is bigger than the event timestamp\r\n          // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n          // and we need to use the hi-res version for event listeners as well.\r\n          _getNow = () => performance.now();\r\n      }\r\n      // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation\r\n      // and does not fire microtasks in between event propagation, so safe to exclude.\r\n      const ffMatch = navigator.userAgent.match(/firefox\\/(\\d+)/i);\r\n      skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);\r\n  }\r\n  // To avoid the overhead of repeatedly calling performance.now(), we cache\r\n  // and use the same timestamp for all event listeners attached in the same tick.\r\n  let cachedNow = 0;\r\n  const p = Promise.resolve();\r\n  const reset = () => {\r\n      cachedNow = 0;\r\n  };\r\n  const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\n  function addEventListener(el, event, handler, options) {\r\n      el.addEventListener(event, handler, options);\r\n  }\r\n  function removeEventListener(el, event, handler, options) {\r\n      el.removeEventListener(event, handler, options);\r\n  }\r\n  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n      // vei = vue event invokers\r\n      const invokers = el._vei || (el._vei = {});\r\n      const existingInvoker = invokers[rawName];\r\n      if (nextValue && existingInvoker) {\r\n          // patch\r\n          existingInvoker.value = nextValue;\r\n      }\r\n      else {\r\n          const [name, options] = parseName(rawName);\r\n          if (nextValue) {\r\n              // add\r\n              const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n              addEventListener(el, name, invoker, options);\r\n          }\r\n          else if (existingInvoker) {\r\n              // remove\r\n              removeEventListener(el, name, existingInvoker, options);\r\n              invokers[rawName] = undefined;\r\n          }\r\n      }\r\n  }\r\n  const optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\n  function parseName(name) {\r\n      let options;\r\n      if (optionsModifierRE.test(name)) {\r\n          options = {};\r\n          let m;\r\n          while ((m = name.match(optionsModifierRE))) {\r\n              name = name.slice(0, name.length - m[0].length);\r\n              options[m[0].toLowerCase()] = true;\r\n          }\r\n      }\r\n      return [hyphenate(name.slice(2)), options];\r\n  }\r\n  function createInvoker(initialValue, instance) {\r\n      const invoker = (e) => {\r\n          // async edge case #6566: inner click event triggers patch, event handler\r\n          // attached to outer element during patch, and triggered again. This\r\n          // happens because browsers fire microtask ticks between event propagation.\r\n          // the solution is simple: we save the timestamp when a handler is attached,\r\n          // and the handler would only fire if the event passed to it was fired\r\n          // AFTER it was attached.\r\n          const timeStamp = e.timeStamp || _getNow();\r\n          if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {\r\n              callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n          }\r\n      };\r\n      invoker.value = initialValue;\r\n      invoker.attached = getNow();\r\n      return invoker;\r\n  }\r\n  function patchStopImmediatePropagation(e, value) {\r\n      if (isArray(value)) {\r\n          const originalStop = e.stopImmediatePropagation;\r\n          e.stopImmediatePropagation = () => {\r\n              originalStop.call(e);\r\n              e._stopped = true;\r\n          };\r\n          return value.map(fn => (e) => !e._stopped && fn && fn(e));\r\n      }\r\n      else {\r\n          return value;\r\n      }\r\n  }\n\n  const nativeOnRE = /^on[a-z]/;\r\n  const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n      if (key === 'class') {\r\n          patchClass(el, nextValue, isSVG);\r\n      }\r\n      else if (key === 'style') {\r\n          patchStyle(el, prevValue, nextValue);\r\n      }\r\n      else if (isOn(key)) {\r\n          // ignore v-model listeners\r\n          if (!isModelListener(key)) {\r\n              patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n          }\r\n      }\r\n      else if (key[0] === '.'\r\n          ? ((key = key.slice(1)), true)\r\n          : key[0] === '^'\r\n              ? ((key = key.slice(1)), false)\r\n              : shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n          patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n      }\r\n      else {\r\n          // special case for <input v-model type=\"checkbox\"> with\r\n          // :true-value & :false-value\r\n          // store value as dom properties since non-string values will be\r\n          // stringified.\r\n          if (key === 'true-value') {\r\n              el._trueValue = nextValue;\r\n          }\r\n          else if (key === 'false-value') {\r\n              el._falseValue = nextValue;\r\n          }\r\n          patchAttr(el, key, nextValue, isSVG);\r\n      }\r\n  };\r\n  function shouldSetAsProp(el, key, value, isSVG) {\r\n      if (isSVG) {\r\n          // most keys must be set as attribute on svg elements to work\r\n          // ...except innerHTML & textContent\r\n          if (key === 'innerHTML' || key === 'textContent') {\r\n              return true;\r\n          }\r\n          // or native onclick with function values\r\n          if (key in el && nativeOnRE.test(key) && isFunction(value)) {\r\n              return true;\r\n          }\r\n          return false;\r\n      }\r\n      // spellcheck and draggable are numerated attrs, however their\r\n      // corresponding DOM properties are actually booleans - this leads to\r\n      // setting it with a string \"false\" value leading it to be coerced to\r\n      // `true`, so we need to always treat them as attributes.\r\n      // Note that `contentEditable` doesn't have this problem: its DOM\r\n      // property is also enumerated string values.\r\n      if (key === 'spellcheck' || key === 'draggable') {\r\n          return false;\r\n      }\r\n      // #1787, #2840 form property on form elements is readonly and must be set as\r\n      // attribute.\r\n      if (key === 'form') {\r\n          return false;\r\n      }\r\n      // #1526 <input list> must be set as attribute\r\n      if (key === 'list' && el.tagName === 'INPUT') {\r\n          return false;\r\n      }\r\n      // #2766 <textarea type> must be set as attribute\r\n      if (key === 'type' && el.tagName === 'TEXTAREA') {\r\n          return false;\r\n      }\r\n      // native onclick with string value, must be set as attribute\r\n      if (nativeOnRE.test(key) && isString(value)) {\r\n          return false;\r\n      }\r\n      return key in el;\r\n  }\n\n  function defineCustomElement(options, hydate) {\r\n      const Comp = defineComponent(options);\r\n      class VueCustomElement extends VueElement {\r\n          constructor(initialProps) {\r\n              super(Comp, initialProps, hydate);\r\n          }\r\n      }\r\n      VueCustomElement.def = Comp;\r\n      return VueCustomElement;\r\n  }\r\n  const defineSSRCustomElement = ((options) => {\r\n      // @ts-ignore\r\n      return defineCustomElement(options, hydrate);\r\n  });\r\n  const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {\r\n  });\r\n  class VueElement extends BaseClass {\r\n      constructor(_def, _props = {}, hydrate) {\r\n          super();\r\n          this._def = _def;\r\n          this._props = _props;\r\n          /**\r\n           * @internal\r\n           */\r\n          this._instance = null;\r\n          this._connected = false;\r\n          this._resolved = false;\r\n          this._numberProps = null;\r\n          if (this.shadowRoot && hydrate) {\r\n              hydrate(this._createVNode(), this.shadowRoot);\r\n          }\r\n          else {\r\n              if (this.shadowRoot) {\r\n                  warn$1(`Custom element has pre-rendered declarative shadow root but is not ` +\r\n                      `defined as hydratable. Use \\`defineSSRCustomElement\\`.`);\r\n              }\r\n              this.attachShadow({ mode: 'open' });\r\n          }\r\n      }\r\n      connectedCallback() {\r\n          this._connected = true;\r\n          if (!this._instance) {\r\n              this._resolveDef();\r\n          }\r\n      }\r\n      disconnectedCallback() {\r\n          this._connected = false;\r\n          nextTick(() => {\r\n              if (!this._connected) {\r\n                  render(null, this.shadowRoot);\r\n                  this._instance = null;\r\n              }\r\n          });\r\n      }\r\n      /**\r\n       * resolve inner component definition (handle possible async component)\r\n       */\r\n      _resolveDef() {\r\n          if (this._resolved) {\r\n              return;\r\n          }\r\n          this._resolved = true;\r\n          // set initial attrs\r\n          for (let i = 0; i < this.attributes.length; i++) {\r\n              this._setAttr(this.attributes[i].name);\r\n          }\r\n          // watch future attr changes\r\n          new MutationObserver(mutations => {\r\n              for (const m of mutations) {\r\n                  this._setAttr(m.attributeName);\r\n              }\r\n          }).observe(this, { attributes: true });\r\n          const resolve = (def) => {\r\n              const { props, styles } = def;\r\n              const hasOptions = !isArray(props);\r\n              const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];\r\n              // cast Number-type props set before resolve\r\n              let numberProps;\r\n              if (hasOptions) {\r\n                  for (const key in this._props) {\r\n                      const opt = props[key];\r\n                      if (opt === Number || (opt && opt.type === Number)) {\r\n                          this._props[key] = toNumber(this._props[key]);\r\n                          (numberProps || (numberProps = Object.create(null)))[key] = true;\r\n                      }\r\n                  }\r\n              }\r\n              this._numberProps = numberProps;\r\n              // check if there are props set pre-upgrade or connect\r\n              for (const key of Object.keys(this)) {\r\n                  if (key[0] !== '_') {\r\n                      this._setProp(key, this[key], true, false);\r\n                  }\r\n              }\r\n              // defining getter/setters on prototype\r\n              for (const key of rawKeys.map(camelize)) {\r\n                  Object.defineProperty(this, key, {\r\n                      get() {\r\n                          return this._getProp(key);\r\n                      },\r\n                      set(val) {\r\n                          this._setProp(key, val);\r\n                      }\r\n                  });\r\n              }\r\n              // apply CSS\r\n              this._applyStyles(styles);\r\n              // initial render\r\n              this._update();\r\n          };\r\n          const asyncDef = this._def.__asyncLoader;\r\n          if (asyncDef) {\r\n              asyncDef().then(resolve);\r\n          }\r\n          else {\r\n              resolve(this._def);\r\n          }\r\n      }\r\n      _setAttr(key) {\r\n          let value = this.getAttribute(key);\r\n          if (this._numberProps && this._numberProps[key]) {\r\n              value = toNumber(value);\r\n          }\r\n          this._setProp(camelize(key), value, false);\r\n      }\r\n      /**\r\n       * @internal\r\n       */\r\n      _getProp(key) {\r\n          return this._props[key];\r\n      }\r\n      /**\r\n       * @internal\r\n       */\r\n      _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\r\n          if (val !== this._props[key]) {\r\n              this._props[key] = val;\r\n              if (shouldUpdate && this._instance) {\r\n                  this._update();\r\n              }\r\n              // reflect\r\n              if (shouldReflect) {\r\n                  if (val === true) {\r\n                      this.setAttribute(hyphenate(key), '');\r\n                  }\r\n                  else if (typeof val === 'string' || typeof val === 'number') {\r\n                      this.setAttribute(hyphenate(key), val + '');\r\n                  }\r\n                  else if (!val) {\r\n                      this.removeAttribute(hyphenate(key));\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      _update() {\r\n          render(this._createVNode(), this.shadowRoot);\r\n      }\r\n      _createVNode() {\r\n          const vnode = createVNode(this._def, extend({}, this._props));\r\n          if (!this._instance) {\r\n              vnode.ce = instance => {\r\n                  this._instance = instance;\r\n                  instance.isCE = true;\r\n                  // HMR\r\n                  {\r\n                      instance.ceReload = newStyles => {\r\n                          // always reset styles\r\n                          if (this._styles) {\r\n                              this._styles.forEach(s => this.shadowRoot.removeChild(s));\r\n                              this._styles.length = 0;\r\n                          }\r\n                          this._applyStyles(newStyles);\r\n                          // if this is an async component, ceReload is called from the inner\r\n                          // component so no need to reload the async wrapper\r\n                          if (!this._def.__asyncLoader) {\r\n                              // reload\r\n                              this._instance = null;\r\n                              this._update();\r\n                          }\r\n                      };\r\n                  }\r\n                  // intercept emit\r\n                  instance.emit = (event, ...args) => {\r\n                      this.dispatchEvent(new CustomEvent(event, {\r\n                          detail: args\r\n                      }));\r\n                  };\r\n                  // locate nearest Vue custom element parent for provide/inject\r\n                  let parent = this;\r\n                  while ((parent =\r\n                      parent && (parent.parentNode || parent.host))) {\r\n                      if (parent instanceof VueElement) {\r\n                          instance.parent = parent._instance;\r\n                          break;\r\n                      }\r\n                  }\r\n              };\r\n          }\r\n          return vnode;\r\n      }\r\n      _applyStyles(styles) {\r\n          if (styles) {\r\n              styles.forEach(css => {\r\n                  const s = document.createElement('style');\r\n                  s.textContent = css;\r\n                  this.shadowRoot.appendChild(s);\r\n                  // record for HMR\r\n                  {\r\n                      (this._styles || (this._styles = [])).push(s);\r\n                  }\r\n              });\r\n          }\r\n      }\r\n  }\n\n  function useCssModule(name = '$style') {\r\n      /* istanbul ignore else */\r\n      {\r\n          {\r\n              warn$1(`useCssModule() is not supported in the global build.`);\r\n          }\r\n          return EMPTY_OBJ;\r\n      }\r\n  }\n\n  /**\r\n   * Runtime helper for SFC's CSS variable injection feature.\r\n   * @private\r\n   */\r\n  function useCssVars(getter) {\r\n      const instance = getCurrentInstance();\r\n      /* istanbul ignore next */\r\n      if (!instance) {\r\n          warn$1(`useCssVars is called without current active component instance.`);\r\n          return;\r\n      }\r\n      const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));\r\n      watchPostEffect(setVars);\r\n      onMounted(() => {\r\n          const ob = new MutationObserver(setVars);\r\n          ob.observe(instance.subTree.el.parentNode, { childList: true });\r\n          onUnmounted(() => ob.disconnect());\r\n      });\r\n  }\r\n  function setVarsOnVNode(vnode, vars) {\r\n      if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n          const suspense = vnode.suspense;\r\n          vnode = suspense.activeBranch;\r\n          if (suspense.pendingBranch && !suspense.isHydrating) {\r\n              suspense.effects.push(() => {\r\n                  setVarsOnVNode(suspense.activeBranch, vars);\r\n              });\r\n          }\r\n      }\r\n      // drill down HOCs until it's a non-component vnode\r\n      while (vnode.component) {\r\n          vnode = vnode.component.subTree;\r\n      }\r\n      if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {\r\n          setVarsOnNode(vnode.el, vars);\r\n      }\r\n      else if (vnode.type === Fragment) {\r\n          vnode.children.forEach(c => setVarsOnVNode(c, vars));\r\n      }\r\n      else if (vnode.type === Static) {\r\n          let { el, anchor } = vnode;\r\n          while (el) {\r\n              setVarsOnNode(el, vars);\r\n              if (el === anchor)\r\n                  break;\r\n              el = el.nextSibling;\r\n          }\r\n      }\r\n  }\r\n  function setVarsOnNode(el, vars) {\r\n      if (el.nodeType === 1) {\r\n          const style = el.style;\r\n          for (const key in vars) {\r\n              style.setProperty(`--${key}`, vars[key]);\r\n          }\r\n      }\r\n  }\n\n  const TRANSITION = 'transition';\r\n  const ANIMATION = 'animation';\r\n  // DOM Transition is a higher-order-component based on the platform-agnostic\r\n  // base Transition component, with DOM-specific logic.\r\n  const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\r\n  Transition.displayName = 'Transition';\r\n  const DOMTransitionPropsValidators = {\r\n      name: String,\r\n      type: String,\r\n      css: {\r\n          type: Boolean,\r\n          default: true\r\n      },\r\n      duration: [String, Number, Object],\r\n      enterFromClass: String,\r\n      enterActiveClass: String,\r\n      enterToClass: String,\r\n      appearFromClass: String,\r\n      appearActiveClass: String,\r\n      appearToClass: String,\r\n      leaveFromClass: String,\r\n      leaveActiveClass: String,\r\n      leaveToClass: String\r\n  };\r\n  const TransitionPropsValidators = (Transition.props =\r\n      /*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));\r\n  /**\r\n   * #3227 Incoming hooks may be merged into arrays when wrapping Transition\r\n   * with custom HOCs.\r\n   */\r\n  const callHook$1 = (hook, args = []) => {\r\n      if (isArray(hook)) {\r\n          hook.forEach(h => h(...args));\r\n      }\r\n      else if (hook) {\r\n          hook(...args);\r\n      }\r\n  };\r\n  /**\r\n   * Check if a hook expects a callback (2nd arg), which means the user\r\n   * intends to explicitly control the end of the transition.\r\n   */\r\n  const hasExplicitCallback = (hook) => {\r\n      return hook\r\n          ? isArray(hook)\r\n              ? hook.some(h => h.length > 1)\r\n              : hook.length > 1\r\n          : false;\r\n  };\r\n  function resolveTransitionProps(rawProps) {\r\n      const baseProps = {};\r\n      for (const key in rawProps) {\r\n          if (!(key in DOMTransitionPropsValidators)) {\r\n              baseProps[key] = rawProps[key];\r\n          }\r\n      }\r\n      if (rawProps.css === false) {\r\n          return baseProps;\r\n      }\r\n      const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\r\n      const durations = normalizeDuration(duration);\r\n      const enterDuration = durations && durations[0];\r\n      const leaveDuration = durations && durations[1];\r\n      const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\r\n      const finishEnter = (el, isAppear, done) => {\r\n          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\r\n          done && done();\r\n      };\r\n      const finishLeave = (el, done) => {\r\n          removeTransitionClass(el, leaveToClass);\r\n          removeTransitionClass(el, leaveActiveClass);\r\n          done && done();\r\n      };\r\n      const makeEnterHook = (isAppear) => {\r\n          return (el, done) => {\r\n              const hook = isAppear ? onAppear : onEnter;\r\n              const resolve = () => finishEnter(el, isAppear, done);\r\n              callHook$1(hook, [el, resolve]);\r\n              nextFrame(() => {\r\n                  removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\r\n                  addTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n                  if (!hasExplicitCallback(hook)) {\r\n                      whenTransitionEnds(el, type, enterDuration, resolve);\r\n                  }\r\n              });\r\n          };\r\n      };\r\n      return extend(baseProps, {\r\n          onBeforeEnter(el) {\r\n              callHook$1(onBeforeEnter, [el]);\r\n              addTransitionClass(el, enterFromClass);\r\n              addTransitionClass(el, enterActiveClass);\r\n          },\r\n          onBeforeAppear(el) {\r\n              callHook$1(onBeforeAppear, [el]);\r\n              addTransitionClass(el, appearFromClass);\r\n              addTransitionClass(el, appearActiveClass);\r\n          },\r\n          onEnter: makeEnterHook(false),\r\n          onAppear: makeEnterHook(true),\r\n          onLeave(el, done) {\r\n              const resolve = () => finishLeave(el, done);\r\n              addTransitionClass(el, leaveFromClass);\r\n              // force reflow so *-leave-from classes immediately take effect (#2593)\r\n              forceReflow();\r\n              addTransitionClass(el, leaveActiveClass);\r\n              nextFrame(() => {\r\n                  removeTransitionClass(el, leaveFromClass);\r\n                  addTransitionClass(el, leaveToClass);\r\n                  if (!hasExplicitCallback(onLeave)) {\r\n                      whenTransitionEnds(el, type, leaveDuration, resolve);\r\n                  }\r\n              });\r\n              callHook$1(onLeave, [el, resolve]);\r\n          },\r\n          onEnterCancelled(el) {\r\n              finishEnter(el, false);\r\n              callHook$1(onEnterCancelled, [el]);\r\n          },\r\n          onAppearCancelled(el) {\r\n              finishEnter(el, true);\r\n              callHook$1(onAppearCancelled, [el]);\r\n          },\r\n          onLeaveCancelled(el) {\r\n              finishLeave(el);\r\n              callHook$1(onLeaveCancelled, [el]);\r\n          }\r\n      });\r\n  }\r\n  function normalizeDuration(duration) {\r\n      if (duration == null) {\r\n          return null;\r\n      }\r\n      else if (isObject(duration)) {\r\n          return [NumberOf(duration.enter), NumberOf(duration.leave)];\r\n      }\r\n      else {\r\n          const n = NumberOf(duration);\r\n          return [n, n];\r\n      }\r\n  }\r\n  function NumberOf(val) {\r\n      const res = toNumber(val);\r\n      validateDuration(res);\r\n      return res;\r\n  }\r\n  function validateDuration(val) {\r\n      if (typeof val !== 'number') {\r\n          warn$1(`<transition> explicit duration is not a valid number - ` +\r\n              `got ${JSON.stringify(val)}.`);\r\n      }\r\n      else if (isNaN(val)) {\r\n          warn$1(`<transition> explicit duration is NaN - ` +\r\n              'the duration expression might be incorrect.');\r\n      }\r\n  }\r\n  function addTransitionClass(el, cls) {\r\n      cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\r\n      (el._vtc ||\r\n          (el._vtc = new Set())).add(cls);\r\n  }\r\n  function removeTransitionClass(el, cls) {\r\n      cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\r\n      const { _vtc } = el;\r\n      if (_vtc) {\r\n          _vtc.delete(cls);\r\n          if (!_vtc.size) {\r\n              el._vtc = undefined;\r\n          }\r\n      }\r\n  }\r\n  function nextFrame(cb) {\r\n      requestAnimationFrame(() => {\r\n          requestAnimationFrame(cb);\r\n      });\r\n  }\r\n  let endId = 0;\r\n  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\r\n      const id = (el._endId = ++endId);\r\n      const resolveIfNotStale = () => {\r\n          if (id === el._endId) {\r\n              resolve();\r\n          }\r\n      };\r\n      if (explicitTimeout) {\r\n          return setTimeout(resolveIfNotStale, explicitTimeout);\r\n      }\r\n      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n      if (!type) {\r\n          return resolve();\r\n      }\r\n      const endEvent = type + 'end';\r\n      let ended = 0;\r\n      const end = () => {\r\n          el.removeEventListener(endEvent, onEnd);\r\n          resolveIfNotStale();\r\n      };\r\n      const onEnd = (e) => {\r\n          if (e.target === el && ++ended >= propCount) {\r\n              end();\r\n          }\r\n      };\r\n      setTimeout(() => {\r\n          if (ended < propCount) {\r\n              end();\r\n          }\r\n      }, timeout + 1);\r\n      el.addEventListener(endEvent, onEnd);\r\n  }\r\n  function getTransitionInfo(el, expectedType) {\r\n      const styles = window.getComputedStyle(el);\r\n      // JSDOM may return undefined for transition properties\r\n      const getStyleProperties = (key) => (styles[key] || '').split(', ');\r\n      const transitionDelays = getStyleProperties(TRANSITION + 'Delay');\r\n      const transitionDurations = getStyleProperties(TRANSITION + 'Duration');\r\n      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n      const animationDelays = getStyleProperties(ANIMATION + 'Delay');\r\n      const animationDurations = getStyleProperties(ANIMATION + 'Duration');\r\n      const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n      let type = null;\r\n      let timeout = 0;\r\n      let propCount = 0;\r\n      /* istanbul ignore if */\r\n      if (expectedType === TRANSITION) {\r\n          if (transitionTimeout > 0) {\r\n              type = TRANSITION;\r\n              timeout = transitionTimeout;\r\n              propCount = transitionDurations.length;\r\n          }\r\n      }\r\n      else if (expectedType === ANIMATION) {\r\n          if (animationTimeout > 0) {\r\n              type = ANIMATION;\r\n              timeout = animationTimeout;\r\n              propCount = animationDurations.length;\r\n          }\r\n      }\r\n      else {\r\n          timeout = Math.max(transitionTimeout, animationTimeout);\r\n          type =\r\n              timeout > 0\r\n                  ? transitionTimeout > animationTimeout\r\n                      ? TRANSITION\r\n                      : ANIMATION\r\n                  : null;\r\n          propCount = type\r\n              ? type === TRANSITION\r\n                  ? transitionDurations.length\r\n                  : animationDurations.length\r\n              : 0;\r\n      }\r\n      const hasTransform = type === TRANSITION &&\r\n          /\\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);\r\n      return {\r\n          type,\r\n          timeout,\r\n          propCount,\r\n          hasTransform\r\n      };\r\n  }\r\n  function getTimeout(delays, durations) {\r\n      while (delays.length < durations.length) {\r\n          delays = delays.concat(delays);\r\n      }\r\n      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\r\n  }\r\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n  // numbers in a locale-dependent way, using a comma instead of a dot.\r\n  // If comma is not replaced with a dot, the input will be rounded down\r\n  // (i.e. acting as a floor function) causing unexpected behaviors\r\n  function toMs(s) {\r\n      return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n  }\r\n  // synchronously force layout to put elements into a certain state\r\n  function forceReflow() {\r\n      return document.body.offsetHeight;\r\n  }\n\n  const positionMap = new WeakMap();\r\n  const newPositionMap = new WeakMap();\r\n  const TransitionGroupImpl = {\r\n      name: 'TransitionGroup',\r\n      props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {\r\n          tag: String,\r\n          moveClass: String\r\n      }),\r\n      setup(props, { slots }) {\r\n          const instance = getCurrentInstance();\r\n          const state = useTransitionState();\r\n          let prevChildren;\r\n          let children;\r\n          onUpdated(() => {\r\n              // children is guaranteed to exist after initial render\r\n              if (!prevChildren.length) {\r\n                  return;\r\n              }\r\n              const moveClass = props.moveClass || `${props.name || 'v'}-move`;\r\n              if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\r\n                  return;\r\n              }\r\n              // we divide the work into three loops to avoid mixing DOM reads and writes\r\n              // in each iteration - which helps prevent layout thrashing.\r\n              prevChildren.forEach(callPendingCbs);\r\n              prevChildren.forEach(recordPosition);\r\n              const movedChildren = prevChildren.filter(applyTranslation);\r\n              // force reflow to put everything in position\r\n              forceReflow();\r\n              movedChildren.forEach(c => {\r\n                  const el = c.el;\r\n                  const style = el.style;\r\n                  addTransitionClass(el, moveClass);\r\n                  style.transform = style.webkitTransform = style.transitionDuration = '';\r\n                  const cb = (el._moveCb = (e) => {\r\n                      if (e && e.target !== el) {\r\n                          return;\r\n                      }\r\n                      if (!e || /transform$/.test(e.propertyName)) {\r\n                          el.removeEventListener('transitionend', cb);\r\n                          el._moveCb = null;\r\n                          removeTransitionClass(el, moveClass);\r\n                      }\r\n                  });\r\n                  el.addEventListener('transitionend', cb);\r\n              });\r\n          });\r\n          return () => {\r\n              const rawProps = toRaw(props);\r\n              const cssTransitionProps = resolveTransitionProps(rawProps);\r\n              let tag = rawProps.tag || Fragment;\r\n              prevChildren = children;\r\n              children = slots.default ? getTransitionRawChildren(slots.default()) : [];\r\n              for (let i = 0; i < children.length; i++) {\r\n                  const child = children[i];\r\n                  if (child.key != null) {\r\n                      setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                  }\r\n                  else {\r\n                      warn$1(`<TransitionGroup> children must be keyed.`);\r\n                  }\r\n              }\r\n              if (prevChildren) {\r\n                  for (let i = 0; i < prevChildren.length; i++) {\r\n                      const child = prevChildren[i];\r\n                      setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                      positionMap.set(child, child.el.getBoundingClientRect());\r\n                  }\r\n              }\r\n              return createVNode(tag, null, children);\r\n          };\r\n      }\r\n  };\r\n  const TransitionGroup = TransitionGroupImpl;\r\n  function callPendingCbs(c) {\r\n      const el = c.el;\r\n      if (el._moveCb) {\r\n          el._moveCb();\r\n      }\r\n      if (el._enterCb) {\r\n          el._enterCb();\r\n      }\r\n  }\r\n  function recordPosition(c) {\r\n      newPositionMap.set(c, c.el.getBoundingClientRect());\r\n  }\r\n  function applyTranslation(c) {\r\n      const oldPos = positionMap.get(c);\r\n      const newPos = newPositionMap.get(c);\r\n      const dx = oldPos.left - newPos.left;\r\n      const dy = oldPos.top - newPos.top;\r\n      if (dx || dy) {\r\n          const s = c.el.style;\r\n          s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\r\n          s.transitionDuration = '0s';\r\n          return c;\r\n      }\r\n  }\r\n  function hasCSSTransform(el, root, moveClass) {\r\n      // Detect whether an element with the move class applied has\r\n      // CSS transitions. Since the element may be inside an entering\r\n      // transition at this very moment, we make a clone of it and remove\r\n      // all other transition classes applied to ensure only the move class\r\n      // is applied.\r\n      const clone = el.cloneNode();\r\n      if (el._vtc) {\r\n          el._vtc.forEach(cls => {\r\n              cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\r\n          });\r\n      }\r\n      moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\r\n      clone.style.display = 'none';\r\n      const container = (root.nodeType === 1 ? root : root.parentNode);\r\n      container.appendChild(clone);\r\n      const { hasTransform } = getTransitionInfo(clone);\r\n      container.removeChild(clone);\r\n      return hasTransform;\r\n  }\n\n  const getModelAssigner = (vnode) => {\r\n      const fn = vnode.props['onUpdate:modelValue'];\r\n      return isArray(fn) ? value => invokeArrayFns(fn, value) : fn;\r\n  };\r\n  function onCompositionStart(e) {\r\n      e.target.composing = true;\r\n  }\r\n  function onCompositionEnd(e) {\r\n      const target = e.target;\r\n      if (target.composing) {\r\n          target.composing = false;\r\n          trigger$1(target, 'input');\r\n      }\r\n  }\r\n  function trigger$1(el, type) {\r\n      const e = document.createEvent('HTMLEvents');\r\n      e.initEvent(type, true, true);\r\n      el.dispatchEvent(e);\r\n  }\r\n  // We are exporting the v-model runtime directly as vnode hooks so that it can\r\n  // be tree-shaken in case v-model is never used.\r\n  const vModelText = {\r\n      created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n          el._assign = getModelAssigner(vnode);\r\n          const castToNumber = number || (vnode.props && vnode.props.type === 'number');\r\n          addEventListener(el, lazy ? 'change' : 'input', e => {\r\n              if (e.target.composing)\r\n                  return;\r\n              let domValue = el.value;\r\n              if (trim) {\r\n                  domValue = domValue.trim();\r\n              }\r\n              else if (castToNumber) {\r\n                  domValue = toNumber(domValue);\r\n              }\r\n              el._assign(domValue);\r\n          });\r\n          if (trim) {\r\n              addEventListener(el, 'change', () => {\r\n                  el.value = el.value.trim();\r\n              });\r\n          }\r\n          if (!lazy) {\r\n              addEventListener(el, 'compositionstart', onCompositionStart);\r\n              addEventListener(el, 'compositionend', onCompositionEnd);\r\n              // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n              // switching focus before confirming composition choice\r\n              // this also fixes the issue where some browsers e.g. iOS Chrome\r\n              // fires \"change\" instead of \"input\" on autocomplete.\r\n              addEventListener(el, 'change', onCompositionEnd);\r\n          }\r\n      },\r\n      // set value on mounted so it's after min/max for type=\"range\"\r\n      mounted(el, { value }) {\r\n          el.value = value == null ? '' : value;\r\n      },\r\n      beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\r\n          el._assign = getModelAssigner(vnode);\r\n          // avoid clearing unresolved text. #2302\r\n          if (el.composing)\r\n              return;\r\n          if (document.activeElement === el) {\r\n              if (lazy) {\r\n                  return;\r\n              }\r\n              if (trim && el.value.trim() === value) {\r\n                  return;\r\n              }\r\n              if ((number || el.type === 'number') && toNumber(el.value) === value) {\r\n                  return;\r\n              }\r\n          }\r\n          const newValue = value == null ? '' : value;\r\n          if (el.value !== newValue) {\r\n              el.value = newValue;\r\n          }\r\n      }\r\n  };\r\n  const vModelCheckbox = {\r\n      // #4096 array checkboxes need to be deep traversed\r\n      deep: true,\r\n      created(el, _, vnode) {\r\n          el._assign = getModelAssigner(vnode);\r\n          addEventListener(el, 'change', () => {\r\n              const modelValue = el._modelValue;\r\n              const elementValue = getValue(el);\r\n              const checked = el.checked;\r\n              const assign = el._assign;\r\n              if (isArray(modelValue)) {\r\n                  const index = looseIndexOf(modelValue, elementValue);\r\n                  const found = index !== -1;\r\n                  if (checked && !found) {\r\n                      assign(modelValue.concat(elementValue));\r\n                  }\r\n                  else if (!checked && found) {\r\n                      const filtered = [...modelValue];\r\n                      filtered.splice(index, 1);\r\n                      assign(filtered);\r\n                  }\r\n              }\r\n              else if (isSet(modelValue)) {\r\n                  const cloned = new Set(modelValue);\r\n                  if (checked) {\r\n                      cloned.add(elementValue);\r\n                  }\r\n                  else {\r\n                      cloned.delete(elementValue);\r\n                  }\r\n                  assign(cloned);\r\n              }\r\n              else {\r\n                  assign(getCheckboxValue(el, checked));\r\n              }\r\n          });\r\n      },\r\n      // set initial checked on mount to wait for true-value/false-value\r\n      mounted: setChecked,\r\n      beforeUpdate(el, binding, vnode) {\r\n          el._assign = getModelAssigner(vnode);\r\n          setChecked(el, binding, vnode);\r\n      }\r\n  };\r\n  function setChecked(el, { value, oldValue }, vnode) {\r\n      el._modelValue = value;\r\n      if (isArray(value)) {\r\n          el.checked = looseIndexOf(value, vnode.props.value) > -1;\r\n      }\r\n      else if (isSet(value)) {\r\n          el.checked = value.has(vnode.props.value);\r\n      }\r\n      else if (value !== oldValue) {\r\n          el.checked = looseEqual(value, getCheckboxValue(el, true));\r\n      }\r\n  }\r\n  const vModelRadio = {\r\n      created(el, { value }, vnode) {\r\n          el.checked = looseEqual(value, vnode.props.value);\r\n          el._assign = getModelAssigner(vnode);\r\n          addEventListener(el, 'change', () => {\r\n              el._assign(getValue(el));\r\n          });\r\n      },\r\n      beforeUpdate(el, { value, oldValue }, vnode) {\r\n          el._assign = getModelAssigner(vnode);\r\n          if (value !== oldValue) {\r\n              el.checked = looseEqual(value, vnode.props.value);\r\n          }\r\n      }\r\n  };\r\n  const vModelSelect = {\r\n      // <select multiple> value need to be deep traversed\r\n      deep: true,\r\n      created(el, { value, modifiers: { number } }, vnode) {\r\n          const isSetModel = isSet(value);\r\n          addEventListener(el, 'change', () => {\r\n              const selectedVal = Array.prototype.filter\r\n                  .call(el.options, (o) => o.selected)\r\n                  .map((o) => number ? toNumber(getValue(o)) : getValue(o));\r\n              el._assign(el.multiple\r\n                  ? isSetModel\r\n                      ? new Set(selectedVal)\r\n                      : selectedVal\r\n                  : selectedVal[0]);\r\n          });\r\n          el._assign = getModelAssigner(vnode);\r\n      },\r\n      // set value in mounted & updated because <select> relies on its children\r\n      // <option>s.\r\n      mounted(el, { value }) {\r\n          setSelected(el, value);\r\n      },\r\n      beforeUpdate(el, _binding, vnode) {\r\n          el._assign = getModelAssigner(vnode);\r\n      },\r\n      updated(el, { value }) {\r\n          setSelected(el, value);\r\n      }\r\n  };\r\n  function setSelected(el, value) {\r\n      const isMultiple = el.multiple;\r\n      if (isMultiple && !isArray(value) && !isSet(value)) {\r\n          warn$1(`<select multiple v-model> expects an Array or Set value for its binding, ` +\r\n                  `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\r\n          return;\r\n      }\r\n      for (let i = 0, l = el.options.length; i < l; i++) {\r\n          const option = el.options[i];\r\n          const optionValue = getValue(option);\r\n          if (isMultiple) {\r\n              if (isArray(value)) {\r\n                  option.selected = looseIndexOf(value, optionValue) > -1;\r\n              }\r\n              else {\r\n                  option.selected = value.has(optionValue);\r\n              }\r\n          }\r\n          else {\r\n              if (looseEqual(getValue(option), value)) {\r\n                  if (el.selectedIndex !== i)\r\n                      el.selectedIndex = i;\r\n                  return;\r\n              }\r\n          }\r\n      }\r\n      if (!isMultiple && el.selectedIndex !== -1) {\r\n          el.selectedIndex = -1;\r\n      }\r\n  }\r\n  // retrieve raw value set via :value bindings\r\n  function getValue(el) {\r\n      return '_value' in el ? el._value : el.value;\r\n  }\r\n  // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\n  function getCheckboxValue(el, checked) {\r\n      const key = checked ? '_trueValue' : '_falseValue';\r\n      return key in el ? el[key] : checked;\r\n  }\r\n  const vModelDynamic = {\r\n      created(el, binding, vnode) {\r\n          callModelHook(el, binding, vnode, null, 'created');\r\n      },\r\n      mounted(el, binding, vnode) {\r\n          callModelHook(el, binding, vnode, null, 'mounted');\r\n      },\r\n      beforeUpdate(el, binding, vnode, prevVNode) {\r\n          callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\r\n      },\r\n      updated(el, binding, vnode, prevVNode) {\r\n          callModelHook(el, binding, vnode, prevVNode, 'updated');\r\n      }\r\n  };\r\n  function callModelHook(el, binding, vnode, prevVNode, hook) {\r\n      let modelToUse;\r\n      switch (el.tagName) {\r\n          case 'SELECT':\r\n              modelToUse = vModelSelect;\r\n              break;\r\n          case 'TEXTAREA':\r\n              modelToUse = vModelText;\r\n              break;\r\n          default:\r\n              switch (vnode.props && vnode.props.type) {\r\n                  case 'checkbox':\r\n                      modelToUse = vModelCheckbox;\r\n                      break;\r\n                  case 'radio':\r\n                      modelToUse = vModelRadio;\r\n                      break;\r\n                  default:\r\n                      modelToUse = vModelText;\r\n              }\r\n      }\r\n      const fn = modelToUse[hook];\r\n      fn && fn(el, binding, vnode, prevVNode);\r\n  }\n\n  const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\r\n  const modifierGuards = {\r\n      stop: e => e.stopPropagation(),\r\n      prevent: e => e.preventDefault(),\r\n      self: e => e.target !== e.currentTarget,\r\n      ctrl: e => !e.ctrlKey,\r\n      shift: e => !e.shiftKey,\r\n      alt: e => !e.altKey,\r\n      meta: e => !e.metaKey,\r\n      left: e => 'button' in e && e.button !== 0,\r\n      middle: e => 'button' in e && e.button !== 1,\r\n      right: e => 'button' in e && e.button !== 2,\r\n      exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\r\n  };\r\n  /**\r\n   * @private\r\n   */\r\n  const withModifiers = (fn, modifiers) => {\r\n      return (event, ...args) => {\r\n          for (let i = 0; i < modifiers.length; i++) {\r\n              const guard = modifierGuards[modifiers[i]];\r\n              if (guard && guard(event, modifiers))\r\n                  return;\r\n          }\r\n          return fn(event, ...args);\r\n      };\r\n  };\r\n  // Kept for 2.x compat.\r\n  // Note: IE11 compat for `spacebar` and `del` is removed for now.\r\n  const keyNames = {\r\n      esc: 'escape',\r\n      space: ' ',\r\n      up: 'arrow-up',\r\n      left: 'arrow-left',\r\n      right: 'arrow-right',\r\n      down: 'arrow-down',\r\n      delete: 'backspace'\r\n  };\r\n  /**\r\n   * @private\r\n   */\r\n  const withKeys = (fn, modifiers) => {\r\n      return (event) => {\r\n          if (!('key' in event)) {\r\n              return;\r\n          }\r\n          const eventKey = hyphenate(event.key);\r\n          if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n              return fn(event);\r\n          }\r\n      };\r\n  };\n\n  const vShow = {\r\n      beforeMount(el, { value }, { transition }) {\r\n          el._vod = el.style.display === 'none' ? '' : el.style.display;\r\n          if (transition && value) {\r\n              transition.beforeEnter(el);\r\n          }\r\n          else {\r\n              setDisplay(el, value);\r\n          }\r\n      },\r\n      mounted(el, { value }, { transition }) {\r\n          if (transition && value) {\r\n              transition.enter(el);\r\n          }\r\n      },\r\n      updated(el, { value, oldValue }, { transition }) {\r\n          if (!value === !oldValue)\r\n              return;\r\n          if (transition) {\r\n              if (value) {\r\n                  transition.beforeEnter(el);\r\n                  setDisplay(el, true);\r\n                  transition.enter(el);\r\n              }\r\n              else {\r\n                  transition.leave(el, () => {\r\n                      setDisplay(el, false);\r\n                  });\r\n              }\r\n          }\r\n          else {\r\n              setDisplay(el, value);\r\n          }\r\n      },\r\n      beforeUnmount(el, { value }) {\r\n          setDisplay(el, value);\r\n      }\r\n  };\r\n  function setDisplay(el, value) {\r\n      el.style.display = value ? el._vod : 'none';\r\n  }\n\n  const rendererOptions = extend({ patchProp }, nodeOps);\r\n  // lazy create the renderer - this makes core renderer logic tree-shakable\r\n  // in case the user only imports reactivity utilities from Vue.\r\n  let renderer;\r\n  let enabledHydration = false;\r\n  function ensureRenderer() {\r\n      return (renderer ||\r\n          (renderer = createRenderer(rendererOptions)));\r\n  }\r\n  function ensureHydrationRenderer() {\r\n      renderer = enabledHydration\r\n          ? renderer\r\n          : createHydrationRenderer(rendererOptions);\r\n      enabledHydration = true;\r\n      return renderer;\r\n  }\r\n  // use explicit type casts here to avoid import() calls in rolled-up d.ts\r\n  const render = ((...args) => {\r\n      ensureRenderer().render(...args);\r\n  });\r\n  const hydrate = ((...args) => {\r\n      ensureHydrationRenderer().hydrate(...args);\r\n  });\r\n  const createApp = ((...args) => {\r\n      const app = ensureRenderer().createApp(...args);\r\n      {\r\n          injectNativeTagCheck(app);\r\n          injectCompilerOptionsCheck(app);\r\n      }\r\n      const { mount } = app;\r\n      app.mount = (containerOrSelector) => {\r\n          const container = normalizeContainer(containerOrSelector);\r\n          if (!container)\r\n              return;\r\n          const component = app._component;\r\n          if (!isFunction(component) && !component.render && !component.template) {\r\n              // __UNSAFE__\r\n              // Reason: potential execution of JS expressions in in-DOM template.\r\n              // The user must make sure the in-DOM template is trusted. If it's\r\n              // rendered by the server, the template should not contain any user data.\r\n              component.template = container.innerHTML;\r\n          }\r\n          // clear content before mounting\r\n          container.innerHTML = '';\r\n          const proxy = mount(container, false, container instanceof SVGElement);\r\n          if (container instanceof Element) {\r\n              container.removeAttribute('v-cloak');\r\n              container.setAttribute('data-v-app', '');\r\n          }\r\n          return proxy;\r\n      };\r\n      return app;\r\n  });\r\n  const createSSRApp = ((...args) => {\r\n      const app = ensureHydrationRenderer().createApp(...args);\r\n      {\r\n          injectNativeTagCheck(app);\r\n          injectCompilerOptionsCheck(app);\r\n      }\r\n      const { mount } = app;\r\n      app.mount = (containerOrSelector) => {\r\n          const container = normalizeContainer(containerOrSelector);\r\n          if (container) {\r\n              return mount(container, true, container instanceof SVGElement);\r\n          }\r\n      };\r\n      return app;\r\n  });\r\n  function injectNativeTagCheck(app) {\r\n      // Inject `isNativeTag`\r\n      // this is used for component name validation (dev only)\r\n      Object.defineProperty(app.config, 'isNativeTag', {\r\n          value: (tag) => isHTMLTag(tag) || isSVGTag(tag),\r\n          writable: false\r\n      });\r\n  }\r\n  // dev only\r\n  function injectCompilerOptionsCheck(app) {\r\n      if (isRuntimeOnly()) {\r\n          const isCustomElement = app.config.isCustomElement;\r\n          Object.defineProperty(app.config, 'isCustomElement', {\r\n              get() {\r\n                  return isCustomElement;\r\n              },\r\n              set() {\r\n                  warn$1(`The \\`isCustomElement\\` config option is deprecated. Use ` +\r\n                      `\\`compilerOptions.isCustomElement\\` instead.`);\r\n              }\r\n          });\r\n          const compilerOptions = app.config.compilerOptions;\r\n          const msg = `The \\`compilerOptions\\` config option is only respected when using ` +\r\n              `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\r\n              `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\r\n              `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\r\n              `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\r\n              `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\r\n              `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\r\n          Object.defineProperty(app.config, 'compilerOptions', {\r\n              get() {\r\n                  warn$1(msg);\r\n                  return compilerOptions;\r\n              },\r\n              set() {\r\n                  warn$1(msg);\r\n              }\r\n          });\r\n      }\r\n  }\r\n  function normalizeContainer(container) {\r\n      if (isString(container)) {\r\n          const res = document.querySelector(container);\r\n          if (!res) {\r\n              warn$1(`Failed to mount app: mount target selector \"${container}\" returned null.`);\r\n          }\r\n          return res;\r\n      }\r\n      if (window.ShadowRoot &&\r\n          container instanceof window.ShadowRoot &&\r\n          container.mode === 'closed') {\r\n          warn$1(`mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`);\r\n      }\r\n      return container;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  const initDirectivesForSSR = NOOP;\n\n  function initDev() {\r\n      {\r\n          {\r\n              console.info(`You are running a development build of Vue.\\n` +\r\n                  `Make sure to use the production build (*.prod.js) when deploying for production.`);\r\n          }\r\n          initCustomFormatter();\r\n      }\r\n  }\n\n  function defaultOnError(error) {\r\n      throw error;\r\n  }\r\n  function defaultOnWarn(msg) {\r\n      console.warn(`[Vue warn] ${msg.message}`);\r\n  }\r\n  function createCompilerError(code, loc, messages, additionalMessage) {\r\n      const msg = (messages || errorMessages)[code] + (additionalMessage || ``)\r\n          ;\r\n      const error = new SyntaxError(String(msg));\r\n      error.code = code;\r\n      error.loc = loc;\r\n      return error;\r\n  }\r\n  const errorMessages = {\r\n      // parse errors\r\n      [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',\r\n      [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',\r\n      [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',\r\n      [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',\r\n      [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: \"Illegal '/' in tags.\",\r\n      [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',\r\n      [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',\r\n      [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',\r\n      [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',\r\n      [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',\r\n      [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',\r\n      [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',\r\n      [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: \"Illegal tag name. Use '&lt;' to print '<'.\",\r\n      [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',\r\n      [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',\r\n      [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',\r\n      [16 /* NESTED_COMMENT */]: \"Unexpected '<!--' in comment.\",\r\n      [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\r\n      [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\r\n      [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: \"Attribute name cannot start with '='.\",\r\n      [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: \"'<?' is allowed only in XML context.\",\r\n      [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,\r\n      [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: \"Illegal '/' in tags.\",\r\n      // Vue-specific parse errors\r\n      [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',\r\n      [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',\r\n      [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',\r\n      [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +\r\n          'Note that dynamic directive argument cannot contain spaces.',\r\n      [26 /* X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',\r\n      // transform errors\r\n      [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\r\n      [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\r\n      [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\r\n      [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\r\n      [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\r\n      [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\r\n      [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\r\n      [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\r\n      [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\r\n      [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +\r\n          `When there are multiple named slots, all slots should use <template> ` +\r\n          `syntax to avoid scope ambiguity.`,\r\n      [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\r\n      [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\r\n          `default slot. These children will be ignored.`,\r\n      [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\r\n      [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\r\n      [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\r\n      [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n      [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\r\n      [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\r\n      // generic errors\r\n      [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\r\n      [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\r\n      [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\r\n      [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `\"scopeId\" option is only supported in module mode.`,\r\n      // just to fulfill types\r\n      [50 /* __EXTEND_POINT__ */]: ``\r\n  };\n\n  const FRAGMENT = Symbol(`Fragment` );\r\n  const TELEPORT = Symbol(`Teleport` );\r\n  const SUSPENSE = Symbol(`Suspense` );\r\n  const KEEP_ALIVE = Symbol(`KeepAlive` );\r\n  const BASE_TRANSITION = Symbol(`BaseTransition` );\r\n  const OPEN_BLOCK = Symbol(`openBlock` );\r\n  const CREATE_BLOCK = Symbol(`createBlock` );\r\n  const CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock` );\r\n  const CREATE_VNODE = Symbol(`createVNode` );\r\n  const CREATE_ELEMENT_VNODE = Symbol(`createElementVNode` );\r\n  const CREATE_COMMENT = Symbol(`createCommentVNode` );\r\n  const CREATE_TEXT = Symbol(`createTextVNode` );\r\n  const CREATE_STATIC = Symbol(`createStaticVNode` );\r\n  const RESOLVE_COMPONENT = Symbol(`resolveComponent` );\r\n  const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent` );\r\n  const RESOLVE_DIRECTIVE = Symbol(`resolveDirective` );\r\n  const RESOLVE_FILTER = Symbol(`resolveFilter` );\r\n  const WITH_DIRECTIVES = Symbol(`withDirectives` );\r\n  const RENDER_LIST = Symbol(`renderList` );\r\n  const RENDER_SLOT = Symbol(`renderSlot` );\r\n  const CREATE_SLOTS = Symbol(`createSlots` );\r\n  const TO_DISPLAY_STRING = Symbol(`toDisplayString` );\r\n  const MERGE_PROPS = Symbol(`mergeProps` );\r\n  const NORMALIZE_CLASS = Symbol(`normalizeClass` );\r\n  const NORMALIZE_STYLE = Symbol(`normalizeStyle` );\r\n  const NORMALIZE_PROPS = Symbol(`normalizeProps` );\r\n  const GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps` );\r\n  const TO_HANDLERS = Symbol(`toHandlers` );\r\n  const CAMELIZE = Symbol(`camelize` );\r\n  const CAPITALIZE = Symbol(`capitalize` );\r\n  const TO_HANDLER_KEY = Symbol(`toHandlerKey` );\r\n  const SET_BLOCK_TRACKING = Symbol(`setBlockTracking` );\r\n  const PUSH_SCOPE_ID = Symbol(`pushScopeId` );\r\n  const POP_SCOPE_ID = Symbol(`popScopeId` );\r\n  const WITH_CTX = Symbol(`withCtx` );\r\n  const UNREF = Symbol(`unref` );\r\n  const IS_REF = Symbol(`isRef` );\r\n  const WITH_MEMO = Symbol(`withMemo` );\r\n  const IS_MEMO_SAME = Symbol(`isMemoSame` );\r\n  // Name mapping for runtime helpers that need to be imported from 'vue' in\r\n  // generated code. Make sure these are correctly exported in the runtime!\r\n  // Using `any` here because TS doesn't allow symbols as index type.\r\n  const helperNameMap = {\r\n      [FRAGMENT]: `Fragment`,\r\n      [TELEPORT]: `Teleport`,\r\n      [SUSPENSE]: `Suspense`,\r\n      [KEEP_ALIVE]: `KeepAlive`,\r\n      [BASE_TRANSITION]: `BaseTransition`,\r\n      [OPEN_BLOCK]: `openBlock`,\r\n      [CREATE_BLOCK]: `createBlock`,\r\n      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\r\n      [CREATE_VNODE]: `createVNode`,\r\n      [CREATE_ELEMENT_VNODE]: `createElementVNode`,\r\n      [CREATE_COMMENT]: `createCommentVNode`,\r\n      [CREATE_TEXT]: `createTextVNode`,\r\n      [CREATE_STATIC]: `createStaticVNode`,\r\n      [RESOLVE_COMPONENT]: `resolveComponent`,\r\n      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n      [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n      [RESOLVE_FILTER]: `resolveFilter`,\r\n      [WITH_DIRECTIVES]: `withDirectives`,\r\n      [RENDER_LIST]: `renderList`,\r\n      [RENDER_SLOT]: `renderSlot`,\r\n      [CREATE_SLOTS]: `createSlots`,\r\n      [TO_DISPLAY_STRING]: `toDisplayString`,\r\n      [MERGE_PROPS]: `mergeProps`,\r\n      [NORMALIZE_CLASS]: `normalizeClass`,\r\n      [NORMALIZE_STYLE]: `normalizeStyle`,\r\n      [NORMALIZE_PROPS]: `normalizeProps`,\r\n      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\r\n      [TO_HANDLERS]: `toHandlers`,\r\n      [CAMELIZE]: `camelize`,\r\n      [CAPITALIZE]: `capitalize`,\r\n      [TO_HANDLER_KEY]: `toHandlerKey`,\r\n      [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n      [PUSH_SCOPE_ID]: `pushScopeId`,\r\n      [POP_SCOPE_ID]: `popScopeId`,\r\n      [WITH_CTX]: `withCtx`,\r\n      [UNREF]: `unref`,\r\n      [IS_REF]: `isRef`,\r\n      [WITH_MEMO]: `withMemo`,\r\n      [IS_MEMO_SAME]: `isMemoSame`\r\n  };\r\n  function registerRuntimeHelpers(helpers) {\r\n      Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n          helperNameMap[s] = helpers[s];\r\n      });\r\n  }\n\n  // AST Utilities ---------------------------------------------------------------\r\n  // Some expressions, e.g. sequence and conditional expressions, are never\r\n  // associated with template nodes, so their source locations are just a stub.\r\n  // Container types like CompoundExpression also don't need a real location.\r\n  const locStub = {\r\n      source: '',\r\n      start: { line: 1, column: 1, offset: 0 },\r\n      end: { line: 1, column: 1, offset: 0 }\r\n  };\r\n  function createRoot(children, loc = locStub) {\r\n      return {\r\n          type: 0 /* ROOT */,\r\n          children,\r\n          helpers: [],\r\n          components: [],\r\n          directives: [],\r\n          hoists: [],\r\n          imports: [],\r\n          cached: 0,\r\n          temps: 0,\r\n          codegenNode: undefined,\r\n          loc\r\n      };\r\n  }\r\n  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {\r\n      if (context) {\r\n          if (isBlock) {\r\n              context.helper(OPEN_BLOCK);\r\n              context.helper(getVNodeBlockHelper(context.inSSR, isComponent));\r\n          }\r\n          else {\r\n              context.helper(getVNodeHelper(context.inSSR, isComponent));\r\n          }\r\n          if (directives) {\r\n              context.helper(WITH_DIRECTIVES);\r\n          }\r\n      }\r\n      return {\r\n          type: 13 /* VNODE_CALL */,\r\n          tag,\r\n          props,\r\n          children,\r\n          patchFlag,\r\n          dynamicProps,\r\n          directives,\r\n          isBlock,\r\n          disableTracking,\r\n          isComponent,\r\n          loc\r\n      };\r\n  }\r\n  function createArrayExpression(elements, loc = locStub) {\r\n      return {\r\n          type: 17 /* JS_ARRAY_EXPRESSION */,\r\n          loc,\r\n          elements\r\n      };\r\n  }\r\n  function createObjectExpression(properties, loc = locStub) {\r\n      return {\r\n          type: 15 /* JS_OBJECT_EXPRESSION */,\r\n          loc,\r\n          properties\r\n      };\r\n  }\r\n  function createObjectProperty(key, value) {\r\n      return {\r\n          type: 16 /* JS_PROPERTY */,\r\n          loc: locStub,\r\n          key: isString(key) ? createSimpleExpression(key, true) : key,\r\n          value\r\n      };\r\n  }\r\n  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* NOT_CONSTANT */) {\r\n      return {\r\n          type: 4 /* SIMPLE_EXPRESSION */,\r\n          loc,\r\n          content,\r\n          isStatic,\r\n          constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType\r\n      };\r\n  }\r\n  function createCompoundExpression(children, loc = locStub) {\r\n      return {\r\n          type: 8 /* COMPOUND_EXPRESSION */,\r\n          loc,\r\n          children\r\n      };\r\n  }\r\n  function createCallExpression(callee, args = [], loc = locStub) {\r\n      return {\r\n          type: 14 /* JS_CALL_EXPRESSION */,\r\n          loc,\r\n          callee,\r\n          arguments: args\r\n      };\r\n  }\r\n  function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\r\n      return {\r\n          type: 18 /* JS_FUNCTION_EXPRESSION */,\r\n          params,\r\n          returns,\r\n          newline,\r\n          isSlot,\r\n          loc\r\n      };\r\n  }\r\n  function createConditionalExpression(test, consequent, alternate, newline = true) {\r\n      return {\r\n          type: 19 /* JS_CONDITIONAL_EXPRESSION */,\r\n          test,\r\n          consequent,\r\n          alternate,\r\n          newline,\r\n          loc: locStub\r\n      };\r\n  }\r\n  function createCacheExpression(index, value, isVNode = false) {\r\n      return {\r\n          type: 20 /* JS_CACHE_EXPRESSION */,\r\n          index,\r\n          value,\r\n          isVNode,\r\n          loc: locStub\r\n      };\r\n  }\r\n  function createBlockStatement(body) {\r\n      return {\r\n          type: 21 /* JS_BLOCK_STATEMENT */,\r\n          body,\r\n          loc: locStub\r\n      };\r\n  }\n\n  const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\r\n  const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);\r\n  function isCoreComponent(tag) {\r\n      if (isBuiltInType(tag, 'Teleport')) {\r\n          return TELEPORT;\r\n      }\r\n      else if (isBuiltInType(tag, 'Suspense')) {\r\n          return SUSPENSE;\r\n      }\r\n      else if (isBuiltInType(tag, 'KeepAlive')) {\r\n          return KEEP_ALIVE;\r\n      }\r\n      else if (isBuiltInType(tag, 'BaseTransition')) {\r\n          return BASE_TRANSITION;\r\n      }\r\n  }\r\n  const nonIdentifierRE = /^\\d|[^\\$\\w]/;\r\n  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\r\n  const validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/;\r\n  const validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/;\r\n  const whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g;\r\n  /**\r\n   * Simple lexer to check if an expression is a member expression. This is\r\n   * lax and only checks validity at the root level (i.e. does not validate exps\r\n   * inside square brackets), but it's ok since these are only used on template\r\n   * expressions and false positives are invalid expressions in the first place.\r\n   */\r\n  const isMemberExpressionBrowser = (path) => {\r\n      // remove whitespaces around . or [ first\r\n      path = path.trim().replace(whitespaceRE, s => s.trim());\r\n      let state = 0 /* inMemberExp */;\r\n      let stateStack = [];\r\n      let currentOpenBracketCount = 0;\r\n      let currentOpenParensCount = 0;\r\n      let currentStringType = null;\r\n      for (let i = 0; i < path.length; i++) {\r\n          const char = path.charAt(i);\r\n          switch (state) {\r\n              case 0 /* inMemberExp */:\r\n                  if (char === '[') {\r\n                      stateStack.push(state);\r\n                      state = 1 /* inBrackets */;\r\n                      currentOpenBracketCount++;\r\n                  }\r\n                  else if (char === '(') {\r\n                      stateStack.push(state);\r\n                      state = 2 /* inParens */;\r\n                      currentOpenParensCount++;\r\n                  }\r\n                  else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {\r\n                      return false;\r\n                  }\r\n                  break;\r\n              case 1 /* inBrackets */:\r\n                  if (char === `'` || char === `\"` || char === '`') {\r\n                      stateStack.push(state);\r\n                      state = 3 /* inString */;\r\n                      currentStringType = char;\r\n                  }\r\n                  else if (char === `[`) {\r\n                      currentOpenBracketCount++;\r\n                  }\r\n                  else if (char === `]`) {\r\n                      if (!--currentOpenBracketCount) {\r\n                          state = stateStack.pop();\r\n                      }\r\n                  }\r\n                  break;\r\n              case 2 /* inParens */:\r\n                  if (char === `'` || char === `\"` || char === '`') {\r\n                      stateStack.push(state);\r\n                      state = 3 /* inString */;\r\n                      currentStringType = char;\r\n                  }\r\n                  else if (char === `(`) {\r\n                      currentOpenParensCount++;\r\n                  }\r\n                  else if (char === `)`) {\r\n                      // if the exp ends as a call then it should not be considered valid\r\n                      if (i === path.length - 1) {\r\n                          return false;\r\n                      }\r\n                      if (!--currentOpenParensCount) {\r\n                          state = stateStack.pop();\r\n                      }\r\n                  }\r\n                  break;\r\n              case 3 /* inString */:\r\n                  if (char === currentStringType) {\r\n                      state = stateStack.pop();\r\n                      currentStringType = null;\r\n                  }\r\n                  break;\r\n          }\r\n      }\r\n      return !currentOpenBracketCount && !currentOpenParensCount;\r\n  };\r\n  const isMemberExpression = isMemberExpressionBrowser\r\n      ;\r\n  function getInnerRange(loc, offset, length) {\r\n      const source = loc.source.slice(offset, offset + length);\r\n      const newLoc = {\r\n          source,\r\n          start: advancePositionWithClone(loc.start, loc.source, offset),\r\n          end: loc.end\r\n      };\r\n      if (length != null) {\r\n          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\r\n      }\r\n      return newLoc;\r\n  }\r\n  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\r\n      return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);\r\n  }\r\n  // advance by mutation without cloning (for performance reasons), since this\r\n  // gets called a lot in the parser\r\n  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\r\n      let linesCount = 0;\r\n      let lastNewLinePos = -1;\r\n      for (let i = 0; i < numberOfCharacters; i++) {\r\n          if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n              linesCount++;\r\n              lastNewLinePos = i;\r\n          }\r\n      }\r\n      pos.offset += numberOfCharacters;\r\n      pos.line += linesCount;\r\n      pos.column =\r\n          lastNewLinePos === -1\r\n              ? pos.column + numberOfCharacters\r\n              : numberOfCharacters - lastNewLinePos;\r\n      return pos;\r\n  }\r\n  function assert(condition, msg) {\r\n      /* istanbul ignore if */\r\n      if (!condition) {\r\n          throw new Error(msg || `unexpected compiler condition`);\r\n      }\r\n  }\r\n  function findDir(node, name, allowEmpty = false) {\r\n      for (let i = 0; i < node.props.length; i++) {\r\n          const p = node.props[i];\r\n          if (p.type === 7 /* DIRECTIVE */ &&\r\n              (allowEmpty || p.exp) &&\r\n              (isString(name) ? p.name === name : name.test(p.name))) {\r\n              return p;\r\n          }\r\n      }\r\n  }\r\n  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {\r\n      for (let i = 0; i < node.props.length; i++) {\r\n          const p = node.props[i];\r\n          if (p.type === 6 /* ATTRIBUTE */) {\r\n              if (dynamicOnly)\r\n                  continue;\r\n              if (p.name === name && (p.value || allowEmpty)) {\r\n                  return p;\r\n              }\r\n          }\r\n          else if (p.name === 'bind' &&\r\n              (p.exp || allowEmpty) &&\r\n              isStaticArgOf(p.arg, name)) {\r\n              return p;\r\n          }\r\n      }\r\n  }\r\n  function isStaticArgOf(arg, name) {\r\n      return !!(arg && isStaticExp(arg) && arg.content === name);\r\n  }\r\n  function hasDynamicKeyVBind(node) {\r\n      return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&\r\n          p.name === 'bind' &&\r\n          (!p.arg || // v-bind=\"obj\"\r\n              p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\r\n              !p.arg.isStatic) // v-bind:[foo]\r\n      );\r\n  }\r\n  function isText(node) {\r\n      return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;\r\n  }\r\n  function isVSlot(p) {\r\n      return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';\r\n  }\r\n  function isTemplateNode(node) {\r\n      return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);\r\n  }\r\n  function isSlotOutlet(node) {\r\n      return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\r\n  }\r\n  function getVNodeHelper(ssr, isComponent) {\r\n      return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;\r\n  }\r\n  function getVNodeBlockHelper(ssr, isComponent) {\r\n      return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;\r\n  }\r\n  const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);\r\n  function getUnnormalizedProps(props, callPath = []) {\r\n      if (props &&\r\n          !isString(props) &&\r\n          props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n          const callee = props.callee;\r\n          if (!isString(callee) && propsHelperSet.has(callee)) {\r\n              return getUnnormalizedProps(props.arguments[0], callPath.concat(props));\r\n          }\r\n      }\r\n      return [props, callPath];\r\n  }\r\n  function injectProp(node, prop, context) {\r\n      let propsWithInjection;\r\n      /**\r\n       * 1. mergeProps(...)\r\n       * 2. toHandlers(...)\r\n       * 3. normalizeProps(...)\r\n       * 4. normalizeProps(guardReactiveProps(...))\r\n       *\r\n       * we need to get the real props before normalization\r\n       */\r\n      let props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];\r\n      let callPath = [];\r\n      let parentCall;\r\n      if (props &&\r\n          !isString(props) &&\r\n          props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n          const ret = getUnnormalizedProps(props);\r\n          props = ret[0];\r\n          callPath = ret[1];\r\n          parentCall = callPath[callPath.length - 1];\r\n      }\r\n      if (props == null || isString(props)) {\r\n          propsWithInjection = createObjectExpression([prop]);\r\n      }\r\n      else if (props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n          // merged props... add ours\r\n          // only inject key to object literal if it's the first argument so that\r\n          // if doesn't override user provided keys\r\n          const first = props.arguments[0];\r\n          if (!isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n              first.properties.unshift(prop);\r\n          }\r\n          else {\r\n              if (props.callee === TO_HANDLERS) {\r\n                  // #2366\r\n                  propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n                      createObjectExpression([prop]),\r\n                      props\r\n                  ]);\r\n              }\r\n              else {\r\n                  props.arguments.unshift(createObjectExpression([prop]));\r\n              }\r\n          }\r\n          !propsWithInjection && (propsWithInjection = props);\r\n      }\r\n      else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n          let alreadyExists = false;\r\n          // check existing key to avoid overriding user provided keys\r\n          if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {\r\n              const propKeyName = prop.key.content;\r\n              alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                  p.key.content === propKeyName);\r\n          }\r\n          if (!alreadyExists) {\r\n              props.properties.unshift(prop);\r\n          }\r\n          propsWithInjection = props;\r\n      }\r\n      else {\r\n          // single v-bind with expression, return a merged replacement\r\n          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n              createObjectExpression([prop]),\r\n              props\r\n          ]);\r\n          // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\r\n          // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\r\n          // the `guardReactiveProps` will no longer be needed\r\n          if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\r\n              parentCall = callPath[callPath.length - 2];\r\n          }\r\n      }\r\n      if (node.type === 13 /* VNODE_CALL */) {\r\n          if (parentCall) {\r\n              parentCall.arguments[0] = propsWithInjection;\r\n          }\r\n          else {\r\n              node.props = propsWithInjection;\r\n          }\r\n      }\r\n      else {\r\n          if (parentCall) {\r\n              parentCall.arguments[0] = propsWithInjection;\r\n          }\r\n          else {\r\n              node.arguments[2] = propsWithInjection;\r\n          }\r\n      }\r\n  }\r\n  function toValidAssetId(name, type) {\r\n      // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\r\n      return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\r\n        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();\r\n    })}`;\r\n  }\r\n  function getMemoedVNodeCall(node) {\r\n      if (node.type === 14 /* JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {\r\n          return node.arguments[1].returns;\r\n      }\r\n      else {\r\n          return node;\r\n      }\r\n  }\r\n  function makeBlock(node, { helper, removeHelper, inSSR }) {\r\n      if (!node.isBlock) {\r\n          node.isBlock = true;\r\n          removeHelper(getVNodeHelper(inSSR, node.isComponent));\r\n          helper(OPEN_BLOCK);\r\n          helper(getVNodeBlockHelper(inSSR, node.isComponent));\r\n      }\r\n  }\n\n  const deprecationData = {\r\n      [\"COMPILER_IS_ON_ELEMENT\" /* COMPILER_IS_ON_ELEMENT */]: {\r\n          message: `Platform-native elements with \"is\" prop will no longer be ` +\r\n              `treated as components in Vue 3 unless the \"is\" value is explicitly ` +\r\n              `prefixed with \"vue:\".`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\r\n      },\r\n      [\"COMPILER_V_BIND_SYNC\" /* COMPILER_V_BIND_SYNC */]: {\r\n          message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +\r\n              `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` +\r\n              `\\`v-model:${key}\\`.`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\r\n      },\r\n      [\"COMPILER_V_BIND_PROP\" /* COMPILER_V_BIND_PROP */]: {\r\n          message: `.prop modifier for v-bind has been removed and no longer necessary. ` +\r\n              `Vue 3 will automatically set a binding as DOM property when appropriate.`\r\n      },\r\n      [\"COMPILER_V_BIND_OBJECT_ORDER\" /* COMPILER_V_BIND_OBJECT_ORDER */]: {\r\n          message: `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` +\r\n              `object spread: it will now overwrite an existing non-mergeable attribute ` +\r\n              `that appears before v-bind in the case of conflict. ` +\r\n              `To retain 2.x behavior, move v-bind to make it the first attribute. ` +\r\n              `You can also suppress this warning if the usage is intended.`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\r\n      },\r\n      [\"COMPILER_V_ON_NATIVE\" /* COMPILER_V_ON_NATIVE */]: {\r\n          message: `.native modifier for v-on has been removed as is no longer necessary.`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\r\n      },\r\n      [\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {\r\n          message: `v-if / v-for precedence when used on the same element has changed ` +\r\n              `in Vue 3: v-if now takes higher precedence and will no longer have ` +\r\n              `access to v-for scope variables. It is best to avoid the ambiguity ` +\r\n              `with <template> tags or use a computed property that filters v-for ` +\r\n              `data source.`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\r\n      },\r\n      [\"COMPILER_NATIVE_TEMPLATE\" /* COMPILER_NATIVE_TEMPLATE */]: {\r\n          message: `<template> with no special directives will render as a native template ` +\r\n              `element instead of its inner content in Vue 3.`\r\n      },\r\n      [\"COMPILER_INLINE_TEMPLATE\" /* COMPILER_INLINE_TEMPLATE */]: {\r\n          message: `\"inline-template\" has been removed in Vue 3.`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\r\n      },\r\n      [\"COMPILER_FILTER\" /* COMPILER_FILTERS */]: {\r\n          message: `filters have been removed in Vue 3. ` +\r\n              `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\r\n              `Use method calls or computed properties instead.`,\r\n          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\r\n      }\r\n  };\r\n  function getCompatValue(key, context) {\r\n      const config = context.options\r\n          ? context.options.compatConfig\r\n          : context.compatConfig;\r\n      const value = config && config[key];\r\n      if (key === 'MODE') {\r\n          return value || 3; // compiler defaults to v3 behavior\r\n      }\r\n      else {\r\n          return value;\r\n      }\r\n  }\r\n  function isCompatEnabled(key, context) {\r\n      const mode = getCompatValue('MODE', context);\r\n      const value = getCompatValue(key, context);\r\n      // in v3 mode, only enable if explicitly set to true\r\n      // otherwise enable for any non-false value\r\n      return mode === 3 ? value === true : value !== false;\r\n  }\r\n  function checkCompatEnabled(key, context, loc, ...args) {\r\n      const enabled = isCompatEnabled(key, context);\r\n      if (enabled) {\r\n          warnDeprecation(key, context, loc, ...args);\r\n      }\r\n      return enabled;\r\n  }\r\n  function warnDeprecation(key, context, loc, ...args) {\r\n      const val = getCompatValue(key, context);\r\n      if (val === 'suppress-warning') {\r\n          return;\r\n      }\r\n      const { message, link } = deprecationData[key];\r\n      const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\\n  Details: ${link}` : ``}`;\r\n      const err = new SyntaxError(msg);\r\n      err.code = key;\r\n      if (loc)\r\n          err.loc = loc;\r\n      context.onWarn(err);\r\n  }\n\n  // The default decoder only provides escapes for characters reserved as part of\r\n  // the template syntax, and is only used if the custom renderer did not provide\r\n  // a platform-specific decoder.\r\n  const decodeRE = /&(gt|lt|amp|apos|quot);/g;\r\n  const decodeMap = {\r\n      gt: '>',\r\n      lt: '<',\r\n      amp: '&',\r\n      apos: \"'\",\r\n      quot: '\"'\r\n  };\r\n  const defaultParserOptions = {\r\n      delimiters: [`{{`, `}}`],\r\n      getNamespace: () => 0 /* HTML */,\r\n      getTextMode: () => 0 /* DATA */,\r\n      isVoidTag: NO,\r\n      isPreTag: NO,\r\n      isCustomElement: NO,\r\n      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n      onError: defaultOnError,\r\n      onWarn: defaultOnWarn,\r\n      comments: true\r\n  };\r\n  function baseParse(content, options = {}) {\r\n      const context = createParserContext(content, options);\r\n      const start = getCursor(context);\r\n      return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));\r\n  }\r\n  function createParserContext(content, rawOptions) {\r\n      const options = extend({}, defaultParserOptions);\r\n      let key;\r\n      for (key in rawOptions) {\r\n          // @ts-ignore\r\n          options[key] =\r\n              rawOptions[key] === undefined\r\n                  ? defaultParserOptions[key]\r\n                  : rawOptions[key];\r\n      }\r\n      return {\r\n          options,\r\n          column: 1,\r\n          line: 1,\r\n          offset: 0,\r\n          originalSource: content,\r\n          source: content,\r\n          inPre: false,\r\n          inVPre: false,\r\n          onWarn: options.onWarn\r\n      };\r\n  }\r\n  function parseChildren(context, mode, ancestors) {\r\n      const parent = last(ancestors);\r\n      const ns = parent ? parent.ns : 0 /* HTML */;\r\n      const nodes = [];\r\n      while (!isEnd(context, mode, ancestors)) {\r\n          const s = context.source;\r\n          let node = undefined;\r\n          if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {\r\n              if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n                  // '{{'\r\n                  node = parseInterpolation(context, mode);\r\n              }\r\n              else if (mode === 0 /* DATA */ && s[0] === '<') {\r\n                  // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n                  if (s.length === 1) {\r\n                      emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);\r\n                  }\r\n                  else if (s[1] === '!') {\r\n                      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n                      if (startsWith(s, '<!--')) {\r\n                          node = parseComment(context);\r\n                      }\r\n                      else if (startsWith(s, '<!DOCTYPE')) {\r\n                          // Ignore DOCTYPE by a limitation.\r\n                          node = parseBogusComment(context);\r\n                      }\r\n                      else if (startsWith(s, '<![CDATA[')) {\r\n                          if (ns !== 0 /* HTML */) {\r\n                              node = parseCDATA(context, ancestors);\r\n                          }\r\n                          else {\r\n                              emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);\r\n                              node = parseBogusComment(context);\r\n                          }\r\n                      }\r\n                      else {\r\n                          emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);\r\n                          node = parseBogusComment(context);\r\n                      }\r\n                  }\r\n                  else if (s[1] === '/') {\r\n                      // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n                      if (s.length === 2) {\r\n                          emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);\r\n                      }\r\n                      else if (s[2] === '>') {\r\n                          emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);\r\n                          advanceBy(context, 3);\r\n                          continue;\r\n                      }\r\n                      else if (/[a-z]/i.test(s[2])) {\r\n                          emitError(context, 23 /* X_INVALID_END_TAG */);\r\n                          parseTag(context, 1 /* End */, parent);\r\n                          continue;\r\n                      }\r\n                      else {\r\n                          emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\r\n                          node = parseBogusComment(context);\r\n                      }\r\n                  }\r\n                  else if (/[a-z]/i.test(s[1])) {\r\n                      node = parseElement(context, ancestors);\r\n                  }\r\n                  else if (s[1] === '?') {\r\n                      emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\r\n                      node = parseBogusComment(context);\r\n                  }\r\n                  else {\r\n                      emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\r\n                  }\r\n              }\r\n          }\r\n          if (!node) {\r\n              node = parseText(context, mode);\r\n          }\r\n          if (isArray(node)) {\r\n              for (let i = 0; i < node.length; i++) {\r\n                  pushNode(nodes, node[i]);\r\n              }\r\n          }\r\n          else {\r\n              pushNode(nodes, node);\r\n          }\r\n      }\r\n      // Whitespace handling strategy like v2\r\n      let removedWhitespace = false;\r\n      if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {\r\n          const shouldCondense = context.options.whitespace !== 'preserve';\r\n          for (let i = 0; i < nodes.length; i++) {\r\n              const node = nodes[i];\r\n              if (!context.inPre && node.type === 2 /* TEXT */) {\r\n                  if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n                      const prev = nodes[i - 1];\r\n                      const next = nodes[i + 1];\r\n                      // Remove if:\r\n                      // - the whitespace is the first or last node, or:\r\n                      // - (condense mode) the whitespace is adjacent to a comment, or:\r\n                      // - (condense mode) the whitespace is between two elements AND contains newline\r\n                      if (!prev ||\r\n                          !next ||\r\n                          (shouldCondense &&\r\n                              (prev.type === 3 /* COMMENT */ ||\r\n                                  next.type === 3 /* COMMENT */ ||\r\n                                  (prev.type === 1 /* ELEMENT */ &&\r\n                                      next.type === 1 /* ELEMENT */ &&\r\n                                      /[\\r\\n]/.test(node.content))))) {\r\n                          removedWhitespace = true;\r\n                          nodes[i] = null;\r\n                      }\r\n                      else {\r\n                          // Otherwise, the whitespace is condensed into a single space\r\n                          node.content = ' ';\r\n                      }\r\n                  }\r\n                  else if (shouldCondense) {\r\n                      // in condense mode, consecutive whitespaces in text are condensed\r\n                      // down to a single space.\r\n                      node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ');\r\n                  }\r\n              }\r\n              // Remove comment nodes if desired by configuration.\r\n              else if (node.type === 3 /* COMMENT */ && !context.options.comments) {\r\n                  removedWhitespace = true;\r\n                  nodes[i] = null;\r\n              }\r\n          }\r\n          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n              // remove leading newline per html spec\r\n              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n              const first = nodes[0];\r\n              if (first && first.type === 2 /* TEXT */) {\r\n                  first.content = first.content.replace(/^\\r?\\n/, '');\r\n              }\r\n          }\r\n      }\r\n      return removedWhitespace ? nodes.filter(Boolean) : nodes;\r\n  }\r\n  function pushNode(nodes, node) {\r\n      if (node.type === 2 /* TEXT */) {\r\n          const prev = last(nodes);\r\n          // Merge if both this and the previous node are text and those are\r\n          // consecutive. This happens for cases like \"a < b\".\r\n          if (prev &&\r\n              prev.type === 2 /* TEXT */ &&\r\n              prev.loc.end.offset === node.loc.start.offset) {\r\n              prev.content += node.content;\r\n              prev.loc.end = node.loc.end;\r\n              prev.loc.source += node.loc.source;\r\n              return;\r\n          }\r\n      }\r\n      nodes.push(node);\r\n  }\r\n  function parseCDATA(context, ancestors) {\r\n      advanceBy(context, 9);\r\n      const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\r\n      if (context.source.length === 0) {\r\n          emitError(context, 6 /* EOF_IN_CDATA */);\r\n      }\r\n      else {\r\n          advanceBy(context, 3);\r\n      }\r\n      return nodes;\r\n  }\r\n  function parseComment(context) {\r\n      const start = getCursor(context);\r\n      let content;\r\n      // Regular comment.\r\n      const match = /--(\\!)?>/.exec(context.source);\r\n      if (!match) {\r\n          content = context.source.slice(4);\r\n          advanceBy(context, context.source.length);\r\n          emitError(context, 7 /* EOF_IN_COMMENT */);\r\n      }\r\n      else {\r\n          if (match.index <= 3) {\r\n              emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\r\n          }\r\n          if (match[1]) {\r\n              emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);\r\n          }\r\n          content = context.source.slice(4, match.index);\r\n          // Advancing with reporting nested comments.\r\n          const s = context.source.slice(0, match.index);\r\n          let prevIndex = 1, nestedIndex = 0;\r\n          while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\r\n              advanceBy(context, nestedIndex - prevIndex + 1);\r\n              if (nestedIndex + 4 < s.length) {\r\n                  emitError(context, 16 /* NESTED_COMMENT */);\r\n              }\r\n              prevIndex = nestedIndex + 1;\r\n          }\r\n          advanceBy(context, match.index + match[0].length - prevIndex + 1);\r\n      }\r\n      return {\r\n          type: 3 /* COMMENT */,\r\n          content,\r\n          loc: getSelection(context, start)\r\n      };\r\n  }\r\n  function parseBogusComment(context) {\r\n      const start = getCursor(context);\r\n      const contentStart = context.source[1] === '?' ? 1 : 2;\r\n      let content;\r\n      const closeIndex = context.source.indexOf('>');\r\n      if (closeIndex === -1) {\r\n          content = context.source.slice(contentStart);\r\n          advanceBy(context, context.source.length);\r\n      }\r\n      else {\r\n          content = context.source.slice(contentStart, closeIndex);\r\n          advanceBy(context, closeIndex + 1);\r\n      }\r\n      return {\r\n          type: 3 /* COMMENT */,\r\n          content,\r\n          loc: getSelection(context, start)\r\n      };\r\n  }\r\n  function parseElement(context, ancestors) {\r\n      // Start tag.\r\n      const wasInPre = context.inPre;\r\n      const wasInVPre = context.inVPre;\r\n      const parent = last(ancestors);\r\n      const element = parseTag(context, 0 /* Start */, parent);\r\n      const isPreBoundary = context.inPre && !wasInPre;\r\n      const isVPreBoundary = context.inVPre && !wasInVPre;\r\n      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n          // #4030 self-closing <pre> tag\r\n          if (isPreBoundary) {\r\n              context.inPre = false;\r\n          }\r\n          if (isVPreBoundary) {\r\n              context.inVPre = false;\r\n          }\r\n          return element;\r\n      }\r\n      // Children.\r\n      ancestors.push(element);\r\n      const mode = context.options.getTextMode(element, parent);\r\n      const children = parseChildren(context, mode, ancestors);\r\n      ancestors.pop();\r\n      element.children = children;\r\n      // End tag.\r\n      if (startsWithEndTagOpen(context.source, element.tag)) {\r\n          parseTag(context, 1 /* End */, parent);\r\n      }\r\n      else {\r\n          emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);\r\n          if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\r\n              const first = children[0];\r\n              if (first && startsWith(first.loc.source, '<!--')) {\r\n                  emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\r\n              }\r\n          }\r\n      }\r\n      element.loc = getSelection(context, element.loc.start);\r\n      if (isPreBoundary) {\r\n          context.inPre = false;\r\n      }\r\n      if (isVPreBoundary) {\r\n          context.inVPre = false;\r\n      }\r\n      return element;\r\n  }\r\n  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);\r\n  function parseTag(context, type, parent) {\r\n      // Tag open.\r\n      const start = getCursor(context);\r\n      const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\r\n      const tag = match[1];\r\n      const ns = context.options.getNamespace(tag, parent);\r\n      advanceBy(context, match[0].length);\r\n      advanceSpaces(context);\r\n      // save current state in case we need to re-parse attributes with v-pre\r\n      const cursor = getCursor(context);\r\n      const currentSource = context.source;\r\n      // check <pre> tag\r\n      if (context.options.isPreTag(tag)) {\r\n          context.inPre = true;\r\n      }\r\n      // Attributes.\r\n      let props = parseAttributes(context, type);\r\n      // check v-pre\r\n      if (type === 0 /* Start */ &&\r\n          !context.inVPre &&\r\n          props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {\r\n          context.inVPre = true;\r\n          // reset context\r\n          extend(context, cursor);\r\n          context.source = currentSource;\r\n          // re-parse attrs and filter out v-pre itself\r\n          props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');\r\n      }\r\n      // Tag close.\r\n      let isSelfClosing = false;\r\n      if (context.source.length === 0) {\r\n          emitError(context, 9 /* EOF_IN_TAG */);\r\n      }\r\n      else {\r\n          isSelfClosing = startsWith(context.source, '/>');\r\n          if (type === 1 /* End */ && isSelfClosing) {\r\n              emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);\r\n          }\r\n          advanceBy(context, isSelfClosing ? 2 : 1);\r\n      }\r\n      if (type === 1 /* End */) {\r\n          return;\r\n      }\r\n      let tagType = 0 /* ELEMENT */;\r\n      if (!context.inVPre) {\r\n          if (tag === 'slot') {\r\n              tagType = 2 /* SLOT */;\r\n          }\r\n          else if (tag === 'template') {\r\n              if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {\r\n                  tagType = 3 /* TEMPLATE */;\r\n              }\r\n          }\r\n          else if (isComponent(tag, props, context)) {\r\n              tagType = 1 /* COMPONENT */;\r\n          }\r\n      }\r\n      return {\r\n          type: 1 /* ELEMENT */,\r\n          ns,\r\n          tag,\r\n          tagType,\r\n          props,\r\n          isSelfClosing,\r\n          children: [],\r\n          loc: getSelection(context, start),\r\n          codegenNode: undefined // to be created during transform phase\r\n      };\r\n  }\r\n  function isComponent(tag, props, context) {\r\n      const options = context.options;\r\n      if (options.isCustomElement(tag)) {\r\n          return false;\r\n      }\r\n      if (tag === 'component' ||\r\n          /^[A-Z]/.test(tag) ||\r\n          isCoreComponent(tag) ||\r\n          (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n          (options.isNativeTag && !options.isNativeTag(tag))) {\r\n          return true;\r\n      }\r\n      // at this point the tag should be a native tag, but check for potential \"is\"\r\n      // casting\r\n      for (let i = 0; i < props.length; i++) {\r\n          const p = props[i];\r\n          if (p.type === 6 /* ATTRIBUTE */) {\r\n              if (p.name === 'is' && p.value) {\r\n                  if (p.value.content.startsWith('vue:')) {\r\n                      return true;\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              // directive\r\n              // v-is (TODO Deprecate)\r\n              if (p.name === 'is') {\r\n                  return true;\r\n              }\r\n              else if (\r\n              // :is on plain element - only treat as component in compat mode\r\n              p.name === 'bind' &&\r\n                  isStaticArgOf(p.arg, 'is') &&\r\n                  false &&\r\n                  checkCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {\r\n                  return true;\r\n              }\r\n          }\r\n      }\r\n  }\r\n  function parseAttributes(context, type) {\r\n      const props = [];\r\n      const attributeNames = new Set();\r\n      while (context.source.length > 0 &&\r\n          !startsWith(context.source, '>') &&\r\n          !startsWith(context.source, '/>')) {\r\n          if (startsWith(context.source, '/')) {\r\n              emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);\r\n              advanceBy(context, 1);\r\n              advanceSpaces(context);\r\n              continue;\r\n          }\r\n          if (type === 1 /* End */) {\r\n              emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);\r\n          }\r\n          const attr = parseAttribute(context, attributeNames);\r\n          // Trim whitespace between class\r\n          // https://github.com/vuejs/core/issues/4251\r\n          if (attr.type === 6 /* ATTRIBUTE */ &&\r\n              attr.value &&\r\n              attr.name === 'class') {\r\n              attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim();\r\n          }\r\n          if (type === 0 /* Start */) {\r\n              props.push(attr);\r\n          }\r\n          if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n              emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\r\n          }\r\n          advanceSpaces(context);\r\n      }\r\n      return props;\r\n  }\r\n  function parseAttribute(context, nameSet) {\r\n      // Name.\r\n      const start = getCursor(context);\r\n      const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\r\n      const name = match[0];\r\n      if (nameSet.has(name)) {\r\n          emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);\r\n      }\r\n      nameSet.add(name);\r\n      if (name[0] === '=') {\r\n          emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\r\n      }\r\n      {\r\n          const pattern = /[\"'<]/g;\r\n          let m;\r\n          while ((m = pattern.exec(name))) {\r\n              emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\r\n          }\r\n      }\r\n      advanceBy(context, name.length);\r\n      // Value\r\n      let value = undefined;\r\n      if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n          advanceSpaces(context);\r\n          advanceBy(context, 1);\r\n          advanceSpaces(context);\r\n          value = parseAttributeValue(context);\r\n          if (!value) {\r\n              emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);\r\n          }\r\n      }\r\n      const loc = getSelection(context, start);\r\n      if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\r\n          const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\r\n          let isPropShorthand = startsWith(name, '.');\r\n          let dirName = match[1] ||\r\n              (isPropShorthand || startsWith(name, ':')\r\n                  ? 'bind'\r\n                  : startsWith(name, '@')\r\n                      ? 'on'\r\n                      : 'slot');\r\n          let arg;\r\n          if (match[2]) {\r\n              const isSlot = dirName === 'slot';\r\n              const startOffset = name.lastIndexOf(match[2]);\r\n              const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));\r\n              let content = match[2];\r\n              let isStatic = true;\r\n              if (content.startsWith('[')) {\r\n                  isStatic = false;\r\n                  if (!content.endsWith(']')) {\r\n                      emitError(context, 27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\r\n                      content = content.slice(1);\r\n                  }\r\n                  else {\r\n                      content = content.slice(1, content.length - 1);\r\n                  }\r\n              }\r\n              else if (isSlot) {\r\n                  // #1241 special case for v-slot: vuetify relies extensively on slot\r\n                  // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\r\n                  // supports such usage so we are keeping it consistent with 2.x.\r\n                  content += match[3] || '';\r\n              }\r\n              arg = {\r\n                  type: 4 /* SIMPLE_EXPRESSION */,\r\n                  content,\r\n                  isStatic,\r\n                  constType: isStatic\r\n                      ? 3 /* CAN_STRINGIFY */\r\n                      : 0 /* NOT_CONSTANT */,\r\n                  loc\r\n              };\r\n          }\r\n          if (value && value.isQuoted) {\r\n              const valueLoc = value.loc;\r\n              valueLoc.start.offset++;\r\n              valueLoc.start.column++;\r\n              valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\r\n              valueLoc.source = valueLoc.source.slice(1, -1);\r\n          }\r\n          const modifiers = match[3] ? match[3].slice(1).split('.') : [];\r\n          if (isPropShorthand)\r\n              modifiers.push('prop');\r\n          return {\r\n              type: 7 /* DIRECTIVE */,\r\n              name: dirName,\r\n              exp: value && {\r\n                  type: 4 /* SIMPLE_EXPRESSION */,\r\n                  content: value.content,\r\n                  isStatic: false,\r\n                  // Treat as non-constant by default. This can be potentially set to\r\n                  // other values by `transformExpression` to make it eligible for hoisting.\r\n                  constType: 0 /* NOT_CONSTANT */,\r\n                  loc: value.loc\r\n              },\r\n              arg,\r\n              modifiers,\r\n              loc\r\n          };\r\n      }\r\n      // missing directive name or illegal directive name\r\n      if (!context.inVPre && startsWith(name, 'v-')) {\r\n          emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);\r\n      }\r\n      return {\r\n          type: 6 /* ATTRIBUTE */,\r\n          name,\r\n          value: value && {\r\n              type: 2 /* TEXT */,\r\n              content: value.content,\r\n              loc: value.loc\r\n          },\r\n          loc\r\n      };\r\n  }\r\n  function parseAttributeValue(context) {\r\n      const start = getCursor(context);\r\n      let content;\r\n      const quote = context.source[0];\r\n      const isQuoted = quote === `\"` || quote === `'`;\r\n      if (isQuoted) {\r\n          // Quoted value.\r\n          advanceBy(context, 1);\r\n          const endIndex = context.source.indexOf(quote);\r\n          if (endIndex === -1) {\r\n              content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\r\n          }\r\n          else {\r\n              content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\r\n              advanceBy(context, 1);\r\n          }\r\n      }\r\n      else {\r\n          // Unquoted\r\n          const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\r\n          if (!match) {\r\n              return undefined;\r\n          }\r\n          const unexpectedChars = /[\"'<=`]/g;\r\n          let m;\r\n          while ((m = unexpectedChars.exec(match[0]))) {\r\n              emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\r\n          }\r\n          content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\r\n      }\r\n      return { content, isQuoted, loc: getSelection(context, start) };\r\n  }\r\n  function parseInterpolation(context, mode) {\r\n      const [open, close] = context.options.delimiters;\r\n      const closeIndex = context.source.indexOf(close, open.length);\r\n      if (closeIndex === -1) {\r\n          emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);\r\n          return undefined;\r\n      }\r\n      const start = getCursor(context);\r\n      advanceBy(context, open.length);\r\n      const innerStart = getCursor(context);\r\n      const innerEnd = getCursor(context);\r\n      const rawContentLength = closeIndex - open.length;\r\n      const rawContent = context.source.slice(0, rawContentLength);\r\n      const preTrimContent = parseTextData(context, rawContentLength, mode);\r\n      const content = preTrimContent.trim();\r\n      const startOffset = preTrimContent.indexOf(content);\r\n      if (startOffset > 0) {\r\n          advancePositionWithMutation(innerStart, rawContent, startOffset);\r\n      }\r\n      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\r\n      advancePositionWithMutation(innerEnd, rawContent, endOffset);\r\n      advanceBy(context, close.length);\r\n      return {\r\n          type: 5 /* INTERPOLATION */,\r\n          content: {\r\n              type: 4 /* SIMPLE_EXPRESSION */,\r\n              isStatic: false,\r\n              // Set `isConstant` to false by default and will decide in transformExpression\r\n              constType: 0 /* NOT_CONSTANT */,\r\n              content,\r\n              loc: getSelection(context, innerStart, innerEnd)\r\n          },\r\n          loc: getSelection(context, start)\r\n      };\r\n  }\r\n  function parseText(context, mode) {\r\n      const endTokens = mode === 3 /* CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];\r\n      let endIndex = context.source.length;\r\n      for (let i = 0; i < endTokens.length; i++) {\r\n          const index = context.source.indexOf(endTokens[i], 1);\r\n          if (index !== -1 && endIndex > index) {\r\n              endIndex = index;\r\n          }\r\n      }\r\n      const start = getCursor(context);\r\n      const content = parseTextData(context, endIndex, mode);\r\n      return {\r\n          type: 2 /* TEXT */,\r\n          content,\r\n          loc: getSelection(context, start)\r\n      };\r\n  }\r\n  /**\r\n   * Get text data with a given length from the current location.\r\n   * This translates HTML entities in the text data.\r\n   */\r\n  function parseTextData(context, length, mode) {\r\n      const rawText = context.source.slice(0, length);\r\n      advanceBy(context, length);\r\n      if (mode === 2 /* RAWTEXT */ ||\r\n          mode === 3 /* CDATA */ ||\r\n          !rawText.includes('&')) {\r\n          return rawText;\r\n      }\r\n      else {\r\n          // DATA or RCDATA containing \"&\"\". Entity decoding required.\r\n          return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);\r\n      }\r\n  }\r\n  function getCursor(context) {\r\n      const { column, line, offset } = context;\r\n      return { column, line, offset };\r\n  }\r\n  function getSelection(context, start, end) {\r\n      end = end || getCursor(context);\r\n      return {\r\n          start,\r\n          end,\r\n          source: context.originalSource.slice(start.offset, end.offset)\r\n      };\r\n  }\r\n  function last(xs) {\r\n      return xs[xs.length - 1];\r\n  }\r\n  function startsWith(source, searchString) {\r\n      return source.startsWith(searchString);\r\n  }\r\n  function advanceBy(context, numberOfCharacters) {\r\n      const { source } = context;\r\n      advancePositionWithMutation(context, source, numberOfCharacters);\r\n      context.source = source.slice(numberOfCharacters);\r\n  }\r\n  function advanceSpaces(context) {\r\n      const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\r\n      if (match) {\r\n          advanceBy(context, match[0].length);\r\n      }\r\n  }\r\n  function getNewPosition(context, start, numberOfCharacters) {\r\n      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\r\n  }\r\n  function emitError(context, code, offset, loc = getCursor(context)) {\r\n      if (offset) {\r\n          loc.offset += offset;\r\n          loc.column += offset;\r\n      }\r\n      context.options.onError(createCompilerError(code, {\r\n          start: loc,\r\n          end: loc,\r\n          source: ''\r\n      }));\r\n  }\r\n  function isEnd(context, mode, ancestors) {\r\n      const s = context.source;\r\n      switch (mode) {\r\n          case 0 /* DATA */:\r\n              if (startsWith(s, '</')) {\r\n                  // TODO: probably bad performance\r\n                  for (let i = ancestors.length - 1; i >= 0; --i) {\r\n                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n                          return true;\r\n                      }\r\n                  }\r\n              }\r\n              break;\r\n          case 1 /* RCDATA */:\r\n          case 2 /* RAWTEXT */: {\r\n              const parent = last(ancestors);\r\n              if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n                  return true;\r\n              }\r\n              break;\r\n          }\r\n          case 3 /* CDATA */:\r\n              if (startsWith(s, ']]>')) {\r\n                  return true;\r\n              }\r\n              break;\r\n      }\r\n      return !s;\r\n  }\r\n  function startsWithEndTagOpen(source, tag) {\r\n      return (startsWith(source, '</') &&\r\n          source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&\r\n          /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>'));\r\n  }\n\n  function hoistStatic(root, context) {\r\n      walk(root, context, \r\n      // Root node is unfortunately non-hoistable due to potential parent\r\n      // fallthrough attributes.\r\n      isSingleElementRoot(root, root.children[0]));\r\n  }\r\n  function isSingleElementRoot(root, child) {\r\n      const { children } = root;\r\n      return (children.length === 1 &&\r\n          child.type === 1 /* ELEMENT */ &&\r\n          !isSlotOutlet(child));\r\n  }\r\n  function walk(node, context, doNotHoistNode = false) {\r\n      const { children } = node;\r\n      const originalCount = children.length;\r\n      let hoistedCount = 0;\r\n      for (let i = 0; i < children.length; i++) {\r\n          const child = children[i];\r\n          // only plain elements & text calls are eligible for hoisting.\r\n          if (child.type === 1 /* ELEMENT */ &&\r\n              child.tagType === 0 /* ELEMENT */) {\r\n              const constantType = doNotHoistNode\r\n                  ? 0 /* NOT_CONSTANT */\r\n                  : getConstantType(child, context);\r\n              if (constantType > 0 /* NOT_CONSTANT */) {\r\n                  if (constantType >= 2 /* CAN_HOIST */) {\r\n                      child.codegenNode.patchFlag =\r\n                          -1 /* HOISTED */ + (` /* HOISTED */` );\r\n                      child.codegenNode = context.hoist(child.codegenNode);\r\n                      hoistedCount++;\r\n                      continue;\r\n                  }\r\n              }\r\n              else {\r\n                  // node may contain dynamic children, but its props may be eligible for\r\n                  // hoisting.\r\n                  const codegenNode = child.codegenNode;\r\n                  if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                      const flag = getPatchFlag(codegenNode);\r\n                      if ((!flag ||\r\n                          flag === 512 /* NEED_PATCH */ ||\r\n                          flag === 1 /* TEXT */) &&\r\n                          getGeneratedPropsConstantType(child, context) >=\r\n                              2 /* CAN_HOIST */) {\r\n                          const props = getNodeProps(child);\r\n                          if (props) {\r\n                              codegenNode.props = context.hoist(props);\r\n                          }\r\n                      }\r\n                      if (codegenNode.dynamicProps) {\r\n                          codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n          else if (child.type === 12 /* TEXT_CALL */ &&\r\n              getConstantType(child.content, context) >= 2 /* CAN_HOIST */) {\r\n              child.codegenNode = context.hoist(child.codegenNode);\r\n              hoistedCount++;\r\n          }\r\n          // walk further\r\n          if (child.type === 1 /* ELEMENT */) {\r\n              const isComponent = child.tagType === 1 /* COMPONENT */;\r\n              if (isComponent) {\r\n                  context.scopes.vSlot++;\r\n              }\r\n              walk(child, context);\r\n              if (isComponent) {\r\n                  context.scopes.vSlot--;\r\n              }\r\n          }\r\n          else if (child.type === 11 /* FOR */) {\r\n              // Do not hoist v-for single child because it has to be a block\r\n              walk(child, context, child.children.length === 1);\r\n          }\r\n          else if (child.type === 9 /* IF */) {\r\n              for (let i = 0; i < child.branches.length; i++) {\r\n                  // Do not hoist v-if single child because it has to be a block\r\n                  walk(child.branches[i], context, child.branches[i].children.length === 1);\r\n              }\r\n          }\r\n      }\r\n      if (hoistedCount && context.transformHoist) {\r\n          context.transformHoist(children, context, node);\r\n      }\r\n      // all children were hoisted - the entire children array is hoistable.\r\n      if (hoistedCount &&\r\n          hoistedCount === originalCount &&\r\n          node.type === 1 /* ELEMENT */ &&\r\n          node.tagType === 0 /* ELEMENT */ &&\r\n          node.codegenNode &&\r\n          node.codegenNode.type === 13 /* VNODE_CALL */ &&\r\n          isArray(node.codegenNode.children)) {\r\n          node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));\r\n      }\r\n  }\r\n  function getConstantType(node, context) {\r\n      const { constantCache } = context;\r\n      switch (node.type) {\r\n          case 1 /* ELEMENT */:\r\n              if (node.tagType !== 0 /* ELEMENT */) {\r\n                  return 0 /* NOT_CONSTANT */;\r\n              }\r\n              const cached = constantCache.get(node);\r\n              if (cached !== undefined) {\r\n                  return cached;\r\n              }\r\n              const codegenNode = node.codegenNode;\r\n              if (codegenNode.type !== 13 /* VNODE_CALL */) {\r\n                  return 0 /* NOT_CONSTANT */;\r\n              }\r\n              if (codegenNode.isBlock &&\r\n                  node.tag !== 'svg' &&\r\n                  node.tag !== 'foreignObject') {\r\n                  return 0 /* NOT_CONSTANT */;\r\n              }\r\n              const flag = getPatchFlag(codegenNode);\r\n              if (!flag) {\r\n                  let returnType = 3 /* CAN_STRINGIFY */;\r\n                  // Element itself has no patch flag. However we still need to check:\r\n                  // 1. Even for a node with no patch flag, it is possible for it to contain\r\n                  // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n                  // injected keys or cached event handlers. Therefore we need to always\r\n                  // check the codegenNode's props to be sure.\r\n                  const generatedPropsType = getGeneratedPropsConstantType(node, context);\r\n                  if (generatedPropsType === 0 /* NOT_CONSTANT */) {\r\n                      constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                      return 0 /* NOT_CONSTANT */;\r\n                  }\r\n                  if (generatedPropsType < returnType) {\r\n                      returnType = generatedPropsType;\r\n                  }\r\n                  // 2. its children.\r\n                  for (let i = 0; i < node.children.length; i++) {\r\n                      const childType = getConstantType(node.children[i], context);\r\n                      if (childType === 0 /* NOT_CONSTANT */) {\r\n                          constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                          return 0 /* NOT_CONSTANT */;\r\n                      }\r\n                      if (childType < returnType) {\r\n                          returnType = childType;\r\n                      }\r\n                  }\r\n                  // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n                  // type, check if any of the props can cause the type to be lowered\r\n                  // we can skip can_patch because it's guaranteed by the absence of a\r\n                  // patchFlag.\r\n                  if (returnType > 1 /* CAN_SKIP_PATCH */) {\r\n                      for (let i = 0; i < node.props.length; i++) {\r\n                          const p = node.props[i];\r\n                          if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {\r\n                              const expType = getConstantType(p.exp, context);\r\n                              if (expType === 0 /* NOT_CONSTANT */) {\r\n                                  constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                                  return 0 /* NOT_CONSTANT */;\r\n                              }\r\n                              if (expType < returnType) {\r\n                                  returnType = expType;\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  // only svg/foreignObject could be block here, however if they are\r\n                  // static then they don't need to be blocks since there will be no\r\n                  // nested updates.\r\n                  if (codegenNode.isBlock) {\r\n                      context.removeHelper(OPEN_BLOCK);\r\n                      context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));\r\n                      codegenNode.isBlock = false;\r\n                      context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));\r\n                  }\r\n                  constantCache.set(node, returnType);\r\n                  return returnType;\r\n              }\r\n              else {\r\n                  constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                  return 0 /* NOT_CONSTANT */;\r\n              }\r\n          case 2 /* TEXT */:\r\n          case 3 /* COMMENT */:\r\n              return 3 /* CAN_STRINGIFY */;\r\n          case 9 /* IF */:\r\n          case 11 /* FOR */:\r\n          case 10 /* IF_BRANCH */:\r\n              return 0 /* NOT_CONSTANT */;\r\n          case 5 /* INTERPOLATION */:\r\n          case 12 /* TEXT_CALL */:\r\n              return getConstantType(node.content, context);\r\n          case 4 /* SIMPLE_EXPRESSION */:\r\n              return node.constType;\r\n          case 8 /* COMPOUND_EXPRESSION */:\r\n              let returnType = 3 /* CAN_STRINGIFY */;\r\n              for (let i = 0; i < node.children.length; i++) {\r\n                  const child = node.children[i];\r\n                  if (isString(child) || isSymbol(child)) {\r\n                      continue;\r\n                  }\r\n                  const childType = getConstantType(child, context);\r\n                  if (childType === 0 /* NOT_CONSTANT */) {\r\n                      return 0 /* NOT_CONSTANT */;\r\n                  }\r\n                  else if (childType < returnType) {\r\n                      returnType = childType;\r\n                  }\r\n              }\r\n              return returnType;\r\n          default:\r\n              return 0 /* NOT_CONSTANT */;\r\n      }\r\n  }\r\n  const allowHoistedHelperSet = new Set([\r\n      NORMALIZE_CLASS,\r\n      NORMALIZE_STYLE,\r\n      NORMALIZE_PROPS,\r\n      GUARD_REACTIVE_PROPS\r\n  ]);\r\n  function getConstantTypeOfHelperCall(value, context) {\r\n      if (value.type === 14 /* JS_CALL_EXPRESSION */ &&\r\n          !isString(value.callee) &&\r\n          allowHoistedHelperSet.has(value.callee)) {\r\n          const arg = value.arguments[0];\r\n          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n              return getConstantType(arg, context);\r\n          }\r\n          else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {\r\n              // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\r\n              return getConstantTypeOfHelperCall(arg, context);\r\n          }\r\n      }\r\n      return 0 /* NOT_CONSTANT */;\r\n  }\r\n  function getGeneratedPropsConstantType(node, context) {\r\n      let returnType = 3 /* CAN_STRINGIFY */;\r\n      const props = getNodeProps(node);\r\n      if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n          const { properties } = props;\r\n          for (let i = 0; i < properties.length; i++) {\r\n              const { key, value } = properties[i];\r\n              const keyType = getConstantType(key, context);\r\n              if (keyType === 0 /* NOT_CONSTANT */) {\r\n                  return keyType;\r\n              }\r\n              if (keyType < returnType) {\r\n                  returnType = keyType;\r\n              }\r\n              let valueType;\r\n              if (value.type === 4 /* SIMPLE_EXPRESSION */) {\r\n                  valueType = getConstantType(value, context);\r\n              }\r\n              else if (value.type === 14 /* JS_CALL_EXPRESSION */) {\r\n                  // some helper calls can be hoisted,\r\n                  // such as the `normalizeProps` generated by the compiler for pre-normalize class,\r\n                  // in this case we need to respect the ConstantType of the helper's arguments\r\n                  valueType = getConstantTypeOfHelperCall(value, context);\r\n              }\r\n              else {\r\n                  valueType = 0 /* NOT_CONSTANT */;\r\n              }\r\n              if (valueType === 0 /* NOT_CONSTANT */) {\r\n                  return valueType;\r\n              }\r\n              if (valueType < returnType) {\r\n                  returnType = valueType;\r\n              }\r\n          }\r\n      }\r\n      return returnType;\r\n  }\r\n  function getNodeProps(node) {\r\n      const codegenNode = node.codegenNode;\r\n      if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n          return codegenNode.props;\r\n      }\r\n  }\r\n  function getPatchFlag(node) {\r\n      const flag = node.patchFlag;\r\n      return flag ? parseInt(flag, 10) : undefined;\r\n  }\n\n  function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {\r\n      const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/);\r\n      const context = {\r\n          // options\r\n          selfName: nameMatch && capitalize(camelize(nameMatch[1])),\r\n          prefixIdentifiers,\r\n          hoistStatic,\r\n          cacheHandlers,\r\n          nodeTransforms,\r\n          directiveTransforms,\r\n          transformHoist,\r\n          isBuiltInComponent,\r\n          isCustomElement,\r\n          expressionPlugins,\r\n          scopeId,\r\n          slotted,\r\n          ssr,\r\n          inSSR,\r\n          ssrCssVars,\r\n          bindingMetadata,\r\n          inline,\r\n          isTS,\r\n          onError,\r\n          onWarn,\r\n          compatConfig,\r\n          // state\r\n          root,\r\n          helpers: new Map(),\r\n          components: new Set(),\r\n          directives: new Set(),\r\n          hoists: [],\r\n          imports: [],\r\n          constantCache: new Map(),\r\n          temps: 0,\r\n          cached: 0,\r\n          identifiers: Object.create(null),\r\n          scopes: {\r\n              vFor: 0,\r\n              vSlot: 0,\r\n              vPre: 0,\r\n              vOnce: 0\r\n          },\r\n          parent: null,\r\n          currentNode: root,\r\n          childIndex: 0,\r\n          inVOnce: false,\r\n          // methods\r\n          helper(name) {\r\n              const count = context.helpers.get(name) || 0;\r\n              context.helpers.set(name, count + 1);\r\n              return name;\r\n          },\r\n          removeHelper(name) {\r\n              const count = context.helpers.get(name);\r\n              if (count) {\r\n                  const currentCount = count - 1;\r\n                  if (!currentCount) {\r\n                      context.helpers.delete(name);\r\n                  }\r\n                  else {\r\n                      context.helpers.set(name, currentCount);\r\n                  }\r\n              }\r\n          },\r\n          helperString(name) {\r\n              return `_${helperNameMap[context.helper(name)]}`;\r\n          },\r\n          replaceNode(node) {\r\n              /* istanbul ignore if */\r\n              {\r\n                  if (!context.currentNode) {\r\n                      throw new Error(`Node being replaced is already removed.`);\r\n                  }\r\n                  if (!context.parent) {\r\n                      throw new Error(`Cannot replace root node.`);\r\n                  }\r\n              }\r\n              context.parent.children[context.childIndex] = context.currentNode = node;\r\n          },\r\n          removeNode(node) {\r\n              if (!context.parent) {\r\n                  throw new Error(`Cannot remove root node.`);\r\n              }\r\n              const list = context.parent.children;\r\n              const removalIndex = node\r\n                  ? list.indexOf(node)\r\n                  : context.currentNode\r\n                      ? context.childIndex\r\n                      : -1;\r\n              /* istanbul ignore if */\r\n              if (removalIndex < 0) {\r\n                  throw new Error(`node being removed is not a child of current parent`);\r\n              }\r\n              if (!node || node === context.currentNode) {\r\n                  // current node removed\r\n                  context.currentNode = null;\r\n                  context.onNodeRemoved();\r\n              }\r\n              else {\r\n                  // sibling node removed\r\n                  if (context.childIndex > removalIndex) {\r\n                      context.childIndex--;\r\n                      context.onNodeRemoved();\r\n                  }\r\n              }\r\n              context.parent.children.splice(removalIndex, 1);\r\n          },\r\n          onNodeRemoved: () => { },\r\n          addIdentifiers(exp) {\r\n          },\r\n          removeIdentifiers(exp) {\r\n          },\r\n          hoist(exp) {\r\n              if (isString(exp))\r\n                  exp = createSimpleExpression(exp);\r\n              context.hoists.push(exp);\r\n              const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);\r\n              identifier.hoisted = exp;\r\n              return identifier;\r\n          },\r\n          cache(exp, isVNode = false) {\r\n              return createCacheExpression(context.cached++, exp, isVNode);\r\n          }\r\n      };\r\n      return context;\r\n  }\r\n  function transform(root, options) {\r\n      const context = createTransformContext(root, options);\r\n      traverseNode(root, context);\r\n      if (options.hoistStatic) {\r\n          hoistStatic(root, context);\r\n      }\r\n      if (!options.ssr) {\r\n          createRootCodegen(root, context);\r\n      }\r\n      // finalize meta information\r\n      root.helpers = [...context.helpers.keys()];\r\n      root.components = [...context.components];\r\n      root.directives = [...context.directives];\r\n      root.imports = context.imports;\r\n      root.hoists = context.hoists;\r\n      root.temps = context.temps;\r\n      root.cached = context.cached;\r\n  }\r\n  function createRootCodegen(root, context) {\r\n      const { helper } = context;\r\n      const { children } = root;\r\n      if (children.length === 1) {\r\n          const child = children[0];\r\n          // if the single child is an element, turn it into a block.\r\n          if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n              // single element root is never hoisted so codegenNode will never be\r\n              // SimpleExpressionNode\r\n              const codegenNode = child.codegenNode;\r\n              if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                  makeBlock(codegenNode, context);\r\n              }\r\n              root.codegenNode = codegenNode;\r\n          }\r\n          else {\r\n              // - single <slot/>, IfNode, ForNode: already blocks.\r\n              // - single text node: always patched.\r\n              // root codegen falls through via genNode()\r\n              root.codegenNode = child;\r\n          }\r\n      }\r\n      else if (children.length > 1) {\r\n          // root has multiple nodes - return a fragment block.\r\n          let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n          let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];\r\n          // check if the fragment actually contains a single valid child with\r\n          // the rest being comments\r\n          if (children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {\r\n              patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;\r\n              patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;\r\n          }\r\n          root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, undefined, false /* isComponent */);\r\n      }\r\n      else ;\r\n  }\r\n  function traverseChildren(parent, context) {\r\n      let i = 0;\r\n      const nodeRemoved = () => {\r\n          i--;\r\n      };\r\n      for (; i < parent.children.length; i++) {\r\n          const child = parent.children[i];\r\n          if (isString(child))\r\n              continue;\r\n          context.parent = parent;\r\n          context.childIndex = i;\r\n          context.onNodeRemoved = nodeRemoved;\r\n          traverseNode(child, context);\r\n      }\r\n  }\r\n  function traverseNode(node, context) {\r\n      context.currentNode = node;\r\n      // apply transform plugins\r\n      const { nodeTransforms } = context;\r\n      const exitFns = [];\r\n      for (let i = 0; i < nodeTransforms.length; i++) {\r\n          const onExit = nodeTransforms[i](node, context);\r\n          if (onExit) {\r\n              if (isArray(onExit)) {\r\n                  exitFns.push(...onExit);\r\n              }\r\n              else {\r\n                  exitFns.push(onExit);\r\n              }\r\n          }\r\n          if (!context.currentNode) {\r\n              // node was removed\r\n              return;\r\n          }\r\n          else {\r\n              // node may have been replaced\r\n              node = context.currentNode;\r\n          }\r\n      }\r\n      switch (node.type) {\r\n          case 3 /* COMMENT */:\r\n              if (!context.ssr) {\r\n                  // inject import for the Comment symbol, which is needed for creating\r\n                  // comment nodes with `createVNode`\r\n                  context.helper(CREATE_COMMENT);\r\n              }\r\n              break;\r\n          case 5 /* INTERPOLATION */:\r\n              // no need to traverse, but we need to inject toString helper\r\n              if (!context.ssr) {\r\n                  context.helper(TO_DISPLAY_STRING);\r\n              }\r\n              break;\r\n          // for container types, further traverse downwards\r\n          case 9 /* IF */:\r\n              for (let i = 0; i < node.branches.length; i++) {\r\n                  traverseNode(node.branches[i], context);\r\n              }\r\n              break;\r\n          case 10 /* IF_BRANCH */:\r\n          case 11 /* FOR */:\r\n          case 1 /* ELEMENT */:\r\n          case 0 /* ROOT */:\r\n              traverseChildren(node, context);\r\n              break;\r\n      }\r\n      // exit transforms\r\n      context.currentNode = node;\r\n      let i = exitFns.length;\r\n      while (i--) {\r\n          exitFns[i]();\r\n      }\r\n  }\r\n  function createStructuralDirectiveTransform(name, fn) {\r\n      const matches = isString(name)\r\n          ? (n) => n === name\r\n          : (n) => name.test(n);\r\n      return (node, context) => {\r\n          if (node.type === 1 /* ELEMENT */) {\r\n              const { props } = node;\r\n              // structural directive transforms are not concerned with slots\r\n              // as they are handled separately in vSlot.ts\r\n              if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\r\n                  return;\r\n              }\r\n              const exitFns = [];\r\n              for (let i = 0; i < props.length; i++) {\r\n                  const prop = props[i];\r\n                  if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\r\n                      // structural directives are removed to avoid infinite recursion\r\n                      // also we remove them *before* applying so that it can further\r\n                      // traverse itself in case it moves the node around\r\n                      props.splice(i, 1);\r\n                      i--;\r\n                      const onExit = fn(node, prop, context);\r\n                      if (onExit)\r\n                          exitFns.push(onExit);\r\n                  }\r\n              }\r\n              return exitFns;\r\n          }\r\n      };\r\n  }\n\n  const PURE_ANNOTATION = `/*#__PURE__*/`;\r\n  function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {\r\n      const context = {\r\n          mode,\r\n          prefixIdentifiers,\r\n          sourceMap,\r\n          filename,\r\n          scopeId,\r\n          optimizeImports,\r\n          runtimeGlobalName,\r\n          runtimeModuleName,\r\n          ssrRuntimeModuleName,\r\n          ssr,\r\n          isTS,\r\n          inSSR,\r\n          source: ast.loc.source,\r\n          code: ``,\r\n          column: 1,\r\n          line: 1,\r\n          offset: 0,\r\n          indentLevel: 0,\r\n          pure: false,\r\n          map: undefined,\r\n          helper(key) {\r\n              return `_${helperNameMap[key]}`;\r\n          },\r\n          push(code, node) {\r\n              context.code += code;\r\n          },\r\n          indent() {\r\n              newline(++context.indentLevel);\r\n          },\r\n          deindent(withoutNewLine = false) {\r\n              if (withoutNewLine) {\r\n                  --context.indentLevel;\r\n              }\r\n              else {\r\n                  newline(--context.indentLevel);\r\n              }\r\n          },\r\n          newline() {\r\n              newline(context.indentLevel);\r\n          }\r\n      };\r\n      function newline(n) {\r\n          context.push('\\n' + `  `.repeat(n));\r\n      }\r\n      return context;\r\n  }\r\n  function generate(ast, options = {}) {\r\n      const context = createCodegenContext(ast, options);\r\n      if (options.onContextCreated)\r\n          options.onContextCreated(context);\r\n      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\r\n      const hasHelpers = ast.helpers.length > 0;\r\n      const useWithBlock = !prefixIdentifiers && mode !== 'module';\r\n      // preambles\r\n      // in setup() inline mode, the preamble is generated in a sub context\r\n      // and returned separately.\r\n      const preambleContext = context;\r\n      {\r\n          genFunctionPreamble(ast, preambleContext);\r\n      }\r\n      // enter render function\r\n      const functionName = ssr ? `ssrRender` : `render`;\r\n      const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];\r\n      const signature = args.join(', ');\r\n      {\r\n          push(`function ${functionName}(${signature}) {`);\r\n      }\r\n      indent();\r\n      if (useWithBlock) {\r\n          push(`with (_ctx) {`);\r\n          indent();\r\n          // function mode const declarations should be inside with block\r\n          // also they should be renamed to avoid collision with user properties\r\n          if (hasHelpers) {\r\n              push(`const { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\r\n                .join(', ')} } = _Vue`);\r\n              push(`\\n`);\r\n              newline();\r\n          }\r\n      }\r\n      // generate asset resolution statements\r\n      if (ast.components.length) {\r\n          genAssets(ast.components, 'component', context);\r\n          if (ast.directives.length || ast.temps > 0) {\r\n              newline();\r\n          }\r\n      }\r\n      if (ast.directives.length) {\r\n          genAssets(ast.directives, 'directive', context);\r\n          if (ast.temps > 0) {\r\n              newline();\r\n          }\r\n      }\r\n      if (ast.temps > 0) {\r\n          push(`let `);\r\n          for (let i = 0; i < ast.temps; i++) {\r\n              push(`${i > 0 ? `, ` : ``}_temp${i}`);\r\n          }\r\n      }\r\n      if (ast.components.length || ast.directives.length || ast.temps) {\r\n          push(`\\n`);\r\n          newline();\r\n      }\r\n      // generate the VNode tree expression\r\n      if (!ssr) {\r\n          push(`return `);\r\n      }\r\n      if (ast.codegenNode) {\r\n          genNode(ast.codegenNode, context);\r\n      }\r\n      else {\r\n          push(`null`);\r\n      }\r\n      if (useWithBlock) {\r\n          deindent();\r\n          push(`}`);\r\n      }\r\n      deindent();\r\n      push(`}`);\r\n      return {\r\n          ast,\r\n          code: context.code,\r\n          preamble: ``,\r\n          // SourceMapGenerator does have toJSON() method but it's not in the types\r\n          map: context.map ? context.map.toJSON() : undefined\r\n      };\r\n  }\r\n  function genFunctionPreamble(ast, context) {\r\n      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;\r\n      const VueBinding = runtimeGlobalName;\r\n      const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\r\n      // Generate const declaration for helpers\r\n      // In prefix mode, we place the const declaration at top so it's done\r\n      // only once; But if we not prefixing, we place the declaration inside the\r\n      // with block so it doesn't incur the `in` check cost for every helper access.\r\n      if (ast.helpers.length > 0) {\r\n          {\r\n              // \"with\" mode.\r\n              // save Vue in a separate variable to avoid collision\r\n              push(`const _Vue = ${VueBinding}\\n`);\r\n              // in \"with\" mode, helpers are declared inside the with block to avoid\r\n              // has check cost, but hoists are lifted out of the function - we need\r\n              // to provide the helper here.\r\n              if (ast.hoists.length) {\r\n                  const staticHelpers = [\r\n                      CREATE_VNODE,\r\n                      CREATE_ELEMENT_VNODE,\r\n                      CREATE_COMMENT,\r\n                      CREATE_TEXT,\r\n                      CREATE_STATIC\r\n                  ]\r\n                      .filter(helper => ast.helpers.includes(helper))\r\n                      .map(aliasHelper)\r\n                      .join(', ');\r\n                  push(`const { ${staticHelpers} } = _Vue\\n`);\r\n              }\r\n          }\r\n      }\r\n      genHoists(ast.hoists, context);\r\n      newline();\r\n      push(`return `);\r\n  }\r\n  function genAssets(assets, type, { helper, push, newline, isTS }) {\r\n      const resolver = helper(type === 'component'\r\n              ? RESOLVE_COMPONENT\r\n              : RESOLVE_DIRECTIVE);\r\n      for (let i = 0; i < assets.length; i++) {\r\n          let id = assets[i];\r\n          // potential component implicit self-reference inferred from SFC filename\r\n          const maybeSelfReference = id.endsWith('__self');\r\n          if (maybeSelfReference) {\r\n              id = id.slice(0, -6);\r\n          }\r\n          push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);\r\n          if (i < assets.length - 1) {\r\n              newline();\r\n          }\r\n      }\r\n  }\r\n  function genHoists(hoists, context) {\r\n      if (!hoists.length) {\r\n          return;\r\n      }\r\n      context.pure = true;\r\n      const { push, newline, helper, scopeId, mode } = context;\r\n      newline();\r\n      for (let i = 0; i < hoists.length; i++) {\r\n          const exp = hoists[i];\r\n          if (exp) {\r\n              push(`const _hoisted_${i + 1} = ${``}`);\r\n              genNode(exp, context);\r\n              newline();\r\n          }\r\n      }\r\n      context.pure = false;\r\n  }\r\n  function isText$1(n) {\r\n      return (isString(n) ||\r\n          n.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n          n.type === 2 /* TEXT */ ||\r\n          n.type === 5 /* INTERPOLATION */ ||\r\n          n.type === 8 /* COMPOUND_EXPRESSION */);\r\n  }\r\n  function genNodeListAsArray(nodes, context) {\r\n      const multilines = nodes.length > 3 ||\r\n          (nodes.some(n => isArray(n) || !isText$1(n)));\r\n      context.push(`[`);\r\n      multilines && context.indent();\r\n      genNodeList(nodes, context, multilines);\r\n      multilines && context.deindent();\r\n      context.push(`]`);\r\n  }\r\n  function genNodeList(nodes, context, multilines = false, comma = true) {\r\n      const { push, newline } = context;\r\n      for (let i = 0; i < nodes.length; i++) {\r\n          const node = nodes[i];\r\n          if (isString(node)) {\r\n              push(node);\r\n          }\r\n          else if (isArray(node)) {\r\n              genNodeListAsArray(node, context);\r\n          }\r\n          else {\r\n              genNode(node, context);\r\n          }\r\n          if (i < nodes.length - 1) {\r\n              if (multilines) {\r\n                  comma && push(',');\r\n                  newline();\r\n              }\r\n              else {\r\n                  comma && push(', ');\r\n              }\r\n          }\r\n      }\r\n  }\r\n  function genNode(node, context) {\r\n      if (isString(node)) {\r\n          context.push(node);\r\n          return;\r\n      }\r\n      if (isSymbol(node)) {\r\n          context.push(context.helper(node));\r\n          return;\r\n      }\r\n      switch (node.type) {\r\n          case 1 /* ELEMENT */:\r\n          case 9 /* IF */:\r\n          case 11 /* FOR */:\r\n              assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +\r\n                      `Apply appropriate transforms first.`);\r\n              genNode(node.codegenNode, context);\r\n              break;\r\n          case 2 /* TEXT */:\r\n              genText(node, context);\r\n              break;\r\n          case 4 /* SIMPLE_EXPRESSION */:\r\n              genExpression(node, context);\r\n              break;\r\n          case 5 /* INTERPOLATION */:\r\n              genInterpolation(node, context);\r\n              break;\r\n          case 12 /* TEXT_CALL */:\r\n              genNode(node.codegenNode, context);\r\n              break;\r\n          case 8 /* COMPOUND_EXPRESSION */:\r\n              genCompoundExpression(node, context);\r\n              break;\r\n          case 3 /* COMMENT */:\r\n              genComment(node, context);\r\n              break;\r\n          case 13 /* VNODE_CALL */:\r\n              genVNodeCall(node, context);\r\n              break;\r\n          case 14 /* JS_CALL_EXPRESSION */:\r\n              genCallExpression(node, context);\r\n              break;\r\n          case 15 /* JS_OBJECT_EXPRESSION */:\r\n              genObjectExpression(node, context);\r\n              break;\r\n          case 17 /* JS_ARRAY_EXPRESSION */:\r\n              genArrayExpression(node, context);\r\n              break;\r\n          case 18 /* JS_FUNCTION_EXPRESSION */:\r\n              genFunctionExpression(node, context);\r\n              break;\r\n          case 19 /* JS_CONDITIONAL_EXPRESSION */:\r\n              genConditionalExpression(node, context);\r\n              break;\r\n          case 20 /* JS_CACHE_EXPRESSION */:\r\n              genCacheExpression(node, context);\r\n              break;\r\n          case 21 /* JS_BLOCK_STATEMENT */:\r\n              genNodeList(node.body, context, true, false);\r\n              break;\r\n          // SSR only types\r\n          case 22 /* JS_TEMPLATE_LITERAL */:\r\n              break;\r\n          case 23 /* JS_IF_STATEMENT */:\r\n              break;\r\n          case 24 /* JS_ASSIGNMENT_EXPRESSION */:\r\n              break;\r\n          case 25 /* JS_SEQUENCE_EXPRESSION */:\r\n              break;\r\n          case 26 /* JS_RETURN_STATEMENT */:\r\n              break;\r\n          /* istanbul ignore next */\r\n          case 10 /* IF_BRANCH */:\r\n              // noop\r\n              break;\r\n          default:\r\n              {\r\n                  assert(false, `unhandled codegen node type: ${node.type}`);\r\n                  // make sure we exhaust all possible types\r\n                  const exhaustiveCheck = node;\r\n                  return exhaustiveCheck;\r\n              }\r\n      }\r\n  }\r\n  function genText(node, context) {\r\n      context.push(JSON.stringify(node.content), node);\r\n  }\r\n  function genExpression(node, context) {\r\n      const { content, isStatic } = node;\r\n      context.push(isStatic ? JSON.stringify(content) : content, node);\r\n  }\r\n  function genInterpolation(node, context) {\r\n      const { push, helper, pure } = context;\r\n      if (pure)\r\n          push(PURE_ANNOTATION);\r\n      push(`${helper(TO_DISPLAY_STRING)}(`);\r\n      genNode(node.content, context);\r\n      push(`)`);\r\n  }\r\n  function genCompoundExpression(node, context) {\r\n      for (let i = 0; i < node.children.length; i++) {\r\n          const child = node.children[i];\r\n          if (isString(child)) {\r\n              context.push(child);\r\n          }\r\n          else {\r\n              genNode(child, context);\r\n          }\r\n      }\r\n  }\r\n  function genExpressionAsPropertyKey(node, context) {\r\n      const { push } = context;\r\n      if (node.type === 8 /* COMPOUND_EXPRESSION */) {\r\n          push(`[`);\r\n          genCompoundExpression(node, context);\r\n          push(`]`);\r\n      }\r\n      else if (node.isStatic) {\r\n          // only quote keys if necessary\r\n          const text = isSimpleIdentifier(node.content)\r\n              ? node.content\r\n              : JSON.stringify(node.content);\r\n          push(text, node);\r\n      }\r\n      else {\r\n          push(`[${node.content}]`, node);\r\n      }\r\n  }\r\n  function genComment(node, context) {\r\n      const { push, helper, pure } = context;\r\n      if (pure) {\r\n          push(PURE_ANNOTATION);\r\n      }\r\n      push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);\r\n  }\r\n  function genVNodeCall(node, context) {\r\n      const { push, helper, pure } = context;\r\n      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;\r\n      if (directives) {\r\n          push(helper(WITH_DIRECTIVES) + `(`);\r\n      }\r\n      if (isBlock) {\r\n          push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\r\n      }\r\n      if (pure) {\r\n          push(PURE_ANNOTATION);\r\n      }\r\n      const callHelper = isBlock\r\n          ? getVNodeBlockHelper(context.inSSR, isComponent)\r\n          : getVNodeHelper(context.inSSR, isComponent);\r\n      push(helper(callHelper) + `(`, node);\r\n      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\r\n      push(`)`);\r\n      if (isBlock) {\r\n          push(`)`);\r\n      }\r\n      if (directives) {\r\n          push(`, `);\r\n          genNode(directives, context);\r\n          push(`)`);\r\n      }\r\n  }\r\n  function genNullableArgs(args) {\r\n      let i = args.length;\r\n      while (i--) {\r\n          if (args[i] != null)\r\n              break;\r\n      }\r\n      return args.slice(0, i + 1).map(arg => arg || `null`);\r\n  }\r\n  // JavaScript\r\n  function genCallExpression(node, context) {\r\n      const { push, helper, pure } = context;\r\n      const callee = isString(node.callee) ? node.callee : helper(node.callee);\r\n      if (pure) {\r\n          push(PURE_ANNOTATION);\r\n      }\r\n      push(callee + `(`, node);\r\n      genNodeList(node.arguments, context);\r\n      push(`)`);\r\n  }\r\n  function genObjectExpression(node, context) {\r\n      const { push, indent, deindent, newline } = context;\r\n      const { properties } = node;\r\n      if (!properties.length) {\r\n          push(`{}`, node);\r\n          return;\r\n      }\r\n      const multilines = properties.length > 1 ||\r\n          (properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));\r\n      push(multilines ? `{` : `{ `);\r\n      multilines && indent();\r\n      for (let i = 0; i < properties.length; i++) {\r\n          const { key, value } = properties[i];\r\n          // key\r\n          genExpressionAsPropertyKey(key, context);\r\n          push(`: `);\r\n          // value\r\n          genNode(value, context);\r\n          if (i < properties.length - 1) {\r\n              // will only reach this if it's multilines\r\n              push(`,`);\r\n              newline();\r\n          }\r\n      }\r\n      multilines && deindent();\r\n      push(multilines ? `}` : ` }`);\r\n  }\r\n  function genArrayExpression(node, context) {\r\n      genNodeListAsArray(node.elements, context);\r\n  }\r\n  function genFunctionExpression(node, context) {\r\n      const { push, indent, deindent } = context;\r\n      const { params, returns, body, newline, isSlot } = node;\r\n      if (isSlot) {\r\n          // wrap slot functions with owner context\r\n          push(`_${helperNameMap[WITH_CTX]}(`);\r\n      }\r\n      push(`(`, node);\r\n      if (isArray(params)) {\r\n          genNodeList(params, context);\r\n      }\r\n      else if (params) {\r\n          genNode(params, context);\r\n      }\r\n      push(`) => `);\r\n      if (newline || body) {\r\n          push(`{`);\r\n          indent();\r\n      }\r\n      if (returns) {\r\n          if (newline) {\r\n              push(`return `);\r\n          }\r\n          if (isArray(returns)) {\r\n              genNodeListAsArray(returns, context);\r\n          }\r\n          else {\r\n              genNode(returns, context);\r\n          }\r\n      }\r\n      else if (body) {\r\n          genNode(body, context);\r\n      }\r\n      if (newline || body) {\r\n          deindent();\r\n          push(`}`);\r\n      }\r\n      if (isSlot) {\r\n          push(`)`);\r\n      }\r\n  }\r\n  function genConditionalExpression(node, context) {\r\n      const { test, consequent, alternate, newline: needNewline } = node;\r\n      const { push, indent, deindent, newline } = context;\r\n      if (test.type === 4 /* SIMPLE_EXPRESSION */) {\r\n          const needsParens = !isSimpleIdentifier(test.content);\r\n          needsParens && push(`(`);\r\n          genExpression(test, context);\r\n          needsParens && push(`)`);\r\n      }\r\n      else {\r\n          push(`(`);\r\n          genNode(test, context);\r\n          push(`)`);\r\n      }\r\n      needNewline && indent();\r\n      context.indentLevel++;\r\n      needNewline || push(` `);\r\n      push(`? `);\r\n      genNode(consequent, context);\r\n      context.indentLevel--;\r\n      needNewline && newline();\r\n      needNewline || push(` `);\r\n      push(`: `);\r\n      const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;\r\n      if (!isNested) {\r\n          context.indentLevel++;\r\n      }\r\n      genNode(alternate, context);\r\n      if (!isNested) {\r\n          context.indentLevel--;\r\n      }\r\n      needNewline && deindent(true /* without newline */);\r\n  }\r\n  function genCacheExpression(node, context) {\r\n      const { push, helper, indent, deindent, newline } = context;\r\n      push(`_cache[${node.index}] || (`);\r\n      if (node.isVNode) {\r\n          indent();\r\n          push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\r\n          newline();\r\n      }\r\n      push(`_cache[${node.index}] = `);\r\n      genNode(node.value, context);\r\n      if (node.isVNode) {\r\n          push(`,`);\r\n          newline();\r\n          push(`${helper(SET_BLOCK_TRACKING)}(1),`);\r\n          newline();\r\n          push(`_cache[${node.index}]`);\r\n          deindent();\r\n      }\r\n      push(`)`);\r\n  }\n\n  // these keywords should not appear inside expressions, but operators like\r\n  // typeof, instanceof and in are allowed\r\n  const prohibitedKeywordRE = new RegExp('\\\\b' +\r\n      ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\r\n          'super,throw,while,yield,delete,export,import,return,switch,default,' +\r\n          'extends,finally,continue,debugger,function,arguments,typeof,void')\r\n          .split(',')\r\n          .join('\\\\b|\\\\b') +\r\n      '\\\\b');\r\n  // strip strings in expressions\r\n  const stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n  /**\r\n   * Validate a non-prefixed expression.\r\n   * This is only called when using the in-browser runtime compiler since it\r\n   * doesn't prefix expressions.\r\n   */\r\n  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\r\n      const exp = node.content;\r\n      // empty expressions are validated per-directive since some directives\r\n      // do allow empty expressions.\r\n      if (!exp.trim()) {\r\n          return;\r\n      }\r\n      try {\r\n          new Function(asRawStatements\r\n              ? ` ${exp} `\r\n              : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\r\n      }\r\n      catch (e) {\r\n          let message = e.message;\r\n          const keywordMatch = exp\r\n              .replace(stripStringRE, '')\r\n              .match(prohibitedKeywordRE);\r\n          if (keywordMatch) {\r\n              message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`;\r\n          }\r\n          context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));\r\n      }\r\n  }\n\n  const transformExpression = (node, context) => {\r\n      if (node.type === 5 /* INTERPOLATION */) {\r\n          node.content = processExpression(node.content, context);\r\n      }\r\n      else if (node.type === 1 /* ELEMENT */) {\r\n          // handle directives on element\r\n          for (let i = 0; i < node.props.length; i++) {\r\n              const dir = node.props[i];\r\n              // do not process for v-on & v-for since they are special handled\r\n              if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {\r\n                  const exp = dir.exp;\r\n                  const arg = dir.arg;\r\n                  // do not process exp if this is v-on:arg - we need special handling\r\n                  // for wrapping inline statements.\r\n                  if (exp &&\r\n                      exp.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                      !(dir.name === 'on' && arg)) {\r\n                      dir.exp = processExpression(exp, context, \r\n                      // slot args must be processed as function params\r\n                      dir.name === 'slot');\r\n                  }\r\n                  if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\r\n                      dir.arg = processExpression(arg, context);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n  };\r\n  // Important: since this function uses Node.js only dependencies, it should\r\n  // always be used with a leading !true check so that it can be\r\n  // tree-shaken from the browser build.\r\n  function processExpression(node, context, \r\n  // some expressions like v-slot props & v-for aliases should be parsed as\r\n  // function params\r\n  asParams = false, \r\n  // v-on handler values may contain multiple statements\r\n  asRawStatements = false, localVars = Object.create(context.identifiers)) {\r\n      {\r\n          {\r\n              // simple in-browser validation (same logic in 2.x)\r\n              validateBrowserExpression(node, context, asParams, asRawStatements);\r\n          }\r\n          return node;\r\n      }\r\n  }\n\n  const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\r\n      return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n          // #1587: We need to dynamically increment the key based on the current\r\n          // node's sibling nodes, since chained v-if/else branches are\r\n          // rendered at the same depth\r\n          const siblings = context.parent.children;\r\n          let i = siblings.indexOf(ifNode);\r\n          let key = 0;\r\n          while (i-- >= 0) {\r\n              const sibling = siblings[i];\r\n              if (sibling && sibling.type === 9 /* IF */) {\r\n                  key += sibling.branches.length;\r\n              }\r\n          }\r\n          // Exit callback. Complete the codegenNode when all children have been\r\n          // transformed.\r\n          return () => {\r\n              if (isRoot) {\r\n                  ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\r\n              }\r\n              else {\r\n                  // attach this branch's codegen node to the v-if root.\r\n                  const parentCondition = getParentCondition(ifNode.codegenNode);\r\n                  parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\r\n              }\r\n          };\r\n      });\r\n  });\r\n  // target-agnostic transform used for both Client and SSR\r\n  function processIf(node, dir, context, processCodegen) {\r\n      if (dir.name !== 'else' &&\r\n          (!dir.exp || !dir.exp.content.trim())) {\r\n          const loc = dir.exp ? dir.exp.loc : node.loc;\r\n          context.onError(createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc));\r\n          dir.exp = createSimpleExpression(`true`, false, loc);\r\n      }\r\n      if (dir.exp) {\r\n          validateBrowserExpression(dir.exp, context);\r\n      }\r\n      if (dir.name === 'if') {\r\n          const branch = createIfBranch(node, dir);\r\n          const ifNode = {\r\n              type: 9 /* IF */,\r\n              loc: node.loc,\r\n              branches: [branch]\r\n          };\r\n          context.replaceNode(ifNode);\r\n          if (processCodegen) {\r\n              return processCodegen(ifNode, branch, true);\r\n          }\r\n      }\r\n      else {\r\n          // locate the adjacent v-if\r\n          const siblings = context.parent.children;\r\n          const comments = [];\r\n          let i = siblings.indexOf(node);\r\n          while (i-- >= -1) {\r\n              const sibling = siblings[i];\r\n              if (sibling && sibling.type === 3 /* COMMENT */) {\r\n                  context.removeNode(sibling);\r\n                  comments.unshift(sibling);\r\n                  continue;\r\n              }\r\n              if (sibling &&\r\n                  sibling.type === 2 /* TEXT */ &&\r\n                  !sibling.content.trim().length) {\r\n                  context.removeNode(sibling);\r\n                  continue;\r\n              }\r\n              if (sibling && sibling.type === 9 /* IF */) {\r\n                  // Check if v-else was followed by v-else-if\r\n                  if (dir.name === 'else-if' &&\r\n                      sibling.branches[sibling.branches.length - 1].condition === undefined) {\r\n                      context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\r\n                  }\r\n                  // move the node to the if node's branches\r\n                  context.removeNode();\r\n                  const branch = createIfBranch(node, dir);\r\n                  if (comments.length &&\r\n                      // #3619 ignore comments if the v-if is direct child of <transition>\r\n                      !(context.parent &&\r\n                          context.parent.type === 1 /* ELEMENT */ &&\r\n                          isBuiltInType(context.parent.tag, 'transition'))) {\r\n                      branch.children = [...comments, ...branch.children];\r\n                  }\r\n                  // check if user is forcing same key on different branches\r\n                  {\r\n                      const key = branch.userKey;\r\n                      if (key) {\r\n                          sibling.branches.forEach(({ userKey }) => {\r\n                              if (isSameKey(userKey, key)) {\r\n                                  context.onError(createCompilerError(29 /* X_V_IF_SAME_KEY */, branch.userKey.loc));\r\n                              }\r\n                          });\r\n                      }\r\n                  }\r\n                  sibling.branches.push(branch);\r\n                  const onExit = processCodegen && processCodegen(sibling, branch, false);\r\n                  // since the branch was removed, it will not be traversed.\r\n                  // make sure to traverse here.\r\n                  traverseNode(branch, context);\r\n                  // call on exit\r\n                  if (onExit)\r\n                      onExit();\r\n                  // make sure to reset currentNode after traversal to indicate this\r\n                  // node has been removed.\r\n                  context.currentNode = null;\r\n              }\r\n              else {\r\n                  context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\r\n              }\r\n              break;\r\n          }\r\n      }\r\n  }\r\n  function createIfBranch(node, dir) {\r\n      return {\r\n          type: 10 /* IF_BRANCH */,\r\n          loc: node.loc,\r\n          condition: dir.name === 'else' ? undefined : dir.exp,\r\n          children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')\r\n              ? node.children\r\n              : [node],\r\n          userKey: findProp(node, `key`)\r\n      };\r\n  }\r\n  function createCodegenNodeForBranch(branch, keyIndex, context) {\r\n      if (branch.condition) {\r\n          return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \r\n          // make sure to pass in asBlock: true so that the comment node call\r\n          // closes the current block.\r\n          createCallExpression(context.helper(CREATE_COMMENT), [\r\n              '\"v-if\"' ,\r\n              'true'\r\n          ]));\r\n      }\r\n      else {\r\n          return createChildrenCodegenNode(branch, keyIndex, context);\r\n      }\r\n  }\r\n  function createChildrenCodegenNode(branch, keyIndex, context) {\r\n      const { helper } = context;\r\n      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));\r\n      const { children } = branch;\r\n      const firstChild = children[0];\r\n      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;\r\n      if (needFragmentWrapper) {\r\n          if (children.length === 1 && firstChild.type === 11 /* FOR */) {\r\n              // optimize away nested fragments when child is a ForNode\r\n              const vnodeCall = firstChild.codegenNode;\r\n              injectProp(vnodeCall, keyProperty, context);\r\n              return vnodeCall;\r\n          }\r\n          else {\r\n              let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n              let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];\r\n              // check if the fragment actually contains a single valid child with\r\n              // the rest being comments\r\n              if (children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {\r\n                  patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;\r\n                  patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;\r\n              }\r\n              return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, false, false /* isComponent */, branch.loc);\r\n          }\r\n      }\r\n      else {\r\n          const ret = firstChild.codegenNode;\r\n          const vnodeCall = getMemoedVNodeCall(ret);\r\n          // Change createVNode to createBlock.\r\n          if (vnodeCall.type === 13 /* VNODE_CALL */) {\r\n              makeBlock(vnodeCall, context);\r\n          }\r\n          // inject branch key\r\n          injectProp(vnodeCall, keyProperty, context);\r\n          return ret;\r\n      }\r\n  }\r\n  function isSameKey(a, b) {\r\n      if (!a || a.type !== b.type) {\r\n          return false;\r\n      }\r\n      if (a.type === 6 /* ATTRIBUTE */) {\r\n          if (a.value.content !== b.value.content) {\r\n              return false;\r\n          }\r\n      }\r\n      else {\r\n          // directive\r\n          const exp = a.exp;\r\n          const branchExp = b.exp;\r\n          if (exp.type !== branchExp.type) {\r\n              return false;\r\n          }\r\n          if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||\r\n              exp.isStatic !== branchExp.isStatic ||\r\n              exp.content !== branchExp.content) {\r\n              return false;\r\n          }\r\n      }\r\n      return true;\r\n  }\r\n  function getParentCondition(node) {\r\n      while (true) {\r\n          if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n              if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                  node = node.alternate;\r\n              }\r\n              else {\r\n                  return node;\r\n              }\r\n          }\r\n          else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {\r\n              node = node.value;\r\n          }\r\n      }\r\n  }\n\n  const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {\r\n      const { helper, removeHelper } = context;\r\n      return processFor(node, dir, context, forNode => {\r\n          // create the loop render function expression now, and add the\r\n          // iterator on exit after all children have been traversed\r\n          const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n              forNode.source\r\n          ]);\r\n          const isTemplate = isTemplateNode(node);\r\n          const memo = findDir(node, 'memo');\r\n          const keyProp = findProp(node, `key`);\r\n          const keyExp = keyProp &&\r\n              (keyProp.type === 6 /* ATTRIBUTE */\r\n                  ? createSimpleExpression(keyProp.value.content, true)\r\n                  : keyProp.exp);\r\n          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;\r\n          const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n              forNode.source.constType > 0 /* NOT_CONSTANT */;\r\n          const fragmentFlag = isStableFragment\r\n              ? 64 /* STABLE_FRAGMENT */\r\n              : keyProp\r\n                  ? 128 /* KEYED_FRAGMENT */\r\n                  : 256 /* UNKEYED_FRAGMENT */;\r\n          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +\r\n              (` /* ${PatchFlagNames[fragmentFlag]} */` ), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);\r\n          return () => {\r\n              // finish the codegen now that all children have been traversed\r\n              let childBlock;\r\n              const { children } = forNode;\r\n              // check <template v-for> key placement\r\n              if (isTemplate) {\r\n                  node.children.some(c => {\r\n                      if (c.type === 1 /* ELEMENT */) {\r\n                          const key = findProp(c, 'key');\r\n                          if (key) {\r\n                              context.onError(createCompilerError(33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));\r\n                              return true;\r\n                          }\r\n                      }\r\n                  });\r\n              }\r\n              const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;\r\n              const slotOutlet = isSlotOutlet(node)\r\n                  ? node\r\n                  : isTemplate &&\r\n                      node.children.length === 1 &&\r\n                      isSlotOutlet(node.children[0])\r\n                      ? node.children[0] // api-extractor somehow fails to infer this\r\n                      : null;\r\n              if (slotOutlet) {\r\n                  // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n                  childBlock = slotOutlet.codegenNode;\r\n                  if (isTemplate && keyProperty) {\r\n                      // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n                      // we need to inject the key to the renderSlot() call.\r\n                      // the props for renderSlot is passed as the 3rd argument.\r\n                      injectProp(childBlock, keyProperty, context);\r\n                  }\r\n              }\r\n              else if (needFragmentWrapper) {\r\n                  // <template v-for=\"...\"> with text or multi-elements\r\n                  // should generate a fragment block for each loop\r\n                  childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +\r\n                      (` /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`\r\n                          ), undefined, undefined, true, undefined, false /* isComponent */);\r\n              }\r\n              else {\r\n                  // Normal element v-for. Directly use the child's codegenNode\r\n                  // but mark it as a block.\r\n                  childBlock = children[0]\r\n                      .codegenNode;\r\n                  if (isTemplate && keyProperty) {\r\n                      injectProp(childBlock, keyProperty, context);\r\n                  }\r\n                  if (childBlock.isBlock !== !isStableFragment) {\r\n                      if (childBlock.isBlock) {\r\n                          // switch from block to vnode\r\n                          removeHelper(OPEN_BLOCK);\r\n                          removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\r\n                      }\r\n                      else {\r\n                          // switch from vnode to block\r\n                          removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));\r\n                      }\r\n                  }\r\n                  childBlock.isBlock = !isStableFragment;\r\n                  if (childBlock.isBlock) {\r\n                      helper(OPEN_BLOCK);\r\n                      helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\r\n                  }\r\n                  else {\r\n                      helper(getVNodeHelper(context.inSSR, childBlock.isComponent));\r\n                  }\r\n              }\r\n              if (memo) {\r\n                  const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [\r\n                      createSimpleExpression(`_cached`)\r\n                  ]));\r\n                  loop.body = createBlockStatement([\r\n                      createCompoundExpression([`const _memo = (`, memo.exp, `)`]),\r\n                      createCompoundExpression([\r\n                          `if (_cached`,\r\n                          ...(keyExp ? [` && _cached.key === `, keyExp] : []),\r\n                          ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`\r\n                      ]),\r\n                      createCompoundExpression([`const _item = `, childBlock]),\r\n                      createSimpleExpression(`_item.memo = _memo`),\r\n                      createSimpleExpression(`return _item`)\r\n                  ]);\r\n                  renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));\r\n              }\r\n              else {\r\n                  renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\r\n              }\r\n          };\r\n      });\r\n  });\r\n  // target-agnostic transform used for both Client and SSR\r\n  function processFor(node, dir, context, processCodegen) {\r\n      if (!dir.exp) {\r\n          context.onError(createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc));\r\n          return;\r\n      }\r\n      const parseResult = parseForExpression(\r\n      // can only be simple expression because vFor transform is applied\r\n      // before expression transform.\r\n      dir.exp, context);\r\n      if (!parseResult) {\r\n          context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\r\n          return;\r\n      }\r\n      const { addIdentifiers, removeIdentifiers, scopes } = context;\r\n      const { source, value, key, index } = parseResult;\r\n      const forNode = {\r\n          type: 11 /* FOR */,\r\n          loc: dir.loc,\r\n          source,\r\n          valueAlias: value,\r\n          keyAlias: key,\r\n          objectIndexAlias: index,\r\n          parseResult,\r\n          children: isTemplateNode(node) ? node.children : [node]\r\n      };\r\n      context.replaceNode(forNode);\r\n      // bookkeeping\r\n      scopes.vFor++;\r\n      const onExit = processCodegen && processCodegen(forNode);\r\n      return () => {\r\n          scopes.vFor--;\r\n          if (onExit)\r\n              onExit();\r\n      };\r\n  }\r\n  const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n  // This regex doesn't cover the case if key or index aliases have destructuring,\r\n  // but those do not make sense in the first place, so this works in practice.\r\n  const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\n  const stripParensRE = /^\\(|\\)$/g;\r\n  function parseForExpression(input, context) {\r\n      const loc = input.loc;\r\n      const exp = input.content;\r\n      const inMatch = exp.match(forAliasRE);\r\n      if (!inMatch)\r\n          return;\r\n      const [, LHS, RHS] = inMatch;\r\n      const result = {\r\n          source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n          value: undefined,\r\n          key: undefined,\r\n          index: undefined\r\n      };\r\n      {\r\n          validateBrowserExpression(result.source, context);\r\n      }\r\n      let valueContent = LHS.trim().replace(stripParensRE, '').trim();\r\n      const trimmedOffset = LHS.indexOf(valueContent);\r\n      const iteratorMatch = valueContent.match(forIteratorRE);\r\n      if (iteratorMatch) {\r\n          valueContent = valueContent.replace(forIteratorRE, '').trim();\r\n          const keyContent = iteratorMatch[1].trim();\r\n          let keyOffset;\r\n          if (keyContent) {\r\n              keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\r\n              result.key = createAliasExpression(loc, keyContent, keyOffset);\r\n              {\r\n                  validateBrowserExpression(result.key, context, true);\r\n              }\r\n          }\r\n          if (iteratorMatch[2]) {\r\n              const indexContent = iteratorMatch[2].trim();\r\n              if (indexContent) {\r\n                  result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\r\n                      ? keyOffset + keyContent.length\r\n                      : trimmedOffset + valueContent.length));\r\n                  {\r\n                      validateBrowserExpression(result.index, context, true);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      if (valueContent) {\r\n          result.value = createAliasExpression(loc, valueContent, trimmedOffset);\r\n          {\r\n              validateBrowserExpression(result.value, context, true);\r\n          }\r\n      }\r\n      return result;\r\n  }\r\n  function createAliasExpression(range, content, offset) {\r\n      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\r\n  }\r\n  function createForLoopParams({ value, key, index }, memoArgs = []) {\r\n      return createParamsList([value, key, index, ...memoArgs]);\r\n  }\r\n  function createParamsList(args) {\r\n      let i = args.length;\r\n      while (i--) {\r\n          if (args[i])\r\n              break;\r\n      }\r\n      return args\r\n          .slice(0, i + 1)\r\n          .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));\r\n  }\n\n  const defaultFallback = createSimpleExpression(`undefined`, false);\r\n  // A NodeTransform that:\r\n  // 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n  //    by transformExpression. This is only applied in non-browser builds with\r\n  //    { prefixIdentifiers: true }.\r\n  // 2. Track v-slot depths so that we know a slot is inside another slot.\r\n  //    Note the exit callback is executed before buildSlots() on the same node,\r\n  //    so only nested slots see positive numbers.\r\n  const trackSlotScopes = (node, context) => {\r\n      if (node.type === 1 /* ELEMENT */ &&\r\n          (node.tagType === 1 /* COMPONENT */ ||\r\n              node.tagType === 3 /* TEMPLATE */)) {\r\n          // We are only checking non-empty v-slot here\r\n          // since we only care about slots that introduce scope variables.\r\n          const vSlot = findDir(node, 'slot');\r\n          if (vSlot) {\r\n              vSlot.exp;\r\n              context.scopes.vSlot++;\r\n              return () => {\r\n                  context.scopes.vSlot--;\r\n              };\r\n          }\r\n      }\r\n  };\r\n  const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\r\n  // Instead of being a DirectiveTransform, v-slot processing is called during\r\n  // transformElement to build the slots object for a component.\r\n  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\r\n      context.helper(WITH_CTX);\r\n      const { children, loc } = node;\r\n      const slotsProperties = [];\r\n      const dynamicSlots = [];\r\n      // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n      // since it likely uses a scope variable.\r\n      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n      // 1. Check for slot with slotProps on component itself.\r\n      //    <Comp v-slot=\"{ prop }\"/>\r\n      const onComponentSlot = findDir(node, 'slot', true);\r\n      if (onComponentSlot) {\r\n          const { arg, exp } = onComponentSlot;\r\n          if (arg && !isStaticExp(arg)) {\r\n              hasDynamicSlots = true;\r\n          }\r\n          slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));\r\n      }\r\n      // 2. Iterate through children and check for template slots\r\n      //    <template v-slot:foo=\"{ prop }\">\r\n      let hasTemplateSlots = false;\r\n      let hasNamedDefaultSlot = false;\r\n      const implicitDefaultChildren = [];\r\n      const seenSlotNames = new Set();\r\n      for (let i = 0; i < children.length; i++) {\r\n          const slotElement = children[i];\r\n          let slotDir;\r\n          if (!isTemplateNode(slotElement) ||\r\n              !(slotDir = findDir(slotElement, 'slot', true))) {\r\n              // not a <template v-slot>, skip.\r\n              if (slotElement.type !== 3 /* COMMENT */) {\r\n                  implicitDefaultChildren.push(slotElement);\r\n              }\r\n              continue;\r\n          }\r\n          if (onComponentSlot) {\r\n              // already has on-component slot - this is incorrect usage.\r\n              context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\r\n              break;\r\n          }\r\n          hasTemplateSlots = true;\r\n          const { children: slotChildren, loc: slotLoc } = slotElement;\r\n          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n          // check if name is dynamic.\r\n          let staticSlotName;\r\n          if (isStaticExp(slotName)) {\r\n              staticSlotName = slotName ? slotName.content : `default`;\r\n          }\r\n          else {\r\n              hasDynamicSlots = true;\r\n          }\r\n          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\r\n          // check if this slot is conditional (v-if/v-for)\r\n          let vIf;\r\n          let vElse;\r\n          let vFor;\r\n          if ((vIf = findDir(slotElement, 'if'))) {\r\n              hasDynamicSlots = true;\r\n              dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n          }\r\n          else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n              // find adjacent v-if\r\n              let j = i;\r\n              let prev;\r\n              while (j--) {\r\n                  prev = children[j];\r\n                  if (prev.type !== 3 /* COMMENT */) {\r\n                      break;\r\n                  }\r\n              }\r\n              if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n                  // remove node\r\n                  children.splice(i, 1);\r\n                  i--;\r\n                  // attach this slot to previous conditional\r\n                  let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                  while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                      conditional = conditional.alternate;\r\n                  }\r\n                  conditional.alternate = vElse.exp\r\n                      ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                      : buildDynamicSlot(slotName, slotFunction);\r\n              }\r\n              else {\r\n                  context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n              }\r\n          }\r\n          else if ((vFor = findDir(slotElement, 'for'))) {\r\n              hasDynamicSlots = true;\r\n              const parseResult = vFor.parseResult ||\r\n                  parseForExpression(vFor.exp, context);\r\n              if (parseResult) {\r\n                  // Render the dynamic slots as an array and add it to the createSlot()\r\n                  // args. The runtime knows how to handle it appropriately.\r\n                  dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                      parseResult.source,\r\n                      createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\r\n                  ]));\r\n              }\r\n              else {\r\n                  context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n              }\r\n          }\r\n          else {\r\n              // check duplicate static names\r\n              if (staticSlotName) {\r\n                  if (seenSlotNames.has(staticSlotName)) {\r\n                      context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                      continue;\r\n                  }\r\n                  seenSlotNames.add(staticSlotName);\r\n                  if (staticSlotName === 'default') {\r\n                      hasNamedDefaultSlot = true;\r\n                  }\r\n              }\r\n              slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n          }\r\n      }\r\n      if (!onComponentSlot) {\r\n          const buildDefaultSlotProperty = (props, children) => {\r\n              const fn = buildSlotFn(props, children, loc);\r\n              return createObjectProperty(`default`, fn);\r\n          };\r\n          if (!hasTemplateSlots) {\r\n              // implicit default slot (on component)\r\n              slotsProperties.push(buildDefaultSlotProperty(undefined, children));\r\n          }\r\n          else if (implicitDefaultChildren.length &&\r\n              // #3766\r\n              // with whitespace: 'preserve', whitespaces between slots will end up in\r\n              // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\r\n              implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {\r\n              // implicit default slot (mixed with named slots)\r\n              if (hasNamedDefaultSlot) {\r\n                  context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\r\n              }\r\n              else {\r\n                  slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\r\n              }\r\n          }\r\n      }\r\n      const slotFlag = hasDynamicSlots\r\n          ? 2 /* DYNAMIC */\r\n          : hasForwardedSlots(node.children)\r\n              ? 3 /* FORWARDED */\r\n              : 1 /* STABLE */;\r\n      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \r\n      // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n      // 1 = compiled and static = can skip normalization AND diff as optimized\r\n      createSimpleExpression(slotFlag + (` /* ${slotFlagsText[slotFlag]} */` ), false))), loc);\r\n      if (dynamicSlots.length) {\r\n          slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n              slots,\r\n              createArrayExpression(dynamicSlots)\r\n          ]);\r\n      }\r\n      return {\r\n          slots,\r\n          hasDynamicSlots\r\n      };\r\n  }\r\n  function buildDynamicSlot(name, fn) {\r\n      return createObjectExpression([\r\n          createObjectProperty(`name`, name),\r\n          createObjectProperty(`fn`, fn)\r\n      ]);\r\n  }\r\n  function hasForwardedSlots(children) {\r\n      for (let i = 0; i < children.length; i++) {\r\n          const child = children[i];\r\n          switch (child.type) {\r\n              case 1 /* ELEMENT */:\r\n                  if (child.tagType === 2 /* SLOT */ ||\r\n                      hasForwardedSlots(child.children)) {\r\n                      return true;\r\n                  }\r\n                  break;\r\n              case 9 /* IF */:\r\n                  if (hasForwardedSlots(child.branches))\r\n                      return true;\r\n                  break;\r\n              case 10 /* IF_BRANCH */:\r\n              case 11 /* FOR */:\r\n                  if (hasForwardedSlots(child.children))\r\n                      return true;\r\n                  break;\r\n          }\r\n      }\r\n      return false;\r\n  }\r\n  function isNonWhitespaceContent(node) {\r\n      if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)\r\n          return true;\r\n      return node.type === 2 /* TEXT */\r\n          ? !!node.content.trim()\r\n          : isNonWhitespaceContent(node.content);\r\n  }\n\n  // some directive transforms (e.g. v-model) may return a symbol for runtime\r\n  // import, which should be used instead of a resolveDirective call.\r\n  const directiveImportMap = new WeakMap();\r\n  // generate a JavaScript AST for this element's codegen\r\n  const transformElement = (node, context) => {\r\n      // perform the work on exit, after all child expressions have been\r\n      // processed and merged.\r\n      return function postTransformElement() {\r\n          node = context.currentNode;\r\n          if (!(node.type === 1 /* ELEMENT */ &&\r\n              (node.tagType === 0 /* ELEMENT */ ||\r\n                  node.tagType === 1 /* COMPONENT */))) {\r\n              return;\r\n          }\r\n          const { tag, props } = node;\r\n          const isComponent = node.tagType === 1 /* COMPONENT */;\r\n          // The goal of the transform is to create a codegenNode implementing the\r\n          // VNodeCall interface.\r\n          let vnodeTag = isComponent\r\n              ? resolveComponentType(node, context)\r\n              : `\"${tag}\"`;\r\n          const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\r\n          let vnodeProps;\r\n          let vnodeChildren;\r\n          let vnodePatchFlag;\r\n          let patchFlag = 0;\r\n          let vnodeDynamicProps;\r\n          let dynamicPropNames;\r\n          let vnodeDirectives;\r\n          let shouldUseBlock = \r\n          // dynamic component may resolve to plain elements\r\n          isDynamicComponent ||\r\n              vnodeTag === TELEPORT ||\r\n              vnodeTag === SUSPENSE ||\r\n              (!isComponent &&\r\n                  // <svg> and <foreignObject> must be forced into blocks so that block\r\n                  // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n                  // This is technically web-specific, but splitting the logic out of core\r\n                  // leads to too much unnecessary complexity.\r\n                  (tag === 'svg' || tag === 'foreignObject'));\r\n          // props\r\n          if (props.length > 0) {\r\n              const propsBuildResult = buildProps(node, context);\r\n              vnodeProps = propsBuildResult.props;\r\n              patchFlag = propsBuildResult.patchFlag;\r\n              dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n              const directives = propsBuildResult.directives;\r\n              vnodeDirectives =\r\n                  directives && directives.length\r\n                      ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\r\n                      : undefined;\r\n              if (propsBuildResult.shouldUseBlock) {\r\n                  shouldUseBlock = true;\r\n              }\r\n          }\r\n          // children\r\n          if (node.children.length > 0) {\r\n              if (vnodeTag === KEEP_ALIVE) {\r\n                  // Although a built-in component, we compile KeepAlive with raw children\r\n                  // instead of slot functions so that it can be used inside Transition\r\n                  // or other Transition-wrapping HOCs.\r\n                  // To ensure correct updates with block optimizations, we need to:\r\n                  // 1. Force keep-alive into a block. This avoids its children being\r\n                  //    collected by a parent block.\r\n                  shouldUseBlock = true;\r\n                  // 2. Force keep-alive to always be updated, since it uses raw children.\r\n                  patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                  if (node.children.length > 1) {\r\n                      context.onError(createCompilerError(45 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {\r\n                          start: node.children[0].loc.start,\r\n                          end: node.children[node.children.length - 1].loc.end,\r\n                          source: ''\r\n                      }));\r\n                  }\r\n              }\r\n              const shouldBuildAsSlots = isComponent &&\r\n                  // Teleport is not a real component and has dedicated runtime handling\r\n                  vnodeTag !== TELEPORT &&\r\n                  // explained above.\r\n                  vnodeTag !== KEEP_ALIVE;\r\n              if (shouldBuildAsSlots) {\r\n                  const { slots, hasDynamicSlots } = buildSlots(node, context);\r\n                  vnodeChildren = slots;\r\n                  if (hasDynamicSlots) {\r\n                      patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                  }\r\n              }\r\n              else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n                  const child = node.children[0];\r\n                  const type = child.type;\r\n                  // check for dynamic text children\r\n                  const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\r\n                      type === 8 /* COMPOUND_EXPRESSION */;\r\n                  if (hasDynamicTextChild &&\r\n                      getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                      patchFlag |= 1 /* TEXT */;\r\n                  }\r\n                  // pass directly if the only child is a text node\r\n                  // (plain / interpolation / expression)\r\n                  if (hasDynamicTextChild || type === 2 /* TEXT */) {\r\n                      vnodeChildren = child;\r\n                  }\r\n                  else {\r\n                      vnodeChildren = node.children;\r\n                  }\r\n              }\r\n              else {\r\n                  vnodeChildren = node.children;\r\n              }\r\n          }\r\n          // patchFlag & dynamicPropNames\r\n          if (patchFlag !== 0) {\r\n              {\r\n                  if (patchFlag < 0) {\r\n                      // special flags (negative and mutually exclusive)\r\n                      vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;\r\n                  }\r\n                  else {\r\n                      // bitwise flags\r\n                      const flagNames = Object.keys(PatchFlagNames)\r\n                          .map(Number)\r\n                          .filter(n => n > 0 && patchFlag & n)\r\n                          .map(n => PatchFlagNames[n])\r\n                          .join(`, `);\r\n                      vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\r\n                  }\r\n              }\r\n              if (dynamicPropNames && dynamicPropNames.length) {\r\n                  vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n              }\r\n          }\r\n          node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);\r\n      };\r\n  };\r\n  function resolveComponentType(node, context, ssr = false) {\r\n      let { tag } = node;\r\n      // 1. dynamic component\r\n      const isExplicitDynamic = isComponentTag(tag);\r\n      const isProp = findProp(node, 'is');\r\n      if (isProp) {\r\n          if (isExplicitDynamic ||\r\n              (false )) {\r\n              const exp = isProp.type === 6 /* ATTRIBUTE */\r\n                  ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n                  : isProp.exp;\r\n              if (exp) {\r\n                  return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n                      exp\r\n                  ]);\r\n              }\r\n          }\r\n          else if (isProp.type === 6 /* ATTRIBUTE */ &&\r\n              isProp.value.content.startsWith('vue:')) {\r\n              // <button is=\"vue:xxx\">\r\n              // if not <component>, only is value that starts with \"vue:\" will be\r\n              // treated as component by the parse phase and reach here, unless it's\r\n              // compat mode where all is values are considered components\r\n              tag = isProp.value.content.slice(4);\r\n          }\r\n      }\r\n      // 1.5 v-is (TODO: Deprecate)\r\n      const isDir = !isExplicitDynamic && findDir(node, 'is');\r\n      if (isDir && isDir.exp) {\r\n          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n              isDir.exp\r\n          ]);\r\n      }\r\n      // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\r\n      if (builtIn) {\r\n          // built-ins are simply fallthroughs / have special handling during ssr\r\n          // so we don't need to import their runtime equivalents\r\n          if (!ssr)\r\n              context.helper(builtIn);\r\n          return builtIn;\r\n      }\r\n      // 5. user component (resolve)\r\n      context.helper(RESOLVE_COMPONENT);\r\n      context.components.add(tag);\r\n      return toValidAssetId(tag, `component`);\r\n  }\r\n  function buildProps(node, context, props = node.props, ssr = false) {\r\n      const { tag, loc: elementLoc, children } = node;\r\n      const isComponent = node.tagType === 1 /* COMPONENT */;\r\n      let properties = [];\r\n      const mergeArgs = [];\r\n      const runtimeDirectives = [];\r\n      const hasChildren = children.length > 0;\r\n      let shouldUseBlock = false;\r\n      // patchFlag analysis\r\n      let patchFlag = 0;\r\n      let hasRef = false;\r\n      let hasClassBinding = false;\r\n      let hasStyleBinding = false;\r\n      let hasHydrationEventBinding = false;\r\n      let hasDynamicKeys = false;\r\n      let hasVnodeHook = false;\r\n      const dynamicPropNames = [];\r\n      const analyzePatchFlag = ({ key, value }) => {\r\n          if (isStaticExp(key)) {\r\n              const name = key.content;\r\n              const isEventHandler = isOn(name);\r\n              if (!isComponent &&\r\n                  isEventHandler &&\r\n                  // omit the flag for click handlers because hydration gives click\r\n                  // dedicated fast path.\r\n                  name.toLowerCase() !== 'onclick' &&\r\n                  // omit v-model handlers\r\n                  name !== 'onUpdate:modelValue' &&\r\n                  // omit onVnodeXXX hooks\r\n                  !isReservedProp(name)) {\r\n                  hasHydrationEventBinding = true;\r\n              }\r\n              if (isEventHandler && isReservedProp(name)) {\r\n                  hasVnodeHook = true;\r\n              }\r\n              if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||\r\n                  ((value.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n                      value.type === 8 /* COMPOUND_EXPRESSION */) &&\r\n                      getConstantType(value, context) > 0)) {\r\n                  // skip if the prop is a cached handler or has constant value\r\n                  return;\r\n              }\r\n              if (name === 'ref') {\r\n                  hasRef = true;\r\n              }\r\n              else if (name === 'class') {\r\n                  hasClassBinding = true;\r\n              }\r\n              else if (name === 'style') {\r\n                  hasStyleBinding = true;\r\n              }\r\n              else if (name !== 'key' && !dynamicPropNames.includes(name)) {\r\n                  dynamicPropNames.push(name);\r\n              }\r\n              // treat the dynamic class and style binding of the component as dynamic props\r\n              if (isComponent &&\r\n                  (name === 'class' || name === 'style') &&\r\n                  !dynamicPropNames.includes(name)) {\r\n                  dynamicPropNames.push(name);\r\n              }\r\n          }\r\n          else {\r\n              hasDynamicKeys = true;\r\n          }\r\n      };\r\n      for (let i = 0; i < props.length; i++) {\r\n          // static attribute\r\n          const prop = props[i];\r\n          if (prop.type === 6 /* ATTRIBUTE */) {\r\n              const { loc, name, value } = prop;\r\n              let isStatic = true;\r\n              if (name === 'ref') {\r\n                  hasRef = true;\r\n                  if (context.scopes.vFor > 0) {\r\n                      properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));\r\n                  }\r\n              }\r\n              // skip is on <component>, or is=\"vue:xxx\"\r\n              if (name === 'is' &&\r\n                  (isComponentTag(tag) ||\r\n                      (value && value.content.startsWith('vue:')) ||\r\n                      (false ))) {\r\n                  continue;\r\n              }\r\n              properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));\r\n          }\r\n          else {\r\n              // directives\r\n              const { name, arg, exp, loc } = prop;\r\n              const isVBind = name === 'bind';\r\n              const isVOn = name === 'on';\r\n              // skip v-slot - it is handled by its dedicated transform.\r\n              if (name === 'slot') {\r\n                  if (!isComponent) {\r\n                      context.onError(createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc));\r\n                  }\r\n                  continue;\r\n              }\r\n              // skip v-once/v-memo - they are handled by dedicated transforms.\r\n              if (name === 'once' || name === 'memo') {\r\n                  continue;\r\n              }\r\n              // skip v-is and :is on <component>\r\n              if (name === 'is' ||\r\n                  (isVBind &&\r\n                      isStaticArgOf(arg, 'is') &&\r\n                      (isComponentTag(tag) ||\r\n                          (false )))) {\r\n                  continue;\r\n              }\r\n              // skip v-on in SSR compilation\r\n              if (isVOn && ssr) {\r\n                  continue;\r\n              }\r\n              if (\r\n              // #938: elements with dynamic keys should be forced into blocks\r\n              (isVBind && isStaticArgOf(arg, 'key')) ||\r\n                  // inline before-update hooks need to force block so that it is invoked\r\n                  // before children\r\n                  (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {\r\n                  shouldUseBlock = true;\r\n              }\r\n              if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\r\n                  properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));\r\n              }\r\n              // special case for v-bind and v-on with no argument\r\n              if (!arg && (isVBind || isVOn)) {\r\n                  hasDynamicKeys = true;\r\n                  if (exp) {\r\n                      if (properties.length) {\r\n                          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n                          properties = [];\r\n                      }\r\n                      if (isVBind) {\r\n                          mergeArgs.push(exp);\r\n                      }\r\n                      else {\r\n                          // v-on=\"obj\" -> toHandlers(obj)\r\n                          mergeArgs.push({\r\n                              type: 14 /* JS_CALL_EXPRESSION */,\r\n                              loc,\r\n                              callee: context.helper(TO_HANDLERS),\r\n                              arguments: [exp]\r\n                          });\r\n                      }\r\n                  }\r\n                  else {\r\n                      context.onError(createCompilerError(isVBind\r\n                          ? 34 /* X_V_BIND_NO_EXPRESSION */\r\n                          : 35 /* X_V_ON_NO_EXPRESSION */, loc));\r\n                  }\r\n                  continue;\r\n              }\r\n              const directiveTransform = context.directiveTransforms[name];\r\n              if (directiveTransform) {\r\n                  // has built-in directive transform.\r\n                  const { props, needRuntime } = directiveTransform(prop, node, context);\r\n                  !ssr && props.forEach(analyzePatchFlag);\r\n                  properties.push(...props);\r\n                  if (needRuntime) {\r\n                      runtimeDirectives.push(prop);\r\n                      if (isSymbol(needRuntime)) {\r\n                          directiveImportMap.set(prop, needRuntime);\r\n                      }\r\n                  }\r\n              }\r\n              else if (!isBuiltInDirective(name)) {\r\n                  // no built-in transform, this is a user custom directive.\r\n                  runtimeDirectives.push(prop);\r\n                  // custom dirs may use beforeUpdate so they need to force blocks\r\n                  // to ensure before-update gets called before children update\r\n                  if (hasChildren) {\r\n                      shouldUseBlock = true;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      let propsExpression = undefined;\r\n      // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n      if (mergeArgs.length) {\r\n          if (properties.length) {\r\n              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n          }\r\n          if (mergeArgs.length > 1) {\r\n              propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\r\n          }\r\n          else {\r\n              // single v-bind with nothing else - no need for a mergeProps call\r\n              propsExpression = mergeArgs[0];\r\n          }\r\n      }\r\n      else if (properties.length) {\r\n          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\r\n      }\r\n      // patchFlag analysis\r\n      if (hasDynamicKeys) {\r\n          patchFlag |= 16 /* FULL_PROPS */;\r\n      }\r\n      else {\r\n          if (hasClassBinding && !isComponent) {\r\n              patchFlag |= 2 /* CLASS */;\r\n          }\r\n          if (hasStyleBinding && !isComponent) {\r\n              patchFlag |= 4 /* STYLE */;\r\n          }\r\n          if (dynamicPropNames.length) {\r\n              patchFlag |= 8 /* PROPS */;\r\n          }\r\n          if (hasHydrationEventBinding) {\r\n              patchFlag |= 32 /* HYDRATE_EVENTS */;\r\n          }\r\n      }\r\n      if (!shouldUseBlock &&\r\n          (patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&\r\n          (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\r\n          patchFlag |= 512 /* NEED_PATCH */;\r\n      }\r\n      // pre-normalize props, SSR is skipped for now\r\n      if (!context.inSSR && propsExpression) {\r\n          switch (propsExpression.type) {\r\n              case 15 /* JS_OBJECT_EXPRESSION */:\r\n                  // means that there is no v-bind,\r\n                  // but still need to deal with dynamic key binding\r\n                  let classKeyIndex = -1;\r\n                  let styleKeyIndex = -1;\r\n                  let hasDynamicKey = false;\r\n                  for (let i = 0; i < propsExpression.properties.length; i++) {\r\n                      const key = propsExpression.properties[i].key;\r\n                      if (isStaticExp(key)) {\r\n                          if (key.content === 'class') {\r\n                              classKeyIndex = i;\r\n                          }\r\n                          else if (key.content === 'style') {\r\n                              styleKeyIndex = i;\r\n                          }\r\n                      }\r\n                      else if (!key.isHandlerKey) {\r\n                          hasDynamicKey = true;\r\n                      }\r\n                  }\r\n                  const classProp = propsExpression.properties[classKeyIndex];\r\n                  const styleProp = propsExpression.properties[styleKeyIndex];\r\n                  // no dynamic key\r\n                  if (!hasDynamicKey) {\r\n                      if (classProp && !isStaticExp(classProp.value)) {\r\n                          classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);\r\n                      }\r\n                      if (styleProp &&\r\n                          !isStaticExp(styleProp.value) &&\r\n                          // the static style is compiled into an object,\r\n                          // so use `hasStyleBinding` to ensure that it is a dynamic style binding\r\n                          (hasStyleBinding ||\r\n                              // v-bind:style and style both exist,\r\n                              // v-bind:style with static literal object\r\n                              styleProp.value.type === 17 /* JS_ARRAY_EXPRESSION */)) {\r\n                          styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);\r\n                      }\r\n                  }\r\n                  else {\r\n                      // dynamic key binding, wrap with `normalizeProps`\r\n                      propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);\r\n                  }\r\n                  break;\r\n              case 14 /* JS_CALL_EXPRESSION */:\r\n                  // mergeProps call, do nothing\r\n                  break;\r\n              default:\r\n                  // single v-bind\r\n                  propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [\r\n                      createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\r\n                          propsExpression\r\n                      ])\r\n                  ]);\r\n                  break;\r\n          }\r\n      }\r\n      return {\r\n          props: propsExpression,\r\n          directives: runtimeDirectives,\r\n          patchFlag,\r\n          dynamicPropNames,\r\n          shouldUseBlock\r\n      };\r\n  }\r\n  // Dedupe props in an object literal.\r\n  // Literal duplicated attributes would have been warned during the parse phase,\r\n  // however, it's possible to encounter duplicated `onXXX` handlers with different\r\n  // modifiers. We also need to merge static and dynamic class / style attributes.\r\n  // - onXXX handlers / style: merge into array\r\n  // - class: merge into single expression with concatenation\r\n  function dedupeProperties(properties) {\r\n      const knownProps = new Map();\r\n      const deduped = [];\r\n      for (let i = 0; i < properties.length; i++) {\r\n          const prop = properties[i];\r\n          // dynamic keys are always allowed\r\n          if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\r\n              deduped.push(prop);\r\n              continue;\r\n          }\r\n          const name = prop.key.content;\r\n          const existing = knownProps.get(name);\r\n          if (existing) {\r\n              if (name === 'style' || name === 'class' || isOn(name)) {\r\n                  mergeAsArray$1(existing, prop);\r\n              }\r\n              // unexpected duplicate, should have emitted error during parse\r\n          }\r\n          else {\r\n              knownProps.set(name, prop);\r\n              deduped.push(prop);\r\n          }\r\n      }\r\n      return deduped;\r\n  }\r\n  function mergeAsArray$1(existing, incoming) {\r\n      if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {\r\n          existing.value.elements.push(incoming.value);\r\n      }\r\n      else {\r\n          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\r\n      }\r\n  }\r\n  function buildDirectiveArgs(dir, context) {\r\n      const dirArgs = [];\r\n      const runtime = directiveImportMap.get(dir);\r\n      if (runtime) {\r\n          // built-in directive with runtime\r\n          dirArgs.push(context.helperString(runtime));\r\n      }\r\n      else {\r\n          {\r\n              // inject statement for resolving directive\r\n              context.helper(RESOLVE_DIRECTIVE);\r\n              context.directives.add(dir.name);\r\n              dirArgs.push(toValidAssetId(dir.name, `directive`));\r\n          }\r\n      }\r\n      const { loc } = dir;\r\n      if (dir.exp)\r\n          dirArgs.push(dir.exp);\r\n      if (dir.arg) {\r\n          if (!dir.exp) {\r\n              dirArgs.push(`void 0`);\r\n          }\r\n          dirArgs.push(dir.arg);\r\n      }\r\n      if (Object.keys(dir.modifiers).length) {\r\n          if (!dir.arg) {\r\n              if (!dir.exp) {\r\n                  dirArgs.push(`void 0`);\r\n              }\r\n              dirArgs.push(`void 0`);\r\n          }\r\n          const trueExpression = createSimpleExpression(`true`, false, loc);\r\n          dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\r\n      }\r\n      return createArrayExpression(dirArgs, dir.loc);\r\n  }\r\n  function stringifyDynamicPropNames(props) {\r\n      let propsNamesString = `[`;\r\n      for (let i = 0, l = props.length; i < l; i++) {\r\n          propsNamesString += JSON.stringify(props[i]);\r\n          if (i < l - 1)\r\n              propsNamesString += ', ';\r\n      }\r\n      return propsNamesString + `]`;\r\n  }\r\n  function isComponentTag(tag) {\r\n      return tag === 'component' || tag === 'Component';\r\n  }\n\n  const transformSlotOutlet = (node, context) => {\r\n      if (isSlotOutlet(node)) {\r\n          const { children, loc } = node;\r\n          const { slotName, slotProps } = processSlotOutlet(node, context);\r\n          const slotArgs = [\r\n              context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n              slotName,\r\n              '{}',\r\n              'undefined',\r\n              'true'\r\n          ];\r\n          let expectedLen = 2;\r\n          if (slotProps) {\r\n              slotArgs[2] = slotProps;\r\n              expectedLen = 3;\r\n          }\r\n          if (children.length) {\r\n              slotArgs[3] = createFunctionExpression([], children, false, false, loc);\r\n              expectedLen = 4;\r\n          }\r\n          if (context.scopeId && !context.slotted) {\r\n              expectedLen = 5;\r\n          }\r\n          slotArgs.splice(expectedLen); // remove unused arguments\r\n          node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\r\n      }\r\n  };\r\n  function processSlotOutlet(node, context) {\r\n      let slotName = `\"default\"`;\r\n      let slotProps = undefined;\r\n      const nonNameProps = [];\r\n      for (let i = 0; i < node.props.length; i++) {\r\n          const p = node.props[i];\r\n          if (p.type === 6 /* ATTRIBUTE */) {\r\n              if (p.value) {\r\n                  if (p.name === 'name') {\r\n                      slotName = JSON.stringify(p.value.content);\r\n                  }\r\n                  else {\r\n                      p.name = camelize(p.name);\r\n                      nonNameProps.push(p);\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\r\n                  if (p.exp)\r\n                      slotName = p.exp;\r\n              }\r\n              else {\r\n                  if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\r\n                      p.arg.content = camelize(p.arg.content);\r\n                  }\r\n                  nonNameProps.push(p);\r\n              }\r\n          }\r\n      }\r\n      if (nonNameProps.length > 0) {\r\n          const { props, directives } = buildProps(node, context, nonNameProps);\r\n          slotProps = props;\r\n          if (directives.length) {\r\n              context.onError(createCompilerError(36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\r\n          }\r\n      }\r\n      return {\r\n          slotName,\r\n          slotProps\r\n      };\r\n  }\n\n  const fnExpRE = /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/;\r\n  const transformOn = (dir, node, context, augmentor) => {\r\n      const { loc, modifiers, arg } = dir;\r\n      if (!dir.exp && !modifiers.length) {\r\n          context.onError(createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc));\r\n      }\r\n      let eventName;\r\n      if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n          if (arg.isStatic) {\r\n              let rawName = arg.content;\r\n              // TODO deprecate @vnodeXXX usage\r\n              if (rawName.startsWith('vue:')) {\r\n                  rawName = `vnode-${rawName.slice(4)}`;\r\n              }\r\n              // for all event listeners, auto convert it to camelCase. See issue #2249\r\n              eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);\r\n          }\r\n          else {\r\n              // #2388\r\n              eventName = createCompoundExpression([\r\n                  `${context.helperString(TO_HANDLER_KEY)}(`,\r\n                  arg,\r\n                  `)`\r\n              ]);\r\n          }\r\n      }\r\n      else {\r\n          // already a compound expression.\r\n          eventName = arg;\r\n          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\r\n          eventName.children.push(`)`);\r\n      }\r\n      // handler processing\r\n      let exp = dir.exp;\r\n      if (exp && !exp.content.trim()) {\r\n          exp = undefined;\r\n      }\r\n      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;\r\n      if (exp) {\r\n          const isMemberExp = isMemberExpression(exp.content);\r\n          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\r\n          const hasMultipleStatements = exp.content.includes(`;`);\r\n          {\r\n              validateBrowserExpression(exp, context, false, hasMultipleStatements);\r\n          }\r\n          if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n              // wrap inline statement in a function expression\r\n              exp = createCompoundExpression([\r\n                  `${isInlineStatement\r\n                    ? `$event`\r\n                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\r\n                  exp,\r\n                  hasMultipleStatements ? `}` : `)`\r\n              ]);\r\n          }\r\n      }\r\n      let ret = {\r\n          props: [\r\n              createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\r\n          ]\r\n      };\r\n      // apply extended compiler augmentor\r\n      if (augmentor) {\r\n          ret = augmentor(ret);\r\n      }\r\n      if (shouldCache) {\r\n          // cache handlers so that it's always the same handler being passed down.\r\n          // this avoids unnecessary re-renders when users use inline handlers on\r\n          // components.\r\n          ret.props[0].value = context.cache(ret.props[0].value);\r\n      }\r\n      // mark the key as handler for props normalization check\r\n      ret.props.forEach(p => (p.key.isHandlerKey = true));\r\n      return ret;\r\n  };\n\n  // v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n  // codegen for the entire props object. This transform here is only for v-bind\r\n  // *with* args.\r\n  const transformBind = (dir, _node, context) => {\r\n      const { exp, modifiers, loc } = dir;\r\n      const arg = dir.arg;\r\n      if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n          arg.children.unshift(`(`);\r\n          arg.children.push(`) || \"\"`);\r\n      }\r\n      else if (!arg.isStatic) {\r\n          arg.content = `${arg.content} || \"\"`;\r\n      }\r\n      // .sync is replaced by v-model:arg\r\n      if (modifiers.includes('camel')) {\r\n          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n              if (arg.isStatic) {\r\n                  arg.content = camelize(arg.content);\r\n              }\r\n              else {\r\n                  arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\r\n              }\r\n          }\r\n          else {\r\n              arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\r\n              arg.children.push(`)`);\r\n          }\r\n      }\r\n      if (!context.inSSR) {\r\n          if (modifiers.includes('prop')) {\r\n              injectPrefix(arg, '.');\r\n          }\r\n          if (modifiers.includes('attr')) {\r\n              injectPrefix(arg, '^');\r\n          }\r\n      }\r\n      if (!exp ||\r\n          (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {\r\n          context.onError(createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc));\r\n          return {\r\n              props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\r\n          };\r\n      }\r\n      return {\r\n          props: [createObjectProperty(arg, exp)]\r\n      };\r\n  };\r\n  const injectPrefix = (arg, prefix) => {\r\n      if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n          if (arg.isStatic) {\r\n              arg.content = prefix + arg.content;\r\n          }\r\n          else {\r\n              arg.content = `\\`${prefix}\\${${arg.content}}\\``;\r\n          }\r\n      }\r\n      else {\r\n          arg.children.unshift(`'${prefix}' + (`);\r\n          arg.children.push(`)`);\r\n      }\r\n  };\n\n  // Merge adjacent text nodes and expressions into a single expression\r\n  // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\n  const transformText = (node, context) => {\r\n      if (node.type === 0 /* ROOT */ ||\r\n          node.type === 1 /* ELEMENT */ ||\r\n          node.type === 11 /* FOR */ ||\r\n          node.type === 10 /* IF_BRANCH */) {\r\n          // perform the transform on node exit so that all expressions have already\r\n          // been processed.\r\n          return () => {\r\n              const children = node.children;\r\n              let currentContainer = undefined;\r\n              let hasText = false;\r\n              for (let i = 0; i < children.length; i++) {\r\n                  const child = children[i];\r\n                  if (isText(child)) {\r\n                      hasText = true;\r\n                      for (let j = i + 1; j < children.length; j++) {\r\n                          const next = children[j];\r\n                          if (isText(next)) {\r\n                              if (!currentContainer) {\r\n                                  currentContainer = children[i] = {\r\n                                      type: 8 /* COMPOUND_EXPRESSION */,\r\n                                      loc: child.loc,\r\n                                      children: [child]\r\n                                  };\r\n                              }\r\n                              // merge adjacent text node into current\r\n                              currentContainer.children.push(` + `, next);\r\n                              children.splice(j, 1);\r\n                              j--;\r\n                          }\r\n                          else {\r\n                              currentContainer = undefined;\r\n                              break;\r\n                          }\r\n                      }\r\n                  }\r\n              }\r\n              if (!hasText ||\r\n                  // if this is a plain element with a single text child, leave it\r\n                  // as-is since the runtime has dedicated fast path for this by directly\r\n                  // setting textContent of the element.\r\n                  // for component root it's always normalized anyway.\r\n                  (children.length === 1 &&\r\n                      (node.type === 0 /* ROOT */ ||\r\n                          (node.type === 1 /* ELEMENT */ &&\r\n                              node.tagType === 0 /* ELEMENT */ &&\r\n                              // #3756\r\n                              // custom directives can potentially add DOM elements arbitrarily,\r\n                              // we need to avoid setting textContent of the element at runtime\r\n                              // to avoid accidentally overwriting the DOM elements added\r\n                              // by the user through custom directives.\r\n                              !node.props.find(p => p.type === 7 /* DIRECTIVE */ &&\r\n                                  !context.directiveTransforms[p.name]) &&\r\n                              // in compat mode, <template> tags with no special directives\r\n                              // will be rendered as a fragment so its children must be\r\n                              // converted into vnodes.\r\n                              !(false ))))) {\r\n                  return;\r\n              }\r\n              // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n              // runtime normalization.\r\n              for (let i = 0; i < children.length; i++) {\r\n                  const child = children[i];\r\n                  if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {\r\n                      const callArgs = [];\r\n                      // createTextVNode defaults to single whitespace, so if it is a\r\n                      // single space the code could be an empty call to save bytes.\r\n                      if (child.type !== 2 /* TEXT */ || child.content !== ' ') {\r\n                          callArgs.push(child);\r\n                      }\r\n                      // mark dynamic text with flag so it gets patched inside a block\r\n                      if (!context.ssr &&\r\n                          getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                          callArgs.push(1 /* TEXT */ +\r\n                              (` /* ${PatchFlagNames[1 /* TEXT */]} */` ));\r\n                      }\r\n                      children[i] = {\r\n                          type: 12 /* TEXT_CALL */,\r\n                          content: child,\r\n                          loc: child.loc,\r\n                          codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\r\n                      };\r\n                  }\r\n              }\r\n          };\r\n      }\r\n  };\n\n  const seen = new WeakSet();\r\n  const transformOnce = (node, context) => {\r\n      if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {\r\n          if (seen.has(node) || context.inVOnce) {\r\n              return;\r\n          }\r\n          seen.add(node);\r\n          context.inVOnce = true;\r\n          context.helper(SET_BLOCK_TRACKING);\r\n          return () => {\r\n              context.inVOnce = false;\r\n              const cur = context.currentNode;\r\n              if (cur.codegenNode) {\r\n                  cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\r\n              }\r\n          };\r\n      }\r\n  };\n\n  const transformModel = (dir, node, context) => {\r\n      const { exp, arg } = dir;\r\n      if (!exp) {\r\n          context.onError(createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));\r\n          return createTransformProps();\r\n      }\r\n      const rawExp = exp.loc.source;\r\n      const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;\r\n      // im SFC <script setup> inline mode, the exp may have been transformed into\r\n      // _unref(exp)\r\n      context.bindingMetadata[rawExp];\r\n      const maybeRef = !true    /* SETUP_CONST */;\r\n      if (!expString.trim() ||\r\n          (!isMemberExpression(expString) && !maybeRef)) {\r\n          context.onError(createCompilerError(42 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\r\n          return createTransformProps();\r\n      }\r\n      const propName = arg ? arg : createSimpleExpression('modelValue', true);\r\n      const eventName = arg\r\n          ? isStaticExp(arg)\r\n              ? `onUpdate:${arg.content}`\r\n              : createCompoundExpression(['\"onUpdate:\" + ', arg])\r\n          : `onUpdate:modelValue`;\r\n      let assignmentExp;\r\n      const eventArg = context.isTS ? `($event: any)` : `$event`;\r\n      {\r\n          assignmentExp = createCompoundExpression([\r\n              `${eventArg} => ((`,\r\n              exp,\r\n              `) = $event)`\r\n          ]);\r\n      }\r\n      const props = [\r\n          // modelValue: foo\r\n          createObjectProperty(propName, dir.exp),\r\n          // \"onUpdate:modelValue\": $event => (foo = $event)\r\n          createObjectProperty(eventName, assignmentExp)\r\n      ];\r\n      // modelModifiers: { foo: true, \"bar-baz\": true }\r\n      if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {\r\n          const modifiers = dir.modifiers\r\n              .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n              .join(`, `);\r\n          const modifiersKey = arg\r\n              ? isStaticExp(arg)\r\n                  ? `${arg.content}Modifiers`\r\n                  : createCompoundExpression([arg, ' + \"Modifiers\"'])\r\n              : `modelModifiers`;\r\n          props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));\r\n      }\r\n      return createTransformProps(props);\r\n  };\r\n  function createTransformProps(props = []) {\r\n      return { props };\r\n  }\n\n  const seen$1 = new WeakSet();\r\n  const transformMemo = (node, context) => {\r\n      if (node.type === 1 /* ELEMENT */) {\r\n          const dir = findDir(node, 'memo');\r\n          if (!dir || seen$1.has(node)) {\r\n              return;\r\n          }\r\n          seen$1.add(node);\r\n          return () => {\r\n              const codegenNode = node.codegenNode ||\r\n                  context.currentNode.codegenNode;\r\n              if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {\r\n                  // non-component sub tree should be turned into a block\r\n                  if (node.tagType !== 1 /* COMPONENT */) {\r\n                      makeBlock(codegenNode, context);\r\n                  }\r\n                  node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\r\n                      dir.exp,\r\n                      createFunctionExpression(undefined, codegenNode),\r\n                      `_cache`,\r\n                      String(context.cached++)\r\n                  ]);\r\n              }\r\n          };\r\n      }\r\n  };\n\n  function getBaseTransformPreset(prefixIdentifiers) {\r\n      return [\r\n          [\r\n              transformOnce,\r\n              transformIf,\r\n              transformMemo,\r\n              transformFor,\r\n              ...([]),\r\n              ...([transformExpression]\r\n                      ),\r\n              transformSlotOutlet,\r\n              transformElement,\r\n              trackSlotScopes,\r\n              transformText\r\n          ],\r\n          {\r\n              on: transformOn,\r\n              bind: transformBind,\r\n              model: transformModel\r\n          }\r\n      ];\r\n  }\r\n  // we name it `baseCompile` so that higher order compilers like\r\n  // @vue/compiler-dom can export `compile` while re-exporting everything else.\r\n  function baseCompile(template, options = {}) {\r\n      const onError = options.onError || defaultOnError;\r\n      const isModuleMode = options.mode === 'module';\r\n      /* istanbul ignore if */\r\n      {\r\n          if (options.prefixIdentifiers === true) {\r\n              onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));\r\n          }\r\n          else if (isModuleMode) {\r\n              onError(createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */));\r\n          }\r\n      }\r\n      const prefixIdentifiers = !true ;\r\n      if (options.cacheHandlers) {\r\n          onError(createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */));\r\n      }\r\n      if (options.scopeId && !isModuleMode) {\r\n          onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));\r\n      }\r\n      const ast = isString(template) ? baseParse(template, options) : template;\r\n      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\r\n      transform(ast, extend({}, options, {\r\n          prefixIdentifiers,\r\n          nodeTransforms: [\r\n              ...nodeTransforms,\r\n              ...(options.nodeTransforms || []) // user transforms\r\n          ],\r\n          directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms\r\n          )\r\n      }));\r\n      return generate(ast, extend({}, options, {\r\n          prefixIdentifiers\r\n      }));\r\n  }\n\n  const noopDirectiveTransform = () => ({ props: [] });\n\n  const V_MODEL_RADIO = Symbol(`vModelRadio` );\r\n  const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox` );\r\n  const V_MODEL_TEXT = Symbol(`vModelText` );\r\n  const V_MODEL_SELECT = Symbol(`vModelSelect` );\r\n  const V_MODEL_DYNAMIC = Symbol(`vModelDynamic` );\r\n  const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard` );\r\n  const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard` );\r\n  const V_SHOW = Symbol(`vShow` );\r\n  const TRANSITION$1 = Symbol(`Transition` );\r\n  const TRANSITION_GROUP = Symbol(`TransitionGroup` );\r\n  registerRuntimeHelpers({\r\n      [V_MODEL_RADIO]: `vModelRadio`,\r\n      [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n      [V_MODEL_TEXT]: `vModelText`,\r\n      [V_MODEL_SELECT]: `vModelSelect`,\r\n      [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n      [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n      [V_ON_WITH_KEYS]: `withKeys`,\r\n      [V_SHOW]: `vShow`,\r\n      [TRANSITION$1]: `Transition`,\r\n      [TRANSITION_GROUP]: `TransitionGroup`\r\n  });\n\n  /* eslint-disable no-restricted-globals */\r\n  let decoder;\r\n  function decodeHtmlBrowser(raw, asAttr = false) {\r\n      if (!decoder) {\r\n          decoder = document.createElement('div');\r\n      }\r\n      if (asAttr) {\r\n          decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`;\r\n          return decoder.children[0].getAttribute('foo');\r\n      }\r\n      else {\r\n          decoder.innerHTML = raw;\r\n          return decoder.textContent;\r\n      }\r\n  }\n\n  const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);\r\n  const parserOptions = {\r\n      isVoidTag,\r\n      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\r\n      isPreTag: tag => tag === 'pre',\r\n      decodeEntities: decodeHtmlBrowser ,\r\n      isBuiltInComponent: (tag) => {\r\n          if (isBuiltInType(tag, `Transition`)) {\r\n              return TRANSITION$1;\r\n          }\r\n          else if (isBuiltInType(tag, `TransitionGroup`)) {\r\n              return TRANSITION_GROUP;\r\n          }\r\n      },\r\n      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n      getNamespace(tag, parent) {\r\n          let ns = parent ? parent.ns : 0 /* HTML */;\r\n          if (parent && ns === 2 /* MATH_ML */) {\r\n              if (parent.tag === 'annotation-xml') {\r\n                  if (tag === 'svg') {\r\n                      return 1 /* SVG */;\r\n                  }\r\n                  if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&\r\n                      a.name === 'encoding' &&\r\n                      a.value != null &&\r\n                      (a.value.content === 'text/html' ||\r\n                          a.value.content === 'application/xhtml+xml'))) {\r\n                      ns = 0 /* HTML */;\r\n                  }\r\n              }\r\n              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\r\n                  tag !== 'mglyph' &&\r\n                  tag !== 'malignmark') {\r\n                  ns = 0 /* HTML */;\r\n              }\r\n          }\r\n          else if (parent && ns === 1 /* SVG */) {\r\n              if (parent.tag === 'foreignObject' ||\r\n                  parent.tag === 'desc' ||\r\n                  parent.tag === 'title') {\r\n                  ns = 0 /* HTML */;\r\n              }\r\n          }\r\n          if (ns === 0 /* HTML */) {\r\n              if (tag === 'svg') {\r\n                  return 1 /* SVG */;\r\n              }\r\n              if (tag === 'math') {\r\n                  return 2 /* MATH_ML */;\r\n              }\r\n          }\r\n          return ns;\r\n      },\r\n      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n      getTextMode({ tag, ns }) {\r\n          if (ns === 0 /* HTML */) {\r\n              if (tag === 'textarea' || tag === 'title') {\r\n                  return 1 /* RCDATA */;\r\n              }\r\n              if (isRawTextContainer(tag)) {\r\n                  return 2 /* RAWTEXT */;\r\n              }\r\n          }\r\n          return 0 /* DATA */;\r\n      }\r\n  };\n\n  // Parse inline CSS strings for static style attributes into an object.\r\n  // This is a NodeTransform since it works on the static `style` attribute and\r\n  // converts it into a dynamic equivalent:\r\n  // style=\"color: red\" -> :style='{ \"color\": \"red\" }'\r\n  // It is then processed by `transformElement` and included in the generated\r\n  // props.\r\n  const transformStyle = node => {\r\n      if (node.type === 1 /* ELEMENT */) {\r\n          node.props.forEach((p, i) => {\r\n              if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {\r\n                  // replace p with an expression node\r\n                  node.props[i] = {\r\n                      type: 7 /* DIRECTIVE */,\r\n                      name: `bind`,\r\n                      arg: createSimpleExpression(`style`, true, p.loc),\r\n                      exp: parseInlineCSS(p.value.content, p.loc),\r\n                      modifiers: [],\r\n                      loc: p.loc\r\n                  };\r\n              }\r\n          });\r\n      }\r\n  };\r\n  const parseInlineCSS = (cssText, loc) => {\r\n      const normalized = parseStringStyle(cssText);\r\n      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);\r\n  };\n\n  function createDOMCompilerError(code, loc) {\r\n      return createCompilerError(code, loc, DOMErrorMessages );\r\n  }\r\n  const DOMErrorMessages = {\r\n      [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\r\n      [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\r\n      [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\r\n      [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\r\n      [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n      [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\r\n      [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n      [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\r\n      [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\r\n      [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\r\n      [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n  };\n\n  const transformVHtml = (dir, node, context) => {\r\n      const { exp, loc } = dir;\r\n      if (!exp) {\r\n          context.onError(createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc));\r\n      }\r\n      if (node.children.length) {\r\n          context.onError(createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc));\r\n          node.children.length = 0;\r\n      }\r\n      return {\r\n          props: [\r\n              createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))\r\n          ]\r\n      };\r\n  };\n\n  const transformVText = (dir, node, context) => {\r\n      const { exp, loc } = dir;\r\n      if (!exp) {\r\n          context.onError(createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc));\r\n      }\r\n      if (node.children.length) {\r\n          context.onError(createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc));\r\n          node.children.length = 0;\r\n      }\r\n      return {\r\n          props: [\r\n              createObjectProperty(createSimpleExpression(`textContent`, true), exp\r\n                  ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)\r\n                  : createSimpleExpression('', true))\r\n          ]\r\n      };\r\n  };\n\n  const transformModel$1 = (dir, node, context) => {\r\n      const baseResult = transformModel(dir, node, context);\r\n      // base transform has errors OR component v-model (only need props)\r\n      if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {\r\n          return baseResult;\r\n      }\r\n      if (dir.arg) {\r\n          context.onError(createDOMCompilerError(55 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\r\n      }\r\n      function checkDuplicatedValue() {\r\n          const value = findProp(node, 'value');\r\n          if (value) {\r\n              context.onError(createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\r\n          }\r\n      }\r\n      const { tag } = node;\r\n      const isCustomElement = context.isCustomElement(tag);\r\n      if (tag === 'input' ||\r\n          tag === 'textarea' ||\r\n          tag === 'select' ||\r\n          isCustomElement) {\r\n          let directiveToUse = V_MODEL_TEXT;\r\n          let isInvalidType = false;\r\n          if (tag === 'input' || isCustomElement) {\r\n              const type = findProp(node, `type`);\r\n              if (type) {\r\n                  if (type.type === 7 /* DIRECTIVE */) {\r\n                      // :type=\"foo\"\r\n                      directiveToUse = V_MODEL_DYNAMIC;\r\n                  }\r\n                  else if (type.value) {\r\n                      switch (type.value.content) {\r\n                          case 'radio':\r\n                              directiveToUse = V_MODEL_RADIO;\r\n                              break;\r\n                          case 'checkbox':\r\n                              directiveToUse = V_MODEL_CHECKBOX;\r\n                              break;\r\n                          case 'file':\r\n                              isInvalidType = true;\r\n                              context.onError(createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\r\n                              break;\r\n                          default:\r\n                              // text type\r\n                              checkDuplicatedValue();\r\n                              break;\r\n                      }\r\n                  }\r\n              }\r\n              else if (hasDynamicKeyVBind(node)) {\r\n                  // element has bindings with dynamic keys, which can possibly contain\r\n                  // \"type\".\r\n                  directiveToUse = V_MODEL_DYNAMIC;\r\n              }\r\n              else {\r\n                  // text type\r\n                  checkDuplicatedValue();\r\n              }\r\n          }\r\n          else if (tag === 'select') {\r\n              directiveToUse = V_MODEL_SELECT;\r\n          }\r\n          else {\r\n              // textarea\r\n              checkDuplicatedValue();\r\n          }\r\n          // inject runtime directive\r\n          // by returning the helper symbol via needRuntime\r\n          // the import will replaced a resolveDirective call.\r\n          if (!isInvalidType) {\r\n              baseResult.needRuntime = context.helper(directiveToUse);\r\n          }\r\n      }\r\n      else {\r\n          context.onError(createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\r\n      }\r\n      // native vmodel doesn't need the `modelValue` props since they are also\r\n      // passed to the runtime as `binding.value`. removing it reduces code size.\r\n      baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n          p.key.content === 'modelValue'));\r\n      return baseResult;\r\n  };\n\n  const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);\r\n  const isNonKeyModifier = /*#__PURE__*/ makeMap(\r\n  // event propagation management\r\n`stop,prevent,self,`   +\r\n      // system modifiers + exact\r\n      `ctrl,shift,alt,meta,exact,` +\r\n      // mouse\r\n      `middle`);\r\n  // left & right could be mouse or key modifiers based on event type\r\n  const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');\r\n  const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);\r\n  const resolveModifiers = (key, modifiers, context, loc) => {\r\n      const keyModifiers = [];\r\n      const nonKeyModifiers = [];\r\n      const eventOptionModifiers = [];\r\n      for (let i = 0; i < modifiers.length; i++) {\r\n          const modifier = modifiers[i];\r\n          if (isEventOptionModifier(modifier)) {\r\n              // eventOptionModifiers: modifiers for addEventListener() options,\r\n              // e.g. .passive & .capture\r\n              eventOptionModifiers.push(modifier);\r\n          }\r\n          else {\r\n              // runtimeModifiers: modifiers that needs runtime guards\r\n              if (maybeKeyModifier(modifier)) {\r\n                  if (isStaticExp(key)) {\r\n                      if (isKeyboardEvent(key.content)) {\r\n                          keyModifiers.push(modifier);\r\n                      }\r\n                      else {\r\n                          nonKeyModifiers.push(modifier);\r\n                      }\r\n                  }\r\n                  else {\r\n                      keyModifiers.push(modifier);\r\n                      nonKeyModifiers.push(modifier);\r\n                  }\r\n              }\r\n              else {\r\n                  if (isNonKeyModifier(modifier)) {\r\n                      nonKeyModifiers.push(modifier);\r\n                  }\r\n                  else {\r\n                      keyModifiers.push(modifier);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      return {\r\n          keyModifiers,\r\n          nonKeyModifiers,\r\n          eventOptionModifiers\r\n      };\r\n  };\r\n  const transformClick = (key, event) => {\r\n      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';\r\n      return isStaticClick\r\n          ? createSimpleExpression(event, true)\r\n          : key.type !== 4 /* SIMPLE_EXPRESSION */\r\n              ? createCompoundExpression([\r\n                  `(`,\r\n                  key,\r\n                  `) === \"onClick\" ? \"${event}\" : (`,\r\n                  key,\r\n                  `)`\r\n              ])\r\n              : key;\r\n  };\r\n  const transformOn$1 = (dir, node, context) => {\r\n      return transformOn(dir, node, context, baseResult => {\r\n          const { modifiers } = dir;\r\n          if (!modifiers.length)\r\n              return baseResult;\r\n          let { key, value: handlerExp } = baseResult.props[0];\r\n          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);\r\n          // normalize click.right and click.middle since they don't actually fire\r\n          if (nonKeyModifiers.includes('right')) {\r\n              key = transformClick(key, `onContextmenu`);\r\n          }\r\n          if (nonKeyModifiers.includes('middle')) {\r\n              key = transformClick(key, `onMouseup`);\r\n          }\r\n          if (nonKeyModifiers.length) {\r\n              handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n                  handlerExp,\r\n                  JSON.stringify(nonKeyModifiers)\r\n              ]);\r\n          }\r\n          if (keyModifiers.length &&\r\n              // if event name is dynamic, always wrap with keys guard\r\n              (!isStaticExp(key) || isKeyboardEvent(key.content))) {\r\n              handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n                  handlerExp,\r\n                  JSON.stringify(keyModifiers)\r\n              ]);\r\n          }\r\n          if (eventOptionModifiers.length) {\r\n              const modifierPostfix = eventOptionModifiers.map(capitalize).join('');\r\n              key = isStaticExp(key)\r\n                  ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n                  : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\r\n          }\r\n          return {\r\n              props: [createObjectProperty(key, handlerExp)]\r\n          };\r\n      });\r\n  };\n\n  const transformShow = (dir, node, context) => {\r\n      const { exp, loc } = dir;\r\n      if (!exp) {\r\n          context.onError(createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc));\r\n      }\r\n      return {\r\n          props: [],\r\n          needRuntime: context.helper(V_SHOW)\r\n      };\r\n  };\n\n  const warnTransitionChildren = (node, context) => {\r\n      if (node.type === 1 /* ELEMENT */ &&\r\n          node.tagType === 1 /* COMPONENT */) {\r\n          const component = context.isBuiltInComponent(node.tag);\r\n          if (component === TRANSITION$1) {\r\n              return () => {\r\n                  if (node.children.length && hasMultipleChildren(node)) {\r\n                      context.onError(createDOMCompilerError(59 /* X_TRANSITION_INVALID_CHILDREN */, {\r\n                          start: node.children[0].loc.start,\r\n                          end: node.children[node.children.length - 1].loc.end,\r\n                          source: ''\r\n                      }));\r\n                  }\r\n              };\r\n          }\r\n      }\r\n  };\r\n  function hasMultipleChildren(node) {\r\n      // #1352 filter out potential comment nodes.\r\n      const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */ &&\r\n          !(c.type === 2 /* TEXT */ && !c.content.trim())));\r\n      const child = children[0];\r\n      return (children.length !== 1 ||\r\n          child.type === 11 /* FOR */ ||\r\n          (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));\r\n  }\n\n  const ignoreSideEffectTags = (node, context) => {\r\n      if (node.type === 1 /* ELEMENT */ &&\r\n          node.tagType === 0 /* ELEMENT */ &&\r\n          (node.tag === 'script' || node.tag === 'style')) {\r\n          context.onError(createDOMCompilerError(60 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\r\n          context.removeNode();\r\n      }\r\n  };\n\n  const DOMNodeTransforms = [\r\n      transformStyle,\r\n      ...([warnTransitionChildren] )\r\n  ];\r\n  const DOMDirectiveTransforms = {\r\n      cloak: noopDirectiveTransform,\r\n      html: transformVHtml,\r\n      text: transformVText,\r\n      model: transformModel$1,\r\n      on: transformOn$1,\r\n      show: transformShow\r\n  };\r\n  function compile$1(template, options = {}) {\r\n      return baseCompile(template, extend({}, parserOptions, options, {\r\n          nodeTransforms: [\r\n              // ignore <script> and <tag>\r\n              // this is not put inside DOMNodeTransforms because that list is used\r\n              // by compiler-ssr to generate vnode fallback branches\r\n              ignoreSideEffectTags,\r\n              ...DOMNodeTransforms,\r\n              ...(options.nodeTransforms || [])\r\n          ],\r\n          directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\r\n          transformHoist: null \r\n      }));\r\n  }\n\n  // This entry is the \"full-build\" that includes both the runtime\r\n  {\r\n      initDev();\r\n  }\r\n  const compileCache = Object.create(null);\r\n  function compileToFunction(template, options) {\r\n      if (!isString(template)) {\r\n          if (template.nodeType) {\r\n              template = template.innerHTML;\r\n          }\r\n          else {\r\n              warn$1(`invalid template option: `, template);\r\n              return NOOP;\r\n          }\r\n      }\r\n      const key = template;\r\n      const cached = compileCache[key];\r\n      if (cached) {\r\n          return cached;\r\n      }\r\n      if (template[0] === '#') {\r\n          const el = document.querySelector(template);\r\n          if (!el) {\r\n              warn$1(`Template element not found or is empty: ${template}`);\r\n          }\r\n          // __UNSAFE__\r\n          // Reason: potential execution of JS expressions in in-DOM template.\r\n          // The user must make sure the in-DOM template is trusted. If it's rendered\r\n          // by the server, the template should not contain any user data.\r\n          template = el ? el.innerHTML : ``;\r\n      }\r\n      const { code } = compile$1(template, extend({\r\n          hoistStatic: true,\r\n          onError: onError ,\r\n          onWarn: e => onError(e, true) \r\n      }, options));\r\n      function onError(err, asWarning = false) {\r\n          const message = asWarning\r\n              ? err.message\r\n              : `Template compilation error: ${err.message}`;\r\n          const codeFrame = err.loc &&\r\n              generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);\r\n          warn$1(codeFrame ? `${message}\\n${codeFrame}` : message);\r\n      }\r\n      // The wildcard import results in a huge object with every export\r\n      // with keys that cannot be mangled, and can be quite heavy size-wise.\r\n      // In the global build we know `Vue` is available globally so we can avoid\r\n      // the wildcard object.\r\n      const render = (new Function(code)() );\r\n      render._rc = true;\r\n      return (compileCache[key] = render);\r\n  }\r\n  registerRuntimeCompiler(compileToFunction);\n\n  exports.BaseTransition = BaseTransition;\n  exports.Comment = Comment;\n  exports.EffectScope = EffectScope;\n  exports.Fragment = Fragment;\n  exports.KeepAlive = KeepAlive;\n  exports.ReactiveEffect = ReactiveEffect;\n  exports.Static = Static;\n  exports.Suspense = Suspense;\n  exports.Teleport = Teleport;\n  exports.Text = Text;\n  exports.Transition = Transition;\n  exports.TransitionGroup = TransitionGroup;\n  exports.VueElement = VueElement;\n  exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;\n  exports.callWithErrorHandling = callWithErrorHandling;\n  exports.camelize = camelize;\n  exports.capitalize = capitalize;\n  exports.cloneVNode = cloneVNode;\n  exports.compatUtils = compatUtils;\n  exports.compile = compileToFunction;\n  exports.computed = computed$1;\n  exports.createApp = createApp;\n  exports.createBlock = createBlock;\n  exports.createCommentVNode = createCommentVNode;\n  exports.createElementBlock = createElementBlock;\n  exports.createElementVNode = createBaseVNode;\n  exports.createHydrationRenderer = createHydrationRenderer;\n  exports.createPropsRestProxy = createPropsRestProxy;\n  exports.createRenderer = createRenderer;\n  exports.createSSRApp = createSSRApp;\n  exports.createSlots = createSlots;\n  exports.createStaticVNode = createStaticVNode;\n  exports.createTextVNode = createTextVNode;\n  exports.createVNode = createVNode;\n  exports.customRef = customRef;\n  exports.defineAsyncComponent = defineAsyncComponent;\n  exports.defineComponent = defineComponent;\n  exports.defineCustomElement = defineCustomElement;\n  exports.defineEmits = defineEmits;\n  exports.defineExpose = defineExpose;\n  exports.defineProps = defineProps;\n  exports.defineSSRCustomElement = defineSSRCustomElement;\n  exports.effect = effect;\n  exports.effectScope = effectScope;\n  exports.getCurrentInstance = getCurrentInstance;\n  exports.getCurrentScope = getCurrentScope;\n  exports.getTransitionRawChildren = getTransitionRawChildren;\n  exports.guardReactiveProps = guardReactiveProps;\n  exports.h = h;\n  exports.handleError = handleError;\n  exports.hydrate = hydrate;\n  exports.initCustomFormatter = initCustomFormatter;\n  exports.initDirectivesForSSR = initDirectivesForSSR;\n  exports.inject = inject;\n  exports.isMemoSame = isMemoSame;\n  exports.isProxy = isProxy;\n  exports.isReactive = isReactive;\n  exports.isReadonly = isReadonly;\n  exports.isRef = isRef;\n  exports.isRuntimeOnly = isRuntimeOnly;\n  exports.isShallow = isShallow;\n  exports.isVNode = isVNode;\n  exports.markRaw = markRaw;\n  exports.mergeDefaults = mergeDefaults;\n  exports.mergeProps = mergeProps;\n  exports.nextTick = nextTick;\n  exports.normalizeClass = normalizeClass;\n  exports.normalizeProps = normalizeProps;\n  exports.normalizeStyle = normalizeStyle;\n  exports.onActivated = onActivated;\n  exports.onBeforeMount = onBeforeMount;\n  exports.onBeforeUnmount = onBeforeUnmount;\n  exports.onBeforeUpdate = onBeforeUpdate;\n  exports.onDeactivated = onDeactivated;\n  exports.onErrorCaptured = onErrorCaptured;\n  exports.onMounted = onMounted;\n  exports.onRenderTracked = onRenderTracked;\n  exports.onRenderTriggered = onRenderTriggered;\n  exports.onScopeDispose = onScopeDispose;\n  exports.onServerPrefetch = onServerPrefetch;\n  exports.onUnmounted = onUnmounted;\n  exports.onUpdated = onUpdated;\n  exports.openBlock = openBlock;\n  exports.popScopeId = popScopeId;\n  exports.provide = provide;\n  exports.proxyRefs = proxyRefs;\n  exports.pushScopeId = pushScopeId;\n  exports.queuePostFlushCb = queuePostFlushCb;\n  exports.reactive = reactive;\n  exports.readonly = readonly;\n  exports.ref = ref;\n  exports.registerRuntimeCompiler = registerRuntimeCompiler;\n  exports.render = render;\n  exports.renderList = renderList;\n  exports.renderSlot = renderSlot;\n  exports.resolveComponent = resolveComponent;\n  exports.resolveDirective = resolveDirective;\n  exports.resolveDynamicComponent = resolveDynamicComponent;\n  exports.resolveFilter = resolveFilter;\n  exports.resolveTransitionHooks = resolveTransitionHooks;\n  exports.setBlockTracking = setBlockTracking;\n  exports.setDevtoolsHook = setDevtoolsHook;\n  exports.setTransitionHooks = setTransitionHooks;\n  exports.shallowReactive = shallowReactive;\n  exports.shallowReadonly = shallowReadonly;\n  exports.shallowRef = shallowRef;\n  exports.ssrContextKey = ssrContextKey;\n  exports.ssrUtils = ssrUtils;\n  exports.stop = stop;\n  exports.toDisplayString = toDisplayString;\n  exports.toHandlerKey = toHandlerKey;\n  exports.toHandlers = toHandlers;\n  exports.toRaw = toRaw;\n  exports.toRef = toRef;\n  exports.toRefs = toRefs;\n  exports.transformVNodeArgs = transformVNodeArgs;\n  exports.triggerRef = triggerRef;\n  exports.unref = unref;\n  exports.useAttrs = useAttrs;\n  exports.useCssModule = useCssModule;\n  exports.useCssVars = useCssVars;\n  exports.useSSRContext = useSSRContext;\n  exports.useSlots = useSlots;\n  exports.useTransitionState = useTransitionState;\n  exports.vModelCheckbox = vModelCheckbox;\n  exports.vModelDynamic = vModelDynamic;\n  exports.vModelRadio = vModelRadio;\n  exports.vModelSelect = vModelSelect;\n  exports.vModelText = vModelText;\n  exports.vShow = vShow;\n  exports.version = version;\n  exports.warn = warn$1;\n  exports.watch = watch;\n  exports.watchEffect = watchEffect;\n  exports.watchPostEffect = watchPostEffect;\n  exports.watchSyncEffect = watchSyncEffect;\n  exports.withAsyncContext = withAsyncContext;\n  exports.withCtx = withCtx;\n  exports.withDefaults = withDefaults;\n  exports.withDirectives = withDirectives;\n  exports.withKeys = withKeys;\n  exports.withMemo = withMemo;\n  exports.withModifiers = withModifiers;\n  exports.withScopeId = withScopeId;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\n"]}